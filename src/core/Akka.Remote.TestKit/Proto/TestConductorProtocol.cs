//-----------------------------------------------------------------------
// <copyright file="TestConductorProtocol.cs" company="Akka.NET Project">
//     Copyright (C) 2009-2016 Lightbend Inc. <http://www.lightbend.com>
//     Copyright (C) 2013-2016 Akka.NET project <https://github.com/akkadotnet/akka.net>
// </copyright>
//-----------------------------------------------------------------------

// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace TCP {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class TestConductorProtocol {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Wrapper__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::TCP.Wrapper, global::TCP.Wrapper.Builder> internal__static_Wrapper__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Hello__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::TCP.Hello, global::TCP.Hello.Builder> internal__static_Hello__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_EnterBarrier__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::TCP.EnterBarrier, global::TCP.EnterBarrier.Builder> internal__static_EnterBarrier__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_AddressRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::TCP.AddressRequest, global::TCP.AddressRequest.Builder> internal__static_AddressRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Address__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::TCP.Address, global::TCP.Address.Builder> internal__static_Address__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_InjectFailure__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::TCP.InjectFailure, global::TCP.InjectFailure.Builder> internal__static_InjectFailure__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static TestConductorProtocol() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "ChtUZXN0Q29uZHVjdG9yUHJvdG9jb2wucHJvdG8ijgEKB1dyYXBwZXISFQoF" + 
          "aGVsbG8YASABKAsyBi5IZWxsbxIeCgdiYXJyaWVyGAIgASgLMg0uRW50ZXJC" + 
          "YXJyaWVyEh8KB2ZhaWx1cmUYAyABKAsyDi5JbmplY3RGYWlsdXJlEgwKBGRv" + 
          "bmUYBCABKAkSHQoEYWRkchgFIAEoCzIPLkFkZHJlc3NSZXF1ZXN0IjAKBUhl" + 
          "bGxvEgwKBG5hbWUYASACKAkSGQoHYWRkcmVzcxgCIAIoCzIILkFkZHJlc3Mi" + 
          "RQoMRW50ZXJCYXJyaWVyEgwKBG5hbWUYASACKAkSFgoCb3AYAiACKA4yCi5C" + 
          "YXJyaWVyT3ASDwoHdGltZW91dBgDIAEoAyI2Cg5BZGRyZXNzUmVxdWVzdBIM" + 
          "CgRub2RlGAEgAigJEhYKBGFkZHIYAiABKAsyCC5BZGRyZXNzIkcKB0FkZHJl" + 
          "c3MSEAoIcHJvdG9jb2wYASACKAkSDgoGc3lzdGVtGAIgAigJEgwKBGhvc3QY" + 
          "AyACKAkSDAoEcG9ydBgEIAIoBSKKAQoNSW5qZWN0RmFpbHVyZRIaCgdmYWls" + 
          "dXJlGAEgAigOMgkuRmFpbFR5cGUSHQoJZGlyZWN0aW9uGAIgASgOMgouRGly" + 
          "ZWN0aW9uEhkKB2FkZHJlc3MYAyABKAsyCC5BZGRyZXNzEhAKCHJhdGVNQml0" + 
          "GAYgASgCEhEKCWV4aXRWYWx1ZRgHIAEoBSo7CglCYXJyaWVyT3ASCQoFRW50" + 
          "ZXIQARIICgRGYWlsEAISDQoJU3VjY2VlZGVkEAMSCgoGRmFpbGVkEAQqXwoI" + 
          "RmFpbFR5cGUSDAoIVGhyb3R0bGUQARIOCgpEaXNjb25uZWN0EAISCQoFQWJv" + 
          "cnQQAxIICgRFeGl0EAQSDAoIU2h1dGRvd24QBRISCg5TaHV0ZG93bkFicnVw" + 
          "dBAGKiwKCURpcmVjdGlvbhIICgRTZW5kEAESCwoHUmVjZWl2ZRACEggKBEJv" + 
          "dGgQA0IdChlha2thLnJlbW90ZS50ZXN0Y29uZHVjdG9ySAE=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Wrapper__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Wrapper__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::TCP.Wrapper, global::TCP.Wrapper.Builder>(internal__static_Wrapper__Descriptor,
                new string[] { "Hello", "Barrier", "Failure", "Done", "Addr", });
        internal__static_Hello__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Hello__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::TCP.Hello, global::TCP.Hello.Builder>(internal__static_Hello__Descriptor,
                new string[] { "Name", "Address", });
        internal__static_EnterBarrier__Descriptor = Descriptor.MessageTypes[2];
        internal__static_EnterBarrier__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::TCP.EnterBarrier, global::TCP.EnterBarrier.Builder>(internal__static_EnterBarrier__Descriptor,
                new string[] { "Name", "Op", "Timeout", });
        internal__static_AddressRequest__Descriptor = Descriptor.MessageTypes[3];
        internal__static_AddressRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::TCP.AddressRequest, global::TCP.AddressRequest.Builder>(internal__static_AddressRequest__Descriptor,
                new string[] { "Node", "Addr", });
        internal__static_Address__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Address__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::TCP.Address, global::TCP.Address.Builder>(internal__static_Address__Descriptor,
                new string[] { "Protocol", "System", "Host", "Port", });
        internal__static_InjectFailure__Descriptor = Descriptor.MessageTypes[5];
        internal__static_InjectFailure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::TCP.InjectFailure, global::TCP.InjectFailure.Builder>(internal__static_InjectFailure__Descriptor,
                new string[] { "Failure", "Direction", "Address", "RateMBit", "ExitValue", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  public enum BarrierOp {
    Enter = 1,
    Fail = 2,
    Succeeded = 3,
    Failed = 4,
  }
  
  public enum FailType {
    Throttle = 1,
    Disconnect = 2,
    Abort = 3,
    Exit = 4,
    Shutdown = 5,
    ShutdownAbrupt = 6,
  }
  
  public enum Direction {
    Send = 1,
    Receive = 2,
    Both = 3,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Wrapper : pb::GeneratedMessage<Wrapper, Wrapper.Builder> {
    private Wrapper() { }
    private static readonly Wrapper defaultInstance = new Wrapper().MakeReadOnly();
    private static readonly string[] _wrapperFieldNames = new string[] { "addr", "barrier", "done", "failure", "hello" };
    private static readonly uint[] _wrapperFieldTags = new uint[] { 42, 18, 34, 26, 10 };
    public static Wrapper DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Wrapper DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Wrapper ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::TCP.TestConductorProtocol.internal__static_Wrapper__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Wrapper, Wrapper.Builder> InternalFieldAccessors {
      get { return global::TCP.TestConductorProtocol.internal__static_Wrapper__FieldAccessorTable; }
    }
    
    public const int HelloFieldNumber = 1;
    private bool hasHello;
    private global::TCP.Hello hello_;
    public bool HasHello {
      get { return hasHello; }
    }
    public global::TCP.Hello Hello {
      get { return hello_ ?? global::TCP.Hello.DefaultInstance; }
    }
    
    public const int BarrierFieldNumber = 2;
    private bool hasBarrier;
    private global::TCP.EnterBarrier barrier_;
    public bool HasBarrier {
      get { return hasBarrier; }
    }
    public global::TCP.EnterBarrier Barrier {
      get { return barrier_ ?? global::TCP.EnterBarrier.DefaultInstance; }
    }
    
    public const int FailureFieldNumber = 3;
    private bool hasFailure;
    private global::TCP.InjectFailure failure_;
    public bool HasFailure {
      get { return hasFailure; }
    }
    public global::TCP.InjectFailure Failure {
      get { return failure_ ?? global::TCP.InjectFailure.DefaultInstance; }
    }
    
    public const int DoneFieldNumber = 4;
    private bool hasDone;
    private string done_ = "";
    public bool HasDone {
      get { return hasDone; }
    }
    public string Done {
      get { return done_; }
    }
    
    public const int AddrFieldNumber = 5;
    private bool hasAddr;
    private global::TCP.AddressRequest addr_;
    public bool HasAddr {
      get { return hasAddr; }
    }
    public global::TCP.AddressRequest Addr {
      get { return addr_ ?? global::TCP.AddressRequest.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasHello) {
          if (!Hello.IsInitialized) return false;
        }
        if (HasBarrier) {
          if (!Barrier.IsInitialized) return false;
        }
        if (HasFailure) {
          if (!Failure.IsInitialized) return false;
        }
        if (HasAddr) {
          if (!Addr.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _wrapperFieldNames;
      if (hasHello) {
        output.WriteMessage(1, field_names[4], Hello);
      }
      if (hasBarrier) {
        output.WriteMessage(2, field_names[1], Barrier);
      }
      if (hasFailure) {
        output.WriteMessage(3, field_names[3], Failure);
      }
      if (hasDone) {
        output.WriteString(4, field_names[2], Done);
      }
      if (hasAddr) {
        output.WriteMessage(5, field_names[0], Addr);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasHello) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Hello);
        }
        if (hasBarrier) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Barrier);
        }
        if (hasFailure) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Failure);
        }
        if (hasDone) {
          size += pb::CodedOutputStream.ComputeStringSize(4, Done);
        }
        if (hasAddr) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, Addr);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Wrapper ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Wrapper ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Wrapper ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Wrapper ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Wrapper ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Wrapper ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Wrapper ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Wrapper ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Wrapper ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Wrapper ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Wrapper MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Wrapper prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Wrapper, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Wrapper cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Wrapper result;
      
      private Wrapper PrepareBuilder() {
        if (resultIsReadOnly) {
          Wrapper original = result;
          result = new Wrapper();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Wrapper MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::TCP.Wrapper.Descriptor; }
      }
      
      public override Wrapper DefaultInstanceForType {
        get { return global::TCP.Wrapper.DefaultInstance; }
      }
      
      public override Wrapper BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Wrapper) {
          return MergeFrom((Wrapper) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Wrapper other) {
        if (other == global::TCP.Wrapper.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHello) {
          MergeHello(other.Hello);
        }
        if (other.HasBarrier) {
          MergeBarrier(other.Barrier);
        }
        if (other.HasFailure) {
          MergeFailure(other.Failure);
        }
        if (other.HasDone) {
          Done = other.Done;
        }
        if (other.HasAddr) {
          MergeAddr(other.Addr);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wrapperFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wrapperFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::TCP.Hello.Builder subBuilder = global::TCP.Hello.CreateBuilder();
              if (result.hasHello) {
                subBuilder.MergeFrom(Hello);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Hello = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::TCP.EnterBarrier.Builder subBuilder = global::TCP.EnterBarrier.CreateBuilder();
              if (result.hasBarrier) {
                subBuilder.MergeFrom(Barrier);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Barrier = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::TCP.InjectFailure.Builder subBuilder = global::TCP.InjectFailure.CreateBuilder();
              if (result.hasFailure) {
                subBuilder.MergeFrom(Failure);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Failure = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              result.hasDone = input.ReadString(ref result.done_);
              break;
            }
            case 42: {
              global::TCP.AddressRequest.Builder subBuilder = global::TCP.AddressRequest.CreateBuilder();
              if (result.hasAddr) {
                subBuilder.MergeFrom(Addr);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Addr = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHello {
       get { return result.hasHello; }
      }
      public global::TCP.Hello Hello {
        get { return result.Hello; }
        set { SetHello(value); }
      }
      public Builder SetHello(global::TCP.Hello value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHello = true;
        result.hello_ = value;
        return this;
      }
      public Builder SetHello(global::TCP.Hello.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHello = true;
        result.hello_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHello(global::TCP.Hello value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHello &&
            result.hello_ != global::TCP.Hello.DefaultInstance) {
            result.hello_ = global::TCP.Hello.CreateBuilder(result.hello_).MergeFrom(value).BuildPartial();
        } else {
          result.hello_ = value;
        }
        result.hasHello = true;
        return this;
      }
      public Builder ClearHello() {
        PrepareBuilder();
        result.hasHello = false;
        result.hello_ = null;
        return this;
      }
      
      public bool HasBarrier {
       get { return result.hasBarrier; }
      }
      public global::TCP.EnterBarrier Barrier {
        get { return result.Barrier; }
        set { SetBarrier(value); }
      }
      public Builder SetBarrier(global::TCP.EnterBarrier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBarrier = true;
        result.barrier_ = value;
        return this;
      }
      public Builder SetBarrier(global::TCP.EnterBarrier.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBarrier = true;
        result.barrier_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBarrier(global::TCP.EnterBarrier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBarrier &&
            result.barrier_ != global::TCP.EnterBarrier.DefaultInstance) {
            result.barrier_ = global::TCP.EnterBarrier.CreateBuilder(result.barrier_).MergeFrom(value).BuildPartial();
        } else {
          result.barrier_ = value;
        }
        result.hasBarrier = true;
        return this;
      }
      public Builder ClearBarrier() {
        PrepareBuilder();
        result.hasBarrier = false;
        result.barrier_ = null;
        return this;
      }
      
      public bool HasFailure {
       get { return result.hasFailure; }
      }
      public global::TCP.InjectFailure Failure {
        get { return result.Failure; }
        set { SetFailure(value); }
      }
      public Builder SetFailure(global::TCP.InjectFailure value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFailure = true;
        result.failure_ = value;
        return this;
      }
      public Builder SetFailure(global::TCP.InjectFailure.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasFailure = true;
        result.failure_ = builderForValue.Build();
        return this;
      }
      public Builder MergeFailure(global::TCP.InjectFailure value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasFailure &&
            result.failure_ != global::TCP.InjectFailure.DefaultInstance) {
            result.failure_ = global::TCP.InjectFailure.CreateBuilder(result.failure_).MergeFrom(value).BuildPartial();
        } else {
          result.failure_ = value;
        }
        result.hasFailure = true;
        return this;
      }
      public Builder ClearFailure() {
        PrepareBuilder();
        result.hasFailure = false;
        result.failure_ = null;
        return this;
      }
      
      public bool HasDone {
        get { return result.hasDone; }
      }
      public string Done {
        get { return result.Done; }
        set { SetDone(value); }
      }
      public Builder SetDone(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDone = true;
        result.done_ = value;
        return this;
      }
      public Builder ClearDone() {
        PrepareBuilder();
        result.hasDone = false;
        result.done_ = "";
        return this;
      }
      
      public bool HasAddr {
       get { return result.hasAddr; }
      }
      public global::TCP.AddressRequest Addr {
        get { return result.Addr; }
        set { SetAddr(value); }
      }
      public Builder SetAddr(global::TCP.AddressRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAddr = true;
        result.addr_ = value;
        return this;
      }
      public Builder SetAddr(global::TCP.AddressRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAddr = true;
        result.addr_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAddr(global::TCP.AddressRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAddr &&
            result.addr_ != global::TCP.AddressRequest.DefaultInstance) {
            result.addr_ = global::TCP.AddressRequest.CreateBuilder(result.addr_).MergeFrom(value).BuildPartial();
        } else {
          result.addr_ = value;
        }
        result.hasAddr = true;
        return this;
      }
      public Builder ClearAddr() {
        PrepareBuilder();
        result.hasAddr = false;
        result.addr_ = null;
        return this;
      }
    }
    static Wrapper() {
      object.ReferenceEquals(global::TCP.TestConductorProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Hello : pb::GeneratedMessage<Hello, Hello.Builder> {
    private Hello() { }
    private static readonly Hello defaultInstance = new Hello().MakeReadOnly();
    private static readonly string[] _helloFieldNames = new string[] { "address", "name" };
    private static readonly uint[] _helloFieldTags = new uint[] { 18, 10 };
    public static Hello DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Hello DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Hello ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::TCP.TestConductorProtocol.internal__static_Hello__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Hello, Hello.Builder> InternalFieldAccessors {
      get { return global::TCP.TestConductorProtocol.internal__static_Hello__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int AddressFieldNumber = 2;
    private bool hasAddress;
    private global::TCP.Address address_;
    public bool HasAddress {
      get { return hasAddress; }
    }
    public global::TCP.Address Address {
      get { return address_ ?? global::TCP.Address.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasAddress) return false;
        if (!Address.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _helloFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[1], Name);
      }
      if (hasAddress) {
        output.WriteMessage(2, field_names[0], Address);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasAddress) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Address);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Hello ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Hello ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Hello ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Hello ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Hello ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Hello ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Hello ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Hello ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Hello ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Hello ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Hello MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Hello prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Hello, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Hello cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Hello result;
      
      private Hello PrepareBuilder() {
        if (resultIsReadOnly) {
          Hello original = result;
          result = new Hello();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Hello MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::TCP.Hello.Descriptor; }
      }
      
      public override Hello DefaultInstanceForType {
        get { return global::TCP.Hello.DefaultInstance; }
      }
      
      public override Hello BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Hello) {
          return MergeFrom((Hello) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Hello other) {
        if (other == global::TCP.Hello.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasAddress) {
          MergeAddress(other.Address);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_helloFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _helloFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              global::TCP.Address.Builder subBuilder = global::TCP.Address.CreateBuilder();
              if (result.hasAddress) {
                subBuilder.MergeFrom(Address);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Address = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasAddress {
       get { return result.hasAddress; }
      }
      public global::TCP.Address Address {
        get { return result.Address; }
        set { SetAddress(value); }
      }
      public Builder SetAddress(global::TCP.Address value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAddress = true;
        result.address_ = value;
        return this;
      }
      public Builder SetAddress(global::TCP.Address.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAddress = true;
        result.address_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAddress(global::TCP.Address value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAddress &&
            result.address_ != global::TCP.Address.DefaultInstance) {
            result.address_ = global::TCP.Address.CreateBuilder(result.address_).MergeFrom(value).BuildPartial();
        } else {
          result.address_ = value;
        }
        result.hasAddress = true;
        return this;
      }
      public Builder ClearAddress() {
        PrepareBuilder();
        result.hasAddress = false;
        result.address_ = null;
        return this;
      }
    }
    static Hello() {
      object.ReferenceEquals(global::TCP.TestConductorProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EnterBarrier : pb::GeneratedMessage<EnterBarrier, EnterBarrier.Builder> {
    private EnterBarrier() { }
    private static readonly EnterBarrier defaultInstance = new EnterBarrier().MakeReadOnly();
    private static readonly string[] _enterBarrierFieldNames = new string[] { "name", "op", "timeout" };
    private static readonly uint[] _enterBarrierFieldTags = new uint[] { 10, 16, 24 };
    public static EnterBarrier DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EnterBarrier DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EnterBarrier ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::TCP.TestConductorProtocol.internal__static_EnterBarrier__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EnterBarrier, EnterBarrier.Builder> InternalFieldAccessors {
      get { return global::TCP.TestConductorProtocol.internal__static_EnterBarrier__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int OpFieldNumber = 2;
    private bool hasOp;
    private global::TCP.BarrierOp op_ = global::TCP.BarrierOp.Enter;
    public bool HasOp {
      get { return hasOp; }
    }
    public global::TCP.BarrierOp Op {
      get { return op_; }
    }
    
    public const int TimeoutFieldNumber = 3;
    private bool hasTimeout;
    private long timeout_;
    public bool HasTimeout {
      get { return hasTimeout; }
    }
    public long Timeout {
      get { return timeout_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasOp) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _enterBarrierFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasOp) {
        output.WriteEnum(2, field_names[1], (int) Op, Op);
      }
      if (hasTimeout) {
        output.WriteInt64(3, field_names[2], Timeout);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasOp) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Op);
        }
        if (hasTimeout) {
          size += pb::CodedOutputStream.ComputeInt64Size(3, Timeout);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static EnterBarrier ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EnterBarrier ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EnterBarrier ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EnterBarrier ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EnterBarrier ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EnterBarrier ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EnterBarrier ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EnterBarrier ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EnterBarrier ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EnterBarrier ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EnterBarrier MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EnterBarrier prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EnterBarrier, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EnterBarrier cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EnterBarrier result;
      
      private EnterBarrier PrepareBuilder() {
        if (resultIsReadOnly) {
          EnterBarrier original = result;
          result = new EnterBarrier();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EnterBarrier MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::TCP.EnterBarrier.Descriptor; }
      }
      
      public override EnterBarrier DefaultInstanceForType {
        get { return global::TCP.EnterBarrier.DefaultInstance; }
      }
      
      public override EnterBarrier BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EnterBarrier) {
          return MergeFrom((EnterBarrier) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EnterBarrier other) {
        if (other == global::TCP.EnterBarrier.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasOp) {
          Op = other.Op;
        }
        if (other.HasTimeout) {
          Timeout = other.Timeout;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_enterBarrierFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _enterBarrierFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.op_, out unknown)) {
                result.hasOp = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 24: {
              result.hasTimeout = input.ReadInt64(ref result.timeout_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasOp {
       get { return result.hasOp; }
      }
      public global::TCP.BarrierOp Op {
        get { return result.Op; }
        set { SetOp(value); }
      }
      public Builder SetOp(global::TCP.BarrierOp value) {
        PrepareBuilder();
        result.hasOp = true;
        result.op_ = value;
        return this;
      }
      public Builder ClearOp() {
        PrepareBuilder();
        result.hasOp = false;
        result.op_ = global::TCP.BarrierOp.Enter;
        return this;
      }
      
      public bool HasTimeout {
        get { return result.hasTimeout; }
      }
      public long Timeout {
        get { return result.Timeout; }
        set { SetTimeout(value); }
      }
      public Builder SetTimeout(long value) {
        PrepareBuilder();
        result.hasTimeout = true;
        result.timeout_ = value;
        return this;
      }
      public Builder ClearTimeout() {
        PrepareBuilder();
        result.hasTimeout = false;
        result.timeout_ = 0L;
        return this;
      }
    }
    static EnterBarrier() {
      object.ReferenceEquals(global::TCP.TestConductorProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AddressRequest : pb::GeneratedMessage<AddressRequest, AddressRequest.Builder> {
    private AddressRequest() { }
    private static readonly AddressRequest defaultInstance = new AddressRequest().MakeReadOnly();
    private static readonly string[] _addressRequestFieldNames = new string[] { "addr", "node" };
    private static readonly uint[] _addressRequestFieldTags = new uint[] { 18, 10 };
    public static AddressRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AddressRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AddressRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::TCP.TestConductorProtocol.internal__static_AddressRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AddressRequest, AddressRequest.Builder> InternalFieldAccessors {
      get { return global::TCP.TestConductorProtocol.internal__static_AddressRequest__FieldAccessorTable; }
    }
    
    public const int NodeFieldNumber = 1;
    private bool hasNode;
    private string node_ = "";
    public bool HasNode {
      get { return hasNode; }
    }
    public string Node {
      get { return node_; }
    }
    
    public const int AddrFieldNumber = 2;
    private bool hasAddr;
    private global::TCP.Address addr_;
    public bool HasAddr {
      get { return hasAddr; }
    }
    public global::TCP.Address Addr {
      get { return addr_ ?? global::TCP.Address.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasNode) return false;
        if (HasAddr) {
          if (!Addr.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _addressRequestFieldNames;
      if (hasNode) {
        output.WriteString(1, field_names[1], Node);
      }
      if (hasAddr) {
        output.WriteMessage(2, field_names[0], Addr);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasNode) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Node);
        }
        if (hasAddr) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Addr);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AddressRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AddressRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AddressRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AddressRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AddressRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AddressRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AddressRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AddressRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AddressRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AddressRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AddressRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AddressRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AddressRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AddressRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AddressRequest result;
      
      private AddressRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          AddressRequest original = result;
          result = new AddressRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AddressRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::TCP.AddressRequest.Descriptor; }
      }
      
      public override AddressRequest DefaultInstanceForType {
        get { return global::TCP.AddressRequest.DefaultInstance; }
      }
      
      public override AddressRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AddressRequest) {
          return MergeFrom((AddressRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AddressRequest other) {
        if (other == global::TCP.AddressRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasNode) {
          Node = other.Node;
        }
        if (other.HasAddr) {
          MergeAddr(other.Addr);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_addressRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _addressRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasNode = input.ReadString(ref result.node_);
              break;
            }
            case 18: {
              global::TCP.Address.Builder subBuilder = global::TCP.Address.CreateBuilder();
              if (result.hasAddr) {
                subBuilder.MergeFrom(Addr);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Addr = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasNode {
        get { return result.hasNode; }
      }
      public string Node {
        get { return result.Node; }
        set { SetNode(value); }
      }
      public Builder SetNode(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasNode = true;
        result.node_ = value;
        return this;
      }
      public Builder ClearNode() {
        PrepareBuilder();
        result.hasNode = false;
        result.node_ = "";
        return this;
      }
      
      public bool HasAddr {
       get { return result.hasAddr; }
      }
      public global::TCP.Address Addr {
        get { return result.Addr; }
        set { SetAddr(value); }
      }
      public Builder SetAddr(global::TCP.Address value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAddr = true;
        result.addr_ = value;
        return this;
      }
      public Builder SetAddr(global::TCP.Address.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAddr = true;
        result.addr_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAddr(global::TCP.Address value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAddr &&
            result.addr_ != global::TCP.Address.DefaultInstance) {
            result.addr_ = global::TCP.Address.CreateBuilder(result.addr_).MergeFrom(value).BuildPartial();
        } else {
          result.addr_ = value;
        }
        result.hasAddr = true;
        return this;
      }
      public Builder ClearAddr() {
        PrepareBuilder();
        result.hasAddr = false;
        result.addr_ = null;
        return this;
      }
    }
    static AddressRequest() {
      object.ReferenceEquals(global::TCP.TestConductorProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Address : pb::GeneratedMessage<Address, Address.Builder> {
    private Address() { }
    private static readonly Address defaultInstance = new Address().MakeReadOnly();
    private static readonly string[] _addressFieldNames = new string[] { "host", "port", "protocol", "system" };
    private static readonly uint[] _addressFieldTags = new uint[] { 26, 32, 10, 18 };
    public static Address DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Address DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Address ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::TCP.TestConductorProtocol.internal__static_Address__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Address, Address.Builder> InternalFieldAccessors {
      get { return global::TCP.TestConductorProtocol.internal__static_Address__FieldAccessorTable; }
    }
    
    public const int ProtocolFieldNumber = 1;
    private bool hasProtocol;
    private string protocol_ = "";
    public bool HasProtocol {
      get { return hasProtocol; }
    }
    public string Protocol {
      get { return protocol_; }
    }
    
    public const int SystemFieldNumber = 2;
    private bool hasSystem;
    private string system_ = "";
    public bool HasSystem {
      get { return hasSystem; }
    }
    public string System {
      get { return system_; }
    }
    
    public const int HostFieldNumber = 3;
    private bool hasHost;
    private string host_ = "";
    public bool HasHost {
      get { return hasHost; }
    }
    public string Host {
      get { return host_; }
    }
    
    public const int PortFieldNumber = 4;
    private bool hasPort;
    private int port_;
    public bool HasPort {
      get { return hasPort; }
    }
    public int Port {
      get { return port_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasProtocol) return false;
        if (!hasSystem) return false;
        if (!hasHost) return false;
        if (!hasPort) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _addressFieldNames;
      if (hasProtocol) {
        output.WriteString(1, field_names[2], Protocol);
      }
      if (hasSystem) {
        output.WriteString(2, field_names[3], System);
      }
      if (hasHost) {
        output.WriteString(3, field_names[0], Host);
      }
      if (hasPort) {
        output.WriteInt32(4, field_names[1], Port);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasProtocol) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Protocol);
        }
        if (hasSystem) {
          size += pb::CodedOutputStream.ComputeStringSize(2, System);
        }
        if (hasHost) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Host);
        }
        if (hasPort) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, Port);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Address ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Address ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Address ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Address ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Address ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Address ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Address ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Address ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Address ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Address ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Address MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Address prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Address, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Address cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Address result;
      
      private Address PrepareBuilder() {
        if (resultIsReadOnly) {
          Address original = result;
          result = new Address();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Address MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::TCP.Address.Descriptor; }
      }
      
      public override Address DefaultInstanceForType {
        get { return global::TCP.Address.DefaultInstance; }
      }
      
      public override Address BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Address) {
          return MergeFrom((Address) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Address other) {
        if (other == global::TCP.Address.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProtocol) {
          Protocol = other.Protocol;
        }
        if (other.HasSystem) {
          System = other.System;
        }
        if (other.HasHost) {
          Host = other.Host;
        }
        if (other.HasPort) {
          Port = other.Port;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_addressFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _addressFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasProtocol = input.ReadString(ref result.protocol_);
              break;
            }
            case 18: {
              result.hasSystem = input.ReadString(ref result.system_);
              break;
            }
            case 26: {
              result.hasHost = input.ReadString(ref result.host_);
              break;
            }
            case 32: {
              result.hasPort = input.ReadInt32(ref result.port_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProtocol {
        get { return result.hasProtocol; }
      }
      public string Protocol {
        get { return result.Protocol; }
        set { SetProtocol(value); }
      }
      public Builder SetProtocol(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasProtocol = true;
        result.protocol_ = value;
        return this;
      }
      public Builder ClearProtocol() {
        PrepareBuilder();
        result.hasProtocol = false;
        result.protocol_ = "";
        return this;
      }
      
      public bool HasSystem {
        get { return result.hasSystem; }
      }
      public string System {
        get { return result.System; }
        set { SetSystem(value); }
      }
      public Builder SetSystem(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSystem = true;
        result.system_ = value;
        return this;
      }
      public Builder ClearSystem() {
        PrepareBuilder();
        result.hasSystem = false;
        result.system_ = "";
        return this;
      }
      
      public bool HasHost {
        get { return result.hasHost; }
      }
      public string Host {
        get { return result.Host; }
        set { SetHost(value); }
      }
      public Builder SetHost(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHost = true;
        result.host_ = value;
        return this;
      }
      public Builder ClearHost() {
        PrepareBuilder();
        result.hasHost = false;
        result.host_ = "";
        return this;
      }
      
      public bool HasPort {
        get { return result.hasPort; }
      }
      public int Port {
        get { return result.Port; }
        set { SetPort(value); }
      }
      public Builder SetPort(int value) {
        PrepareBuilder();
        result.hasPort = true;
        result.port_ = value;
        return this;
      }
      public Builder ClearPort() {
        PrepareBuilder();
        result.hasPort = false;
        result.port_ = 0;
        return this;
      }
    }
    static Address() {
      object.ReferenceEquals(global::TCP.TestConductorProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class InjectFailure : pb::GeneratedMessage<InjectFailure, InjectFailure.Builder> {
    private InjectFailure() { }
    private static readonly InjectFailure defaultInstance = new InjectFailure().MakeReadOnly();
    private static readonly string[] _injectFailureFieldNames = new string[] { "address", "direction", "exitValue", "failure", "rateMBit" };
    private static readonly uint[] _injectFailureFieldTags = new uint[] { 26, 16, 56, 8, 53 };
    public static InjectFailure DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override InjectFailure DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override InjectFailure ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::TCP.TestConductorProtocol.internal__static_InjectFailure__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<InjectFailure, InjectFailure.Builder> InternalFieldAccessors {
      get { return global::TCP.TestConductorProtocol.internal__static_InjectFailure__FieldAccessorTable; }
    }
    
    public const int FailureFieldNumber = 1;
    private bool hasFailure;
    private global::TCP.FailType failure_ = global::TCP.FailType.Throttle;
    public bool HasFailure {
      get { return hasFailure; }
    }
    public global::TCP.FailType Failure {
      get { return failure_; }
    }
    
    public const int DirectionFieldNumber = 2;
    private bool hasDirection;
    private global::TCP.Direction direction_ = global::TCP.Direction.Send;
    public bool HasDirection {
      get { return hasDirection; }
    }
    public global::TCP.Direction Direction {
      get { return direction_; }
    }
    
    public const int AddressFieldNumber = 3;
    private bool hasAddress;
    private global::TCP.Address address_;
    public bool HasAddress {
      get { return hasAddress; }
    }
    public global::TCP.Address Address {
      get { return address_ ?? global::TCP.Address.DefaultInstance; }
    }
    
    public const int RateMBitFieldNumber = 6;
    private bool hasRateMBit;
    private float rateMBit_;
    public bool HasRateMBit {
      get { return hasRateMBit; }
    }
    public float RateMBit {
      get { return rateMBit_; }
    }
    
    public const int ExitValueFieldNumber = 7;
    private bool hasExitValue;
    private int exitValue_;
    public bool HasExitValue {
      get { return hasExitValue; }
    }
    public int ExitValue {
      get { return exitValue_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasFailure) return false;
        if (HasAddress) {
          if (!Address.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _injectFailureFieldNames;
      if (hasFailure) {
        output.WriteEnum(1, field_names[3], (int) Failure, Failure);
      }
      if (hasDirection) {
        output.WriteEnum(2, field_names[1], (int) Direction, Direction);
      }
      if (hasAddress) {
        output.WriteMessage(3, field_names[0], Address);
      }
      if (hasRateMBit) {
        output.WriteFloat(6, field_names[4], RateMBit);
      }
      if (hasExitValue) {
        output.WriteInt32(7, field_names[2], ExitValue);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasFailure) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Failure);
        }
        if (hasDirection) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Direction);
        }
        if (hasAddress) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Address);
        }
        if (hasRateMBit) {
          size += pb::CodedOutputStream.ComputeFloatSize(6, RateMBit);
        }
        if (hasExitValue) {
          size += pb::CodedOutputStream.ComputeInt32Size(7, ExitValue);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static InjectFailure ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InjectFailure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InjectFailure ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InjectFailure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InjectFailure ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InjectFailure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static InjectFailure ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static InjectFailure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static InjectFailure ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InjectFailure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private InjectFailure MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(InjectFailure prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<InjectFailure, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(InjectFailure cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private InjectFailure result;
      
      private InjectFailure PrepareBuilder() {
        if (resultIsReadOnly) {
          InjectFailure original = result;
          result = new InjectFailure();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override InjectFailure MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::TCP.InjectFailure.Descriptor; }
      }
      
      public override InjectFailure DefaultInstanceForType {
        get { return global::TCP.InjectFailure.DefaultInstance; }
      }
      
      public override InjectFailure BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is InjectFailure) {
          return MergeFrom((InjectFailure) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(InjectFailure other) {
        if (other == global::TCP.InjectFailure.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasFailure) {
          Failure = other.Failure;
        }
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        if (other.HasAddress) {
          MergeAddress(other.Address);
        }
        if (other.HasRateMBit) {
          RateMBit = other.RateMBit;
        }
        if (other.HasExitValue) {
          ExitValue = other.ExitValue;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_injectFailureFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _injectFailureFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.failure_, out unknown)) {
                result.hasFailure = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.direction_, out unknown)) {
                result.hasDirection = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              global::TCP.Address.Builder subBuilder = global::TCP.Address.CreateBuilder();
              if (result.hasAddress) {
                subBuilder.MergeFrom(Address);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Address = subBuilder.BuildPartial();
              break;
            }
            case 53: {
              result.hasRateMBit = input.ReadFloat(ref result.rateMBit_);
              break;
            }
            case 56: {
              result.hasExitValue = input.ReadInt32(ref result.exitValue_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasFailure {
       get { return result.hasFailure; }
      }
      public global::TCP.FailType Failure {
        get { return result.Failure; }
        set { SetFailure(value); }
      }
      public Builder SetFailure(global::TCP.FailType value) {
        PrepareBuilder();
        result.hasFailure = true;
        result.failure_ = value;
        return this;
      }
      public Builder ClearFailure() {
        PrepareBuilder();
        result.hasFailure = false;
        result.failure_ = global::TCP.FailType.Throttle;
        return this;
      }
      
      public bool HasDirection {
       get { return result.hasDirection; }
      }
      public global::TCP.Direction Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(global::TCP.Direction value) {
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = global::TCP.Direction.Send;
        return this;
      }
      
      public bool HasAddress {
       get { return result.hasAddress; }
      }
      public global::TCP.Address Address {
        get { return result.Address; }
        set { SetAddress(value); }
      }
      public Builder SetAddress(global::TCP.Address value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAddress = true;
        result.address_ = value;
        return this;
      }
      public Builder SetAddress(global::TCP.Address.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAddress = true;
        result.address_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAddress(global::TCP.Address value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAddress &&
            result.address_ != global::TCP.Address.DefaultInstance) {
            result.address_ = global::TCP.Address.CreateBuilder(result.address_).MergeFrom(value).BuildPartial();
        } else {
          result.address_ = value;
        }
        result.hasAddress = true;
        return this;
      }
      public Builder ClearAddress() {
        PrepareBuilder();
        result.hasAddress = false;
        result.address_ = null;
        return this;
      }
      
      public bool HasRateMBit {
        get { return result.hasRateMBit; }
      }
      public float RateMBit {
        get { return result.RateMBit; }
        set { SetRateMBit(value); }
      }
      public Builder SetRateMBit(float value) {
        PrepareBuilder();
        result.hasRateMBit = true;
        result.rateMBit_ = value;
        return this;
      }
      public Builder ClearRateMBit() {
        PrepareBuilder();
        result.hasRateMBit = false;
        result.rateMBit_ = 0F;
        return this;
      }
      
      public bool HasExitValue {
        get { return result.hasExitValue; }
      }
      public int ExitValue {
        get { return result.ExitValue; }
        set { SetExitValue(value); }
      }
      public Builder SetExitValue(int value) {
        PrepareBuilder();
        result.hasExitValue = true;
        result.exitValue_ = value;
        return this;
      }
      public Builder ClearExitValue() {
        PrepareBuilder();
        result.hasExitValue = false;
        result.exitValue_ = 0;
        return this;
      }
    }
    static InjectFailure() {
      object.ReferenceEquals(global::TCP.TestConductorProtocol.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code

