#//#shared
#####################################
# Akka Remote Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

# comments about akka.actor settings left out where they are already in akka-
# actor.jar, because otherwise they would be repeated in config rendering.
#
# For the configuration of the new remoting implementation (Artery) please look
# at the bottom section of this file as it is listed separately.

akka {

  actor {

    serializers {
      akka-containers = "Akka.Remote.Serialization.MessageContainerSerializer, Akka.Remote"
      akka-misc = "Akka.Remote.Serialization.MiscMessageSerializer, Akka.Remote"
      # ARTERY: ArteryMessageSerializer is not implemented yet
      # artery = "Akka.Remote.Serialization.ArteryMessageSerializer, Akka.Remote"
      primitive = "Akka.Remote.Serialization.PrimitiveSerializers, Akka.Remote"
      proto = "Akka.Remote.Serialization.ProtobufSerializer, Akka.Remote"
      daemon-create = "Akka.Remote.Serialization.DaemonMsgCreateSerializer, Akka.Remote"
      akka-system-msg = "Akka.Remote.Serialization.SystemMessageSerializer, Akka.Remote"
    }

    serialization-bindings {
      "Akka.Actor.ActorSelectionMessage, Akka" = akka-containers
      "Akka.Remote.DaemonMsgCreate, Akka.Remote" = daemon-create

      # ARTERY: ArteryMessage is not implemented yet
      # "Akka.Remote.Artery.ArteryMessage" = artery

      "Google.Protobuf.IMessage, Google.Protobuf" = proto

      "Akka.Actor.Identify, Akka" = akka-misc
      "Akka.Actor.ActorIdentity, Akka" = akka-misc

      "Akka.Actor.Status+Success, Akka.Actor" = akka-misc # is this implemented?
      "Akka.Actor.Status+Failure, Akka.Actor" = akka-misc # is this implemented?

      "Akka.Actor.IActorRef, Akka" = akka-misc
      "Akka.Actor.PoisonPill, Akka" = akka-misc
      "Akka.Actor.Kill, Akka" = akka-misc

      # "Akka.Actor.LocalScope" = akka-misc
      # "Akka.Remote.RemoteScope" = akka-misc
      "Akka.Actor.RemoteScope, Akka" = akka-misc

      "Akka.Actor.ActorInitializationException, Akka" = akka-misc
      "Akka.Actor.IllegalActorStateException, Akka" = akka-misc
      "Akka.Actor.ActorKilledException, Akka" = akka-misc
      "Akka.Actor.InvalidActorNameException, Akka" = akka-misc
      "Akka.Actor.InvalidMessageException, Akka" = akka-misc
      # "java.util.concurrent.TimeoutException" = akka-misc
      # "Akka.Remote.Serialization.ThrowableNotSerializableException" = akka-misc

      "Akka.Routing.FromConfig, Akka" = akka-misc
      "Akka.Routing.DefaultResizer, Akka" = akka-misc
      "Akka.Routing.RoundRobinPool, Akka" = akka-misc
      "Akka.Routing.BroadcastPool, Akka" = akka-misc
      "Akka.Routing.RandomPool, Akka" = akka-misc
      "Akka.Routing.ScatterGatherFirstCompletedPool, Akka" = akka-misc
      "Akka.Routing.TailChoppingPool, Akka" = akka-misc
      "Akka.Routing.ConsistentHashingPool, Akka" = akka-misc

      "Akka.Configuration.Config, Akka" = akka-misc

      "Akka.Remote.RemoteWatcher+Heartbeat, Akka.Remote" = akka-misc
      "Akka.Remote.RemoteWatcher+HeartbeatRsp, Akka.Remote" = akka-misc
      "Akka.Remote.Routing.RemoteRouterConfig, Akka.Remote" = akka-misc

      "Akka.Dispatch.SysMsg.SystemMessage, Akka" = akka-system-msg

      "System.String" = primitive
      "System.Int32" = primitive
      "System.Int64" = primitive

      # "Akka.Done, Akka" = akka-misc #// ARTERY: is this implemented?
      # "Akka.NotUsed, Akka" = akka-misc #//  ARTERY: is this implemented?
      # "Akka.Actor.Address, Akka" = akka-misc #//  ARTERY: is this implemented?
      # "Akka.Remote.UniqueAddress, Akka.Remote" = akka-misc #//  ARTERY: is this implemented?

      # "Akka.Routing.SmallestMailboxPool, Akka" = akka-misc #//  ARTERY: is this implemented?

      # "Akka.Routing.RoundRobinGroup, Akka" = akka-misc #//  ARTERY: is this implemented?
      # "Akka.Routing.BroadcastGroup, Akka" = akka-misc #//  ARTERY: is this implemented?
      # "Akka.Routing.RandomGroup, Akka" = akka-misc #//  ARTERY: is this implemented?
      # "Akka.Routing.ScatterGatherFirstCompletedGroup, Akka" = akka-misc #//  ARTERY: is this implemented?
      # "Akka.Routing.TailChoppingGroup, Akka" = akka-misc #//  ARTERY: is this implemented?

      # "Akka.Routing.BalancingPool" = akka-misc #//  ARTERY: Akka.Routing.BalancingPool isn't implemented
    }

    serialization-identifiers {
      "Akka.Remote.Serialization.ProtobufSerializer, Akka.Remote" = 2
      "Akka.Remote.Serialization.DaemonMsgCreateSerializer, Akka.Remote" = 3
      "Akka.Remote.Serialization.MessageContainerSerializer, Akka.Remote" = 6
      "Akka.Remote.Serialization.MiscMessageSerializer, Akka.Remote" = 16
      "Akka.Remote.Serialization.PrimitiveSerializers, Akka.Remote" = 17
      # ARTERY: ArteryMessageSerializer is not implemented yet
      # "Akka.Remote.Serialization.ArteryMessageSerializer, Akka.Remote" = 18

      "Akka.Remote.Serialization.SystemMessageSerializer, Akka.Remote" = 22
    }

    deployment {

      default {

        # if this is set to a valid remote address, the named actor will be
        # deployed at that node e.g. "akka://sys@host:port"
        remote = ""

        target {

          # A list of hostnames and ports for instantiating the children of a
          # router
          #   The format should be on "akka://sys@host:port", where:
          #    - sys is the remote actor system name
          #    - hostname can be either hostname or IP address the remote actor
          #      should connect to
          #    - port should be the port for the remote server on the other node
          # The number of actor instances to be spawned is still taken from the
          # nr-of-instances setting as for local routers; the instances will be
          # distributed round-robin among the given nodes.
          nodes = []

        }
      }
    }
  }

  remote {
    ### Settings shared by classic remoting and Artery (the new implementation of remoting)

    # Using remoting directly is typically not desirable, so a warning will
    # be shown to make this clear. Set this setting to 'off' to suppress that
    # warning.
    warn-about-direct-use = on


    # If Cluster is not used, remote watch and deployment are disabled.
    # To optionally use them while not using Cluster, set to 'on'.
    use-unsafe-remote-features-outside-cluster = off

    # A warning will be logged on remote watch attempts if Cluster
    # is not in use and 'use-unsafe-remote-features-outside-cluster'
    # is 'off'. Set this to 'off' to suppress these.
    warn-unsafe-watch-outside-cluster = on

    # Settings for the Phi accrual failure detector (http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf
    # [Hayashibara et al]) used for remote death watch.
    # The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
    # the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,
    # i.e. around 12.5 seconds with default settings.
    watch-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = "Akka.Remote.PhiAccrualFailureDetector,Akka.Remote"

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 10.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 200

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 10 s


      # How often to check for nodes marked as unreachable by the failure
      # detector
      unreachable-nodes-reaper-interval = 1s

      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat mesage has
      # been received.
      expected-response-after = 1 s
    }

    # remote deployment configuration section
    deployment {
      # If true, will only allow specific classes to be instanciated on this system via remote deployment
      enable-whitelist = off

      whitelist = []
    }

    ### Default dispatcher for the remoting subsystem
    default-remote-dispatcher {
      type = Dispatcher
      executor = "fork-join-executor"
      fork-join-executor {
        parallelism-min = 2
        parallelism-factor = 0.5
        parallelism-max = 16
      }
      throughput = 10
    }

	# necessary to keep backwards compatibility
	helios.tcp.transport-class = "Akka.Remote.Transport.Helios.HeliosTcpTransport, Akka.Remote.Transport.Helios"
    #//#shared

    #//#classic
    # classic {
      ### Configuration for classic remoting. Classic remoting is deprecated, use artery.

      # If set to a nonempty string remoting will use the given dispatcher for
      # its internal actors otherwise the default dispatcher is used. Please note
      # that since remoting can load arbitrary 3rd party drivers (see
      # "enabled-transport" and "adapters" entries) it is not guaranteed that
      # every module will respect this setting.
      use-dispatcher = "akka.remote.default-remote-dispatcher"

      # Settings for the failure detector to monitor connections.
      # For TCP it is not important to have fast failure detection, since
      # most connection failures are captured by TCP itself.
      # The default DeadlineFailureDetector will trigger if there are no heartbeats within
      # the duration heartbeat-interval + acceptable-heartbeat-pause, i.e. 124 seconds
      # with the default settings.
      transport-failure-detector {

        # FQCN of the failure detector implementation.
        # It must implement akka.remote.FailureDetector and have
        # a public constructor with a com.typesafe.config.Config and
        # akka.actor.EventStream parameter.
        implementation-class = "Akka.Remote.DeadlineFailureDetector,Akka.Remote"
  
        # How often keep-alive heartbeat messages should be sent to each connection.
        heartbeat-interval = 4 s

        # Number of potentially lost/delayed heartbeats that will be
        # accepted before considering it to be an anomaly.
        # A margin to the `heartbeat-interval` is important to be able to survive sudden,
        # occasional, pauses in heartbeat arrivals, due to for example garbage collect or
        # network drop.
        acceptable-heartbeat-pause = 120 s
      }


      # Timeout after which the startup of the remoting subsystem is considered
      # to be failed. Increase this value if your transport drivers (see the
      # enabled-transports section) need longer time to be loaded.
      startup-timeout = 10 s

      # Timout after which the graceful shutdown of the remoting subsystem is
      # considered to be failed. After the timeout the remoting system is
      # forcefully shut down. Increase this value if your transport drivers
      # (see the enabled-transports section) need longer time to stop properly.
      shutdown-timeout = 10 s

      # Before shutting down the drivers, the remoting subsystem attempts to flush
      # all pending writes. This setting controls the maximum time the remoting is
      # willing to wait before moving on to shut down the drivers.
      flush-wait-on-shutdown = 2 s

      # Reuse inbound connections for outbound messages
      use-passive-connections = on

      # Controls the backoff interval after a refused write is reattempted.
      # (Transports may refuse writes if their internal buffer is full)
      # This value is 5 milliseconds in the scala implementation
      backoff-interval = 0.05 s

      # Acknowledgment timeout of management commands sent to the transport stack.
      command-ack-timeout = 30 s

      # The timeout for outbound associations to perform the handshake.
      # If the transport is akka.remote.dot-netty.tcp or akka.remote.dot-netty.ssl
      # the configured connection-timeout for the transport will be used instead.
      handshake-timeout = 15 s

      ### Security settings

      # Enable untrusted mode for full security of server managed actors, prevents
      # system messages to be send by clients, e.g. messages like 'Create',
      # 'Suspend', 'Resume', 'Terminate', 'Supervise', 'Link' etc.
      untrusted-mode = off

      # When 'untrusted-mode=on' inbound actor selections are by default discarded.
      # Actors with paths defined in this white list are granted permission to receive actor
      # selections messages.
      # E.g. trusted-selection-paths = ["/user/receptionist", "/user/namingService"]
      trusted-selection-paths = []

      ### Logging

      # If this is "on", Akka will log all inbound messages at DEBUG level,
      # if off then they are not logged
      log-received-messages = off

      # If this is "on", Akka will log all outbound messages at DEBUG level,
      # if off then they are not logged
      log-sent-messages = off

      # Sets the log granularity level at which Akka logs remoting events. This setting
      # can take the values OFF, ERROR, WARNING, INFO, DEBUG, or ON. For compatibility
      # reasons the setting "on" will default to "debug" level. Please note that the effective
      # logging level is still determined by the global logging level of the actor system:
      # for example debug level remoting events will be only logged if the system
      # is running with debug level logging.
      # Failures to deserialize received messages also fall under this flag.
      log-remote-lifecycle-events = on

      # Logging of message types with payload size in bytes larger than
      # this value. Maximum detected size per message type is logged once,
      # with an increase threshold of 10%.
      # By default this feature is turned off. Activate it by setting the property to
      # a value in bytes, such as 1000b. Note that for all messages larger than this
      # limit there will be extra performance and scalability cost.
      log-frame-size-exceeding = off

      # Log warning if the number of messages in the backoff buffer in the endpoint
      # writer exceeds this limit. It can be disabled by setting the value to off.
      log-buffer-size-exceeding = 50000

      # After failed to establish an outbound connection, the remoting will mark the
      # address as failed. This configuration option controls how much time should
      # be elapsed before reattempting a new connection. While the address is
      # gated, all messages sent to the address are delivered to dead-letters.
      # Since this setting limits the rate of reconnects setting it to a
      # very short interval (i.e. less than a second) may result in a storm of
      # reconnect attempts.
      retry-gate-closed-for = 5 s

      # After catastrophic communication failures that result in the loss of system
      # messages or after the remote DeathWatch triggers the remote system gets
      # quarantined to prevent inconsistent behavior.
      # This setting controls how long the Quarantine marker will be kept around
      # before being removed to avoid long-term memory leaks.
      # WARNING: DO NOT change this to a small value to re-enable communication with
      # quarantined nodes. Such feature is not supported and any behavior between
      # the affected systems after lifting the quarantine is undefined.
      prune-quarantine-marker-after = 5 d

      # If system messages have been exchanged between two systems (i.e. remote death
      # watch or remote deployment has been used) a remote system will be marked as
      # quarantined after the two system has no active association, and no
      # communication happens during the time configured here.
      # The only purpose of this setting is to avoid storing system message redelivery
      # data (sequence number state, etc.) for an undefined amount of time leading to long
      # term memory leak. Instead, if a system has been gone for this period,
      # or more exactly
      # - there is no association between the two systems (TCP connection, if TCP transport is used)
      # - neither side has been attempting to communicate with the other
      # - there are no pending system messages to deliver
      # for the amount of time configured here, the remote system will be quarantined and all state
      # associated with it will be dropped.
      #
      # Maximum value depends on the scheduler's max limit (default 248 days) and if configured
      # to a longer duration this feature will effectively be disabled. Setting the value to
      # 'off' will also disable the feature. Note that if disabled there is a risk of a long
      # term memory leak.
      quarantine-after-silence = 2 d

      # This setting defines the maximum number of unacknowledged system messages
      # allowed for a remote system. If this limit is reached the remote system is
      # declared to be dead and its UID marked as tainted.
      system-message-buffer-size = 20000

      # This setting defines the maximum idle time after an individual
      # acknowledgement for system messages is sent. System message delivery
      # is guaranteed by explicit acknowledgement messages. These acks are
      # piggybacked on ordinary traffic messages. If no traffic is detected
      # during the time period configured here, the remoting will send out
      # an individual ack.
      system-message-ack-piggyback-timeout = 0.3 s

      # This setting defines the time after internal management signals
      # between actors (used for DeathWatch and supervision) that have not been
      # explicitly acknowledged or negatively acknowledged are resent.
      # Messages that were negatively acknowledged are always immediately
      # resent.
      resend-interval = 2 s

      # Maximum number of unacknowledged system messages that will be resent
      # each 'resend-interval'. If you watch many (> 1000) remote actors you can
      # increase this value to for example 600, but a too large limit (e.g. 10000)
      # may flood the connection and might cause false failure detection to trigger.
      # Test such a configuration by watching all actors at the same time and stop
      # all watched actors at the same time.
      resend-limit = 200

      # WARNING: this setting should not be not changed unless all of its consequences
      # are properly understood which assumes experience with remoting internals
      # or expert advice.
      # This setting defines the time after redelivery attempts of internal management
      # signals are stopped to a remote system that has been not confirmed to be alive by
      # this system before.
      initial-system-message-delivery-timeout = 3 m

      ### Transports and adapters

      # List of the transport drivers that will be loaded by the remoting.
      # A list of fully qualified config paths must be provided where
      # the given configuration path contains a transport-class key
      # pointing to an implementation class of the Transport interface.
      # If multiple transports are provided, the address of the first
      # one will be used as a default address.
      enabled-transports = ["akka.remote.dot-netty.tcp"]

      # Transport drivers can be augmented with adapters by adding their
      # name to the applied-adapters setting in the configuration of a
      # transport. The available adapters should be configured in this
      # section by providing a name, and the fully qualified name of
      # their corresponding implementation. The class given here
      # must implement akka.akka.remote.transport.TransportAdapterProvider
      # and have public constructor without parameters.
      adapters {
        gremlin = "Akka.Remote.Transport.FailureInjectorProvider,Akka.Remote"
        trttl = "Akka.Remote.Transport.ThrottlerProvider,Akka.Remote"
      }

      ### Default configuration for the Netty based transport drivers

      dot-netty.tcp {
        # The class given here must implement the akka.remote.transport.Transport
        # interface and offer a public constructor which takes two arguments:
        #  1) akka.actor.ExtendedActorSystem
        #  2) com.typesafe.config.Config
        transport-class = "Akka.Remote.Transport.DotNetty.TcpTransport,Akka.Remote"

        # Transport drivers can be augmented with adapters by adding their
        # name to the applied-adapters list. The last adapter in the
        # list is the adapter immediately above the driver, while
        # the first one is the top of the stack below the standard
        # Akka protocol
        applied-adapters = []

        transport-protocol = tcp
        
	    # Byte order used for network communication. Event thou DotNetty is big-endian
	    # by default, we need to switch it back to little endian in order to support
	    # backward compatibility with Helios.
	    byte-order = "little-endian"

        # The default remote server port clients should connect to.
        # Default is 2552 (AKKA), use 0 if you want a random available port
        # This port needs to be unique for each actor system on the same machine.
        port = 2552

        # Similar in spirit to "public-hostname" setting, this allows Akka.Remote users
        # to alias the port they're listening on. The socket will actually listen on the
        # "port" setting, but when connecting to other ActorSystems this node will advertise
        # itself as being connected to the "public-port". This is helpful when working with 
        # hosting environments that rely on address translation and port-forwarding, such as Docker.
        #
        # Leave this setting to "0" if you don't intend to use it.
        public-port = 0

        # The hostname or ip clients should connect to.
        # InetAddress.getLocalHost.getHostAddress is used if empty
        hostname = ""

	    # If this value is set, this becomes the public address for the actor system on this
	    # transport, which might be different than the physical ip address (hostname)
	    # this is designed to make it easy to support private / public addressing schemes
	    public-hostname = ""

	    # If set to true, we will use IPV6 addresses upon DNS resolution for host names.
	    # Otherwise, we will use IPV4.
	    dns-use-ipv6 = false

	    # If set to true, we will enforce usage of IPV4 or IPV6 addresses upon DNS resolution for host names.
	    # If dns-use-ipv6 = true, we will use IPV6 enforcement
	    # Otherwise, we will use IPV4.
	    # Warning: when ip family is enforced, any connection between IPV4 and IPV6 is impossible
	    #
	    # enforce-ip-family setting is used only in some special cases, when default behaviour of 
	    # underlying sockets leads to errors. Typically this occurs when an environment doesn't support
	    # IPV6 or dual-mode sockets.
	    # As of 09/21/2016 there are two known cases: running under Mono and in Azure WebApp  
	    # for them we will need enforce-ip-family = true, and for Azure dns-use-ipv6 = false
	    # This property is always set to true if Mono runtime is detected.

	    enforce-ip-family = false

        # Enables SSL support on this transport
        enable-ssl = false

	    # Enables backwards compatibility with Akka.Remote clients running Helios 1.*
	    enable-backwards-compatibility = false

        # Sets the connectTimeoutMillis of all outbound connections,
        # i.e. how long a connect may take until it is timed out
        connection-timeout = 15 s

        # PERFORMANCE TUNING
        # 
        # The batching feature of DotNetty is designed to help batch together logical writes into a smaller
        # number of physical writes across the socket. This helps significantly reduce the number of system calls
        # and can improve performance by as much as 150% on some systems when enabled.
        batching{

          # Enables the batching system. When disabled, every write will be flushed immediately.
          # Disable this setting if you're working with a VERY low-traffic system that requires
          # fast (< 40ms) acknowledgement for all periodic messages.
          enabled = true

          # The max write threshold based on the number of logical messages regardless of their size. 
          # This is a safe default value - decrease it if you have a small number of remote actors
          # who engage in frequent request->response communication which requires low latency (< 40ms).
          max-pending-writes = 30

          # The max write threshold based on the byte size of all buffered messages. If there are 4 messages
          # waiting to be written (with batching.max-pending-writes = 30) but their total size is greater than
          # batching.max-pending-bytes, a flush will be triggered immediately.
          #
          # Increase this value is you have larger message sizes and watch to take advantage of batching, but
          # otherwise leave it as-is.
          #
          # NOTE: this value should always be smaller than dot-netty.tcp.maximum-frame-size.
          max-pending-bytes = 16k

          # In the event that neither the batching.max-pending-writes or batching.max-pending-bytes
          # is hit we guarantee that all pending writes will be flushed within this interval.
          #
          # This setting, realistically, can't be enforced any lower than the OS' clock resolution (~20ms).
          # If you have a very low-traffic system, either disable pooling altogether or lower the batching.max-pending-writes
          # threshold to maximize throughput. Otherwise, leave this setting as-is.
          flush-interval = 40ms
        }

        # If set to "<id.of.dispatcher>" then the specified dispatcher
        # will be used to accept inbound connections, and perform IO. If "" then
        # dedicated threads will be used.
        # Please note that the Netty driver only uses this configuration and does
        # not read the "akka.remote.use-dispatcher" entry. Instead it has to be
        # configured manually to point to the same dispatcher if needed.
        use-dispatcher-for-io = ""

        # Sets the high water mark for the in and outbound sockets,
        # set to 0b for platform default
        write-buffer-high-water-mark = 0b

        # Sets the low water mark for the in and outbound sockets,
        # set to 0b for platform default
        write-buffer-low-water-mark = 0b

        # Sets the send buffer size of the Sockets,
        # set to 0b for platform default
        send-buffer-size = 256000b

        # Sets the receive buffer size of the Sockets,
        # set to 0b for platform default
        receive-buffer-size = 256000b

        # Maximum message size the transport will accept, but at least
        # 32000 bytes.
        # Please note that UDP does not support arbitrary large datagrams,
        # so this setting has to be chosen carefully when using UDP.
        # Both send-buffer-size and receive-buffer-size settings has to
        # be adjusted to be able to buffer messages of maximum size.
        maximum-frame-size = 128000b

        # Sets the size of the connection backlog
        backlog = 4096

        # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm
        tcp-nodelay = on

        # Enables TCP Keepalive, subject to the O/S kernel’s configuration
        tcp-keepalive = on

        # Enables SO_REUSEADDR, which determines when an ActorSystem can open
        # the specified listen port (the meaning differs between *nix and Windows)
        # Valid values are "on", "off" and "off-for-windows"
        # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378
        # "off-for-windows" of course means that it's "on" for all other platforms
        tcp-reuse-addr = off-for-windows

        # Used to configure the number of I/O worker threads on server sockets
        server-socket-worker-pool {
          # Min number of threads to cap factor-based number to
          pool-size-min = 2

          # The pool size factor is used to determine thread pool size
          # using the following formula: ceil(available processors * factor).
          # Resulting size is then bounded by the pool-size-min and
          # pool-size-max values.
          pool-size-factor = 1.0

          # Max number of threads to cap factor-based number to
          pool-size-max = 2
        }

        # Used to configure the number of I/O worker threads on client sockets
        client-socket-worker-pool {
          # Min number of threads to cap factor-based number to
          pool-size-min = 2

          # The pool size factor is used to determine thread pool size
          # using the following formula: ceil(available processors * factor).
          # Resulting size is then bounded by the pool-size-min and
          # pool-size-max values.
          pool-size-factor = 1.0

          # Max number of threads to cap factor-based number to
          pool-size-max = 2
        }
      }

      dot-netty.udp = ${akka.remote.dot-netty.tcp}
      dot-netty.udp {
        transport-protocol = udp
      }

      dot-netty.ssl = ${akka.remote.dot-netty.tcp}
      dot-netty.ssl = {
        certificate {
          # Valid certificate path required
          path = ""
          # Valid certificate password required
          password = ""
          # Default key storage flag is "default-key-set"
          # Available flags include: 
          #     default-key-set | exportable | machine-key-set | persist-key-set | user-key-set | user-protected
          # flags = [ "default-key-set" ]

          # To use a Thumbprint instead of a file, set this to true
          # And specify a thumprint and it's storage location below
          use-thumprint-over-file = false

          # Valid Thumprint required (if use-thumbprint-over-file is true)
          # A typical thumbprint is a format similar to: "45df32e258c92a7abf6c112e54912ab15bbb9eb0"
          # On Windows machines, The thumprint for an installed certificate can be located
          # By using certlm.msc and opening the certificate under the 'Details' tab.
          thumbprint = ""

          # The Store name. Under windows The most common option is "My", which indicates the personal store.
          # See System.Security.Cryptography.X509Certificates.StoreName for other common values.
          store-name = ""

          # Valid options : local-machine or current-user
          # current-user indicates a certificate stored under the user's account
          # local-machine indicates a certificate stored at an operating system level (potentially shared by users)
          store-location = "current-user"
        }
        suppress-validation = false
      }

      ### Default configuration for the failure injector transport adapter

      gremlin {
        # Enable debug logging of the failure injector transport adapter
        debug = off
      }

      backoff-remote-dispatcher {
        type = Dispatcher
        executor = "fork-join-executor"
        fork-join-executor {
          # Min number of threads to cap factor-based parallelism number to
          parallelism-min = 2
          parallelism-max = 2
        }
      }
    # }
    #//#classic

    #//#artery
    ### Configuration for Artery, the new implementation of remoting
    artery {

      # Disable artery with this flag
      enabled = on

      # Select the underlying transport implementation.
      #
      # Possible values: aeron-udp, tcp, tls-tcp
      # See https://doc.akka.io/docs/akka/current/remoting-artery.html#selecting-a-transport for the tradeoffs
      # for each transport
      transport = tcp

      # Canonical address is the address other clients should connect to.
      # Artery transport will expect messages to this address.
      canonical {

        # The default remote server port clients should connect to.
        # Default is 25520, use 0 if you want a random available port
        # This port needs to be unique for each actor system on the same machine.
        port = 25520

        # Hostname clients should connect to. Can be set to an ip, hostname
        # or one of the following special values:
        #   "<getHostAddress>"   InetAddress.getLocalHost.getHostAddress
        #   "<getHostName>"      InetAddress.getLocalHost.getHostName
        #
        hostname = "<getHostAddress>"
      }

      # Use these settings to bind a network interface to a different address
      # than artery expects messages at. This may be used when running Akka
      # nodes in a separated networks (under NATs or in containers). If canonical
      # and bind addresses are different, then network configuration that relays
      # communications from canonical to bind addresses is expected.
      bind {

        # Port to bind a network interface to. Can be set to a port number
        # of one of the following special values:
        #   0    random available port
        #   ""   akka.remote.artery.canonical.port
        #
        port = ""

        # Hostname to bind a network interface to. Can be set to an ip, hostname
        # or one of the following special values:
        #   "0.0.0.0"            all interfaces
        #   ""                   akka.remote.artery.canonical.hostname
        #   "<getHostAddress>"   InetAddress.getLocalHost.getHostAddress
        #   "<getHostName>"      InetAddress.getLocalHost.getHostName
        #
        hostname = ""

        # Time to wait for Aeron/TCP to bind
        bind-timeout = 3s
      }


      # Actor paths to use the large message stream for when a message
      # is sent to them over remoting. The large message stream dedicated
      # is separate from "normal" and system messages so that sending a
      # large message does not interfere with them.
      # Entries should be the full path to the actor. Wildcards in the form of "*"
      # can be supplied at any place and matches any name at that segment -
      # "/user/supervisor/actor/*" will match any direct child to actor,
      # while "/supervisor/*/child" will match any grandchild to "supervisor" that
      # has the name "child"
      # Entries have to be specified on both the sending and receiving side.
      # Messages sent to ActorSelections will not be passed through the large message
      # stream, to pass such messages through the large message stream the selections
      # but must be resolved to ActorRefs first.
      large-message-destinations = []

      # Enable untrusted mode, which discards inbound system messages, PossiblyHarmful and
      # ActorSelection messages. E.g. remote watch and remote deployment will not work.
      # ActorSelection messages can be enabled for specific paths with the trusted-selection-paths
      untrusted-mode = off

      # When 'untrusted-mode=on' inbound actor selections are by default discarded.
      # Actors with paths defined in this white list are granted permission to receive actor
      # selections messages.
      # E.g. trusted-selection-paths = ["/user/receptionist", "/user/namingService"]
      trusted-selection-paths = []

      # If this is "on", all inbound remote messages will be logged at DEBUG level,
      # if off then they are not logged
      log-received-messages = off

      # If this is "on", all outbound remote messages will be logged at DEBUG level,
      # if off then they are not logged
      log-sent-messages = off

      advanced {

        # Maximum serialized message size, including header data.
        maximum-frame-size = 256 KiB

        # Direct byte buffers are reused in a pool with this maximum size.
        # Each buffer has the size of 'maximum-frame-size'.
        # This is not a hard upper limit on number of created buffers. Additional
        # buffers will be created if needed, e.g. when using many outbound
        # associations at the same time. Such additional buffers will be garbage
        # collected, which is not as efficient as reusing buffers in the pool.
        buffer-pool-size = 128

        # Maximum serialized message size for the large messages, including header data.
        # It is currently restricted to 1/8th the size of a term buffer that can be
        # configured by setting the 'aeron.term.buffer.length' system property.
        # See 'large-message-destinations'.
        maximum-large-frame-size = 2 MiB

        # Direct byte buffers for the large messages are reused in a pool with this maximum size.
        # Each buffer has the size of 'maximum-large-frame-size'.
        # See 'large-message-destinations'.
        # This is not a hard upper limit on number of created buffers. Additional
        # buffers will be created if needed, e.g. when using many outbound
        # associations at the same time. Such additional buffers will be garbage
        # collected, which is not as efficient as reusing buffers in the pool.
        large-buffer-pool-size = 32

        # For enabling testing features, such as blackhole in akka-remote-testkit.
        test-mode = off

        # Settings for the materializer that is used for the remote streams.
        materializer = {

          # Initial size of buffers used in stream elements
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          initial-input-buffer-size = 4

          # Maximum size of buffers used in stream elements
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          max-input-buffer-size = 16

          # Fully qualified config path which holds the dispatcher configuration
          # to be used by FlowMaterialiser when creating Actors.
          # When this value is left empty, the default-dispatcher will be used.
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          dispatcher = ""

          # Cleanup leaked publishers and subscribers when they are not used within a given
          # deadline
          subscription-timeout {
            # when the subscription timeout is reached one of the following strategies on
            # the "stale" publisher:
            # cancel - cancel it (via `onError` or subscribing to the publisher and
            #          `cancel()`ing the subscription right away
            # warn   - log a warning statement about the stale element (then drop the
            #          reference to it)
            # noop   - do nothing (not recommended)		
	        # Note: If you change this value also change the fallback value in StreamSubscriptionTimeoutSettings
            mode = cancel

            # time after which a subscriber / publisher is considered stale and eligible
            # for cancelation (see `akka.stream.subscription-timeout.mode`)		
	        # Note: If you change this value also change the fallback value in StreamSubscriptionTimeoutSettings
            timeout = 5s
          }
      
          # Enable additional troubleshooting logging at DEBUG log level
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          debug-logging = off

          # Maximum number of elements emitted in batch if downstream signals large demand
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          output-burst-limit = 1000
      
          # Enable automatic fusing of all graphs that are run. For short-lived streams
          # this may cause an initial runtime overhead, but most of the time fusing is
          # desirable since it reduces the number of Actors that are created.
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          auto-fusing = on

	      # Those stream elements which have explicit buffers (like mapAsync, mapAsyncUnordered,
          # buffer, flatMapMerge, Source.actorRef, Source.queue, etc.) will preallocate a fixed
          # buffer upon stream materialization if the requested buffer size is less than this
          # configuration parameter. The default is very high because failing early is better
          # than failing under load.
          #
          # Buffers sized larger than this will dynamically grow/shrink and consume more memory
          # per element than the fixed size buffers.
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
          max-fixed-buffer-size = 1000000000

	      # Maximum number of sync messages that actor can process for stream to substream communication.
	      # Parameter allows to interrupt synchronous processing to get upsteam/downstream messages.
	      # Allows to accelerate message processing that happening withing same actor but keep system responsive.
	      # Note: If you change this value also change the fallback value in ActorMaterializerSettings
	      sync-processing-limit = 1000

          debug {
            # Enables the fuzzing mode which increases the chance of race conditions
            # by aggressively reordering events and making certain operations more
            # concurrent than usual.
            # This setting is for testing purposes, NEVER enable this in a production
            # environment!
            # To get the best results, try combining this setting with a throughput
            # of 1 on the corresponding dispatchers.
	        # Note: If you change this value also change the fallback value in ActorMaterializerSettings
            fuzzing-mode = off
          }
      
          stream-ref {
            # Buffer of a SinkRef that is used to batch Request elements from the other side of the stream ref
            #
            # The buffer will be attempted to be filled eagerly even while the local stage did not request elements,
            # because the delay of requesting over network boundaries is much higher.
            buffer-capacity = 32
      
            # Demand is signalled by sending a cumulative demand message ("requesting messages until the n-th sequence number)
            # Using a cumulative demand model allows us to re-deliver the demand message in case of message loss (which should
            # be very rare in any case, yet possible -- mostly under connection break-down and re-establishment).
            #
            # The semantics of handling and updating the demand however are in-line with what Reactive Streams dictates.
            #
            # In normal operation, demand is signalled in response to arriving elements, however if no new elements arrive
            # within `demand-redelivery-interval` a re-delivery of the demand will be triggered, assuming that it may have gotten lost.
            demand-redelivery-interval = 1 second
      
            # Subscription timeout, during which the "remote side" MUST subscribe (materialize) the handed out stream ref.
            # This timeout does not have to be very low in normal situations, since the remote side may also need to
            # prepare things before it is ready to materialize the reference. However the timeout is needed to avoid leaking
            # in-active streams which are never subscribed to.
            subscription-timeout = 30 seconds
        
            # In order to guard the receiving end of a stream ref from never terminating (since awaiting a Completion or Failed
            # message) after / before a Terminated is seen, a special timeout is applied once Terminated is received by it.
            # This allows us to terminate stream refs that have been targeted to other nodes which are Downed, and as such the
            # other side of the stream ref would never send the "final" terminal message.
            #
            # The timeout specifically means the time between the Terminated signal being received and when the local SourceRef
            # determines to fail itself, assuming there was message loss or a complete partition of the completion signal.
            final-termination-signal-deadline = 2 seconds
          }
        }

        # Remoting will use the given dispatcher for the ordinary and large message
        # streams.
        use-dispatcher = "akka.remote.default-remote-dispatcher"

        # Remoting will use the given dispatcher for the control stream.
        # It can be good to not use the same dispatcher for the control stream as
        # the dispatcher for the ordinary message stream so that heartbeat messages
        # are not disturbed.
        use-control-stream-dispatcher = "akka.actor.internal-dispatcher"


        # Total number of inbound lanes, shared among all inbound associations. A value
        # greater than 1 means that deserialization can be performed in parallel for
        # different destination actors. The selection of lane is based on consistent
        # hashing of the recipient ActorRef to preserve message ordering per receiver.
        # Lowest latency can be achieved with inbound-lanes=1 because of one less
        # asynchronous boundary.
        inbound-lanes = 4

        # Number of outbound lanes for each outbound association. A value greater than 1
        # means that serialization and other work can be performed in parallel for different
        # destination actors. The selection of lane is based on consistent hashing of the
        # recipient ActorRef to preserve message ordering per receiver. Note that messages
        # for different destination systems (hosts) are handled by different streams also
        # when outbound-lanes=1. Lowest latency can be achieved with outbound-lanes=1
        # because of one less asynchronous boundary.
        outbound-lanes = 1

        # Size of the send queue for outgoing messages. Messages will be dropped if
        # the queue becomes full. This may happen if you send a burst of many messages
        # without end-to-end flow control. Note that there is one such queue per
        # outbound association. The trade-off of using a larger queue size is that
        # it consumes more memory, since the queue is based on preallocated array with
        # fixed size.
        outbound-message-queue-size = 3072

        # Size of the send queue for outgoing control messages, such as system messages.
        # If this limit is reached the remote system is declared to be dead and its UID
        # marked as quarantined. Note that there is one such queue per outbound association.
        # It is a linked queue so it will not use more memory than needed but by increasing
        # too much you may risk OutOfMemoryError in the worst case.
        outbound-control-queue-size = 20000

        # Size of the send queue for outgoing large messages. Messages will be dropped if
        # the queue becomes full. This may happen if you send a burst of many messages
        # without end-to-end flow control. Note that there is one such queue per
        # outbound association.
        # It is a linked queue so it will not use more memory than needed but by increasing
        # too much you may risk OutOfMemoryError, especially since the message payload
        # of these messages may be large.
        outbound-large-message-queue-size = 256

        # This setting defines the maximum number of unacknowledged system messages
        # allowed for a remote system. If this limit is reached the remote system is
        # declared to be dead and its UID marked as quarantined.
        system-message-buffer-size = 20000

        # unacknowledged system messages are re-delivered with this interval
        system-message-resend-interval = 1 second



        # The timeout for outbound associations to perform the initial handshake.
        # This timeout must be greater than the 'image-liveness-timeout' when
        # transport is aeron-udp.
        handshake-timeout = 20 seconds

        # incomplete initial handshake attempt is retried with this interval
        handshake-retry-interval = 1 second

        # Handshake requests are performed periodically with this interval,
        # also after the handshake has been completed to be able to establish
        # a new session with a restarted destination system.
        inject-handshake-interval = 1 second


        # System messages that are not acknowledged after re-sending for this period are
        # dropped and will trigger quarantine. The value should be longer than the length
        # of a network partition that you need to survive.
        give-up-system-message-after = 6 hours

        # Outbound streams are stopped when they haven't been used for this duration.
        # They are started again when new messages are sent.
        stop-idle-outbound-after = 5 minutes

        # Outbound streams are quarantined when they haven't been used for this duration
        # to cleanup resources used by the association, such as compression tables.
        # This will cleanup association to crashed systems that didn't announce their
        # termination.
        # The value should be longer than the length of a network partition that you
        # need to survive.
        # The value must also be greater than stop-idle-outbound-after.
        # Once every 1/10 of this duration an extra handshake message will be sent.
        # Therfore it's also recommended to use a value that is greater than 10 times
        # the stop-idle-outbound-after, since otherwise the idle streams will not be
        # stopped.
        quarantine-idle-outbound-after = 6 hours

        # Stop outbound stream of a quarantined association after this idle timeout, i.e.
        # when not used any more.
        stop-quarantined-after-idle = 3 seconds

        # After catastrophic communication failures that could result in the loss of system
        # messages or after the remote DeathWatch triggers the remote system gets
        # quarantined to prevent inconsistent behavior.
        # This setting controls how long the quarantined association will be kept around
        # before being removed to avoid long-term memory leaks. It must be quarantined
        # and also unused for this duration before it's removed. When removed the historical
        # information about which UIDs that were quarantined for that hostname:port is
        # gone which could result in communication with a previously quarantined node
        # if it wakes up again. Therfore this shouldn't be set too low.
        remove-quarantined-association-after = 1 h

        # during ActorSystem termination the remoting will wait this long for
        # an acknowledgment by the destination system that flushing of outstanding
        # remote messages has been completed
        shutdown-flush-timeout = 1 second

        # See 'inbound-max-restarts'
        inbound-restart-timeout = 5 seconds

        # Max number of restarts within 'inbound-restart-timeout' for the inbound streams.
        # If more restarts occurs the ActorSystem will be terminated.
        inbound-max-restarts = 5

        # Retry outbound connection after this backoff.
        # Only used when transport is tcp or tls-tcp.
        outbound-restart-backoff = 1 second

        # See 'outbound-max-restarts'
        outbound-restart-timeout = 5 seconds

        # Max number of restarts within 'outbound-restart-timeout' for the outbound streams.
        # If more restarts occurs the ActorSystem will be terminated.
        outbound-max-restarts = 5

        # compression of common strings in remoting messages, like actor destinations, serializers etc
        compression = {

          actor-refs {
            # Max number of compressed actor-refs
            # Note that compression tables are "rolling" (i.e. a new table replaces the old
            # compression table once in a while), and this setting is only about the total number
            # of compressions within a single such table.
            # Must be a positive natural number.
            max = 256

            # interval between new table compression advertisements.
            # this means the time during which we collect heavy-hitter data and then turn it into a compression table.
            advertisement-interval = 1 minute
          }
          manifests {
            # Max number of compressed manifests
            # Note that compression tables are "rolling" (i.e. a new table replaces the old
            # compression table once in a while), and this setting is only about the total number
            # of compressions within a single such table.
            # Must be a positive natural number.
            max = 256

            # interval between new table compression advertisements.
            # this means the time during which we collect heavy-hitter data and then turn it into a compression table.
            advertisement-interval = 1 minute
          }
        }

        # List of fully qualified class names of remote instruments which should
        # be initialized and used for monitoring of remote messages.
        # The class must extend akka.remote.artery.RemoteInstrument and
        # have a public constructor with empty parameters or one ExtendedActorSystem
        # parameter.
        # A new instance of RemoteInstrument will be created for each encoder and decoder.
        # It's only called from the stage, so if it dosn't delegate to any shared instance
        # it doesn't have to be thread-safe.
        # Refer to `akka.remote.artery.RemoteInstrument` for more information.

        # ARTERY: this substitution somehow causes a stack overflow
        # instruments = ${?akka.remote.artery.advanced.instruments} []
        instruments = []

        # Only used when transport is aeron-udp
        aeron = {
          # Periodically log out all Aeron counters. See https://github.com/real-logic/aeron/wiki/Monitoring-and-Debugging#counters
          # Only used when transport is aeron-udp.
          log-aeron-counters = false

          # Controls whether to start the Aeron media driver in the same JVM or use external
          # process. Set to 'off' when using external media driver, and then also set the
          # 'aeron-dir'.
          # Only used when transport is aeron-udp.
          embedded-media-driver = on

          # Directory used by the Aeron media driver. It's mandatory to define the 'aeron-dir'
          # if using external media driver, i.e. when 'embedded-media-driver = off'.
          # Embedded media driver will use a this directory, or a temporary directory if this
          # property is not defined (empty).
          # Only used when transport is aeron-udp.
          aeron-dir = ""

          # Whether to delete aeron embedded driver directory upon driver stop.
          # Only used when transport is aeron-udp.
          delete-aeron-dir = yes

          # Level of CPU time used, on a scale between 1 and 10, during backoff/idle.
          # The tradeoff is that to have low latency more CPU time must be used to be
          # able to react quickly on incoming messages or send as fast as possible after
          # backoff backpressure.
          # Level 1 strongly prefer low CPU consumption over low latency.
          # Level 10 strongly prefer low latency over low CPU consumption.
          # Only used when transport is aeron-udp.
          idle-cpu-level = 5

          # messages that are not accepted by Aeron are dropped after retrying for this period
          # Only used when transport is aeron-udp.
          give-up-message-after = 60 seconds

          # Timeout after which aeron driver has not had keepalive messages
          # from a client before it considers the client dead.
          # Only used when transport is aeron-udp.
          client-liveness-timeout = 20 seconds

          # Timout after after which an uncommitted publication will be unblocked
          # Only used when transport is aeron-udp.
          publication-unblock-timeout = 40 seconds

          # Timeout for each the INACTIVE and LINGER stages an aeron image
          # will be retained for when it is no longer referenced.
          # This timeout must be less than the 'handshake-timeout'.
          # Only used when transport is aeron-udp.
          image-liveness-timeout = 10 seconds

          # Timeout after which the aeron driver is considered dead
          # if it does not update its C'n'C timestamp.
          # Only used when transport is aeron-udp.
          driver-timeout = 20 seconds
        }

        # Only used when transport is tcp or tls-tcp.
        tcp = {
          # Timeout of establishing outbound connections.
          connection-timeout = 5 seconds

          # The local address that is used for the client side of the TCP connection.
          outbound-client-hostname = ""
        }
      }

      # SSL configuration that is used when transport=tls-tcp.
      ssl {
        # Factory of SSLEngine.
        # Must implement akka.remote.artery.tcp.SSLEngineProvider and have a public
        # constructor with an ActorSystem parameter.
        # The default ConfigSSLEngineProvider is configured by properties in section
        # akka.remote.artery.ssl.config-ssl-engine
        ssl-engine-provider = "Akka.Remote.Artery.Tcp.ConfigSSLEngineProvider,Akka.Remote"

        # Config of akka.remote.artery.tcp.ConfigSSLEngineProvider
        config-ssl-engine {

          # This is the Java Key Store used by the server connection
          key-store = "keystore"

          # This password is used for decrypting the key store
          # Use substitution from environment variables for passwords. Don't define
          # real passwords in config files. key-store-password=${SSL_KEY_STORE_PASSWORD}
          key-store-password = "changeme"

          # This password is used for decrypting the key
          # Use substitution from environment variables for passwords. Don't define
          # real passwords in config files. key-password=${SSL_KEY_PASSWORD}
          key-password = "changeme"

          # This is the Java Key Store used by the client connection
          trust-store = "truststore"

          # This password is used for decrypting the trust store
          # Use substitution from environment variables for passwords. Don't define
          # real passwords in config files. trust-store-password=${SSL_TRUST_STORE_PASSWORD}
          trust-store-password = "changeme"

          # Protocol to use for SSL encryption, choose from:
          # TLS 1.2 is available since JDK7, and default since JDK8:
          # https://blogs.oracle.com/java-platform-group/entry/java_8_will_use_tls
          protocol = "TLSv1.2"

          # Example: ["TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA"]
          # You need to install the JCE Unlimited Strength Jurisdiction Policy
          # Files to use AES 256.
          # More info here:
          # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
          enabled-algorithms = ["TLS_RSA_WITH_AES_128_CBC_SHA"]

          # There are two options, and the default SecureRandom is recommended:
          # "" or "SecureRandom" => (default)
          # "SHA1PRNG" => Can be slow because of blocking issues on Linux
          #
          # Setting a value here may require you to supply the appropriate cipher
          # suite (see enabled-algorithms section above)
          random-number-generator = ""

          # Require mutual authentication between TLS peers
          #
          # Without mutual authentication only the peer that actively establishes a connection (TLS client side)
          # checks if the passive side (TLS server side) sends over a trusted certificate. With the flag turned on,
          # the passive side will also request and verify a certificate from the connecting peer.
          #
          # To prevent man-in-the-middle attacks this setting is enabled by default.
          require-mutual-authentication = on

          # Set this to `on` to verify hostnames with sun.security.util.HostnameChecker
          # If possible it is recommended to have this enabled. Hostname verification is designed for
          # situations where things locate each other by hostname, in scenarios where host names are dynamic
          # and not known up front it can make sense to have this disabled.
          hostname-verification = off
        }
      }
    }
    #//#artery
  }
}
