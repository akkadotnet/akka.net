//-----------------------------------------------------------------------
// <copyright file="ClusterShardingMessages.cs" company="Akka.NET Project">
//     Copyright (C) 2009-2016 Typesafe Inc. <http://www.typesafe.com>
//     Copyright (C) 2013-2016 Akka.NET project <https://github.com/akkadotnet/akka.net>
// </copyright>
//-----------------------------------------------------------------------

// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static partial class ClusterShardingMessages {

  #region Extension registration
  public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
  }
  #endregion
  #region Static variables
  internal static pbd::MessageDescriptor internal__static_CoordinatorState__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CoordinatorState, global::CoordinatorState.Builder> internal__static_CoordinatorState__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CoordinatorState_ShardEntry__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CoordinatorState.Types.ShardEntry, global::CoordinatorState.Types.ShardEntry.Builder> internal__static_CoordinatorState_ShardEntry__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_ActorRefMessage__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::ActorRefMessage, global::ActorRefMessage.Builder> internal__static_ActorRefMessage__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_ShardIdMessage__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::ShardIdMessage, global::ShardIdMessage.Builder> internal__static_ShardIdMessage__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_ShardHomeAllocated__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::ShardHomeAllocated, global::ShardHomeAllocated.Builder> internal__static_ShardHomeAllocated__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_ShardHome__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::ShardHome, global::ShardHome.Builder> internal__static_ShardHome__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_EntityState__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::EntityState, global::EntityState.Builder> internal__static_EntityState__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_EntityStarted__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::EntityStarted, global::EntityStarted.Builder> internal__static_EntityStarted__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_EntityStopped__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::EntityStopped, global::EntityStopped.Builder> internal__static_EntityStopped__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_ShardStats__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::ShardStats, global::ShardStats.Builder> internal__static_ShardStats__FieldAccessorTable;
  #endregion
  #region Descriptor
  public static pbd::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbd::FileDescriptor descriptor;
  
  static ClusterShardingMessages() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        "Ch1DbHVzdGVyU2hhcmRpbmdNZXNzYWdlcy5wcm90byK1AQoQQ29vcmRpbmF0" + 
        "b3JTdGF0ZRIsCgZzaGFyZHMYASADKAsyHC5Db29yZGluYXRvclN0YXRlLlNo" + 
        "YXJkRW50cnkSDwoHcmVnaW9ucxgCIAMoCRIVCg1yZWdpb25Qcm94aWVzGAMg" + 
        "AygJEhkKEXVuYWxsb2NhdGVkU2hhcmRzGAQgAygJGjAKClNoYXJkRW50cnkS" + 
        "DwoHc2hhcmRJZBgBIAIoCRIRCglyZWdpb25SZWYYAiACKAkiHgoPQWN0b3JS" + 
        "ZWZNZXNzYWdlEgsKA3JlZhgBIAIoCSIfCg5TaGFyZElkTWVzc2FnZRINCgVz" + 
        "aGFyZBgBIAIoCSIzChJTaGFyZEhvbWVBbGxvY2F0ZWQSDQoFc2hhcmQYASAC" + 
        "KAkSDgoGcmVnaW9uGAIgAigJIioKCVNoYXJkSG9tZRINCgVzaGFyZBgBIAIo" + 
        "CRIOCgZyZWdpb24YAiACKAkiHwoLRW50aXR5U3RhdGUSEAoIZW50aXRpZXMY" + 
        "ASADKAkiIQoNRW50aXR5U3RhcnRlZBIQCghlbnRpdHlJZBgBIAIoCSIhCg1F" + 
        "bnRpdHlTdG9wcGVkEhAKCGVudGl0eUlkGAEgAigJIjAKClNoYXJkU3RhdHMS" + 
        "DQoFc2hhcmQYASACKAkSEwoLZW50aXR5Q291bnQYAiACKAVCJgoiYWtrYS5j" + 
        "bHVzdGVyLnNoYXJkaW5nLnByb3RvYnVmLm1zZ0gB");
    pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
      descriptor = root;
      internal__static_CoordinatorState__Descriptor = Descriptor.MessageTypes[0];
      internal__static_CoordinatorState__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CoordinatorState, global::CoordinatorState.Builder>(internal__static_CoordinatorState__Descriptor,
              new string[] { "Shards", "Regions", "RegionProxies", "UnallocatedShards", });
      internal__static_CoordinatorState_ShardEntry__Descriptor = internal__static_CoordinatorState__Descriptor.NestedTypes[0];
      internal__static_CoordinatorState_ShardEntry__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CoordinatorState.Types.ShardEntry, global::CoordinatorState.Types.ShardEntry.Builder>(internal__static_CoordinatorState_ShardEntry__Descriptor,
              new string[] { "ShardId", "RegionRef", });
      internal__static_ActorRefMessage__Descriptor = Descriptor.MessageTypes[1];
      internal__static_ActorRefMessage__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::ActorRefMessage, global::ActorRefMessage.Builder>(internal__static_ActorRefMessage__Descriptor,
              new string[] { "Ref", });
      internal__static_ShardIdMessage__Descriptor = Descriptor.MessageTypes[2];
      internal__static_ShardIdMessage__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::ShardIdMessage, global::ShardIdMessage.Builder>(internal__static_ShardIdMessage__Descriptor,
              new string[] { "Shard", });
      internal__static_ShardHomeAllocated__Descriptor = Descriptor.MessageTypes[3];
      internal__static_ShardHomeAllocated__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::ShardHomeAllocated, global::ShardHomeAllocated.Builder>(internal__static_ShardHomeAllocated__Descriptor,
              new string[] { "Shard", "Region", });
      internal__static_ShardHome__Descriptor = Descriptor.MessageTypes[4];
      internal__static_ShardHome__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::ShardHome, global::ShardHome.Builder>(internal__static_ShardHome__Descriptor,
              new string[] { "Shard", "Region", });
      internal__static_EntityState__Descriptor = Descriptor.MessageTypes[5];
      internal__static_EntityState__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::EntityState, global::EntityState.Builder>(internal__static_EntityState__Descriptor,
              new string[] { "Entities", });
      internal__static_EntityStarted__Descriptor = Descriptor.MessageTypes[6];
      internal__static_EntityStarted__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::EntityStarted, global::EntityStarted.Builder>(internal__static_EntityStarted__Descriptor,
              new string[] { "EntityId", });
      internal__static_EntityStopped__Descriptor = Descriptor.MessageTypes[7];
      internal__static_EntityStopped__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::EntityStopped, global::EntityStopped.Builder>(internal__static_EntityStopped__Descriptor,
              new string[] { "EntityId", });
      internal__static_ShardStats__Descriptor = Descriptor.MessageTypes[8];
      internal__static_ShardStats__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::ShardStats, global::ShardStats.Builder>(internal__static_ShardStats__Descriptor,
              new string[] { "Shard", "EntityCount", });
      return null;
    };
    pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
        new pbd::FileDescriptor[] {
        }, assigner);
  }
  #endregion
  
}
#region Messages
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CoordinatorState : pb::GeneratedMessage<CoordinatorState, CoordinatorState.Builder> {
  private CoordinatorState() { }
  private static readonly CoordinatorState defaultInstance = new CoordinatorState().MakeReadOnly();
  private static readonly string[] _coordinatorStateFieldNames = new string[] { "regionProxies", "regions", "shards", "unallocatedShards" };
  private static readonly uint[] _coordinatorStateFieldTags = new uint[] { 26, 18, 10, 34 };
  public static CoordinatorState DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CoordinatorState DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CoordinatorState ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_CoordinatorState__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CoordinatorState, CoordinatorState.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_CoordinatorState__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class ShardEntry : pb::GeneratedMessage<ShardEntry, ShardEntry.Builder> {
      private ShardEntry() { }
      private static readonly ShardEntry defaultInstance = new ShardEntry().MakeReadOnly();
      private static readonly string[] _shardEntryFieldNames = new string[] { "regionRef", "shardId" };
      private static readonly uint[] _shardEntryFieldTags = new uint[] { 18, 10 };
      public static ShardEntry DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override ShardEntry DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override ShardEntry ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::ClusterShardingMessages.internal__static_CoordinatorState_ShardEntry__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<ShardEntry, ShardEntry.Builder> InternalFieldAccessors {
        get { return global::ClusterShardingMessages.internal__static_CoordinatorState_ShardEntry__FieldAccessorTable; }
      }
      
      public const int ShardIdFieldNumber = 1;
      private bool hasShardId;
      private string shardId_ = "";
      public bool HasShardId {
        get { return hasShardId; }
      }
      public string ShardId {
        get { return shardId_; }
      }
      
      public const int RegionRefFieldNumber = 2;
      private bool hasRegionRef;
      private string regionRef_ = "";
      public bool HasRegionRef {
        get { return hasRegionRef; }
      }
      public string RegionRef {
        get { return regionRef_; }
      }
      
      public override bool IsInitialized {
        get {
          if (!hasShardId) return false;
          if (!hasRegionRef) return false;
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _shardEntryFieldNames;
        if (hasShardId) {
          output.WriteString(1, field_names[1], ShardId);
        }
        if (hasRegionRef) {
          output.WriteString(2, field_names[0], RegionRef);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasShardId) {
            size += pb::CodedOutputStream.ComputeStringSize(1, ShardId);
          }
          if (hasRegionRef) {
            size += pb::CodedOutputStream.ComputeStringSize(2, RegionRef);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static ShardEntry ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static ShardEntry ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static ShardEntry ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static ShardEntry ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static ShardEntry ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static ShardEntry ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static ShardEntry ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static ShardEntry ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static ShardEntry ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static ShardEntry ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private ShardEntry MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(ShardEntry prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<ShardEntry, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(ShardEntry cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private ShardEntry result;
        
        private ShardEntry PrepareBuilder() {
          if (resultIsReadOnly) {
            ShardEntry original = result;
            result = new ShardEntry();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override ShardEntry MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CoordinatorState.Types.ShardEntry.Descriptor; }
        }
        
        public override ShardEntry DefaultInstanceForType {
          get { return global::CoordinatorState.Types.ShardEntry.DefaultInstance; }
        }
        
        public override ShardEntry BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is ShardEntry) {
            return MergeFrom((ShardEntry) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(ShardEntry other) {
          if (other == global::CoordinatorState.Types.ShardEntry.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasShardId) {
            ShardId = other.ShardId;
          }
          if (other.HasRegionRef) {
            RegionRef = other.RegionRef;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_shardEntryFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _shardEntryFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasShardId = input.ReadString(ref result.shardId_);
                break;
              }
              case 18: {
                result.hasRegionRef = input.ReadString(ref result.regionRef_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasShardId {
          get { return result.hasShardId; }
        }
        public string ShardId {
          get { return result.ShardId; }
          set { SetShardId(value); }
        }
        public Builder SetShardId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasShardId = true;
          result.shardId_ = value;
          return this;
        }
        public Builder ClearShardId() {
          PrepareBuilder();
          result.hasShardId = false;
          result.shardId_ = "";
          return this;
        }
        
        public bool HasRegionRef {
          get { return result.hasRegionRef; }
        }
        public string RegionRef {
          get { return result.RegionRef; }
          set { SetRegionRef(value); }
        }
        public Builder SetRegionRef(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRegionRef = true;
          result.regionRef_ = value;
          return this;
        }
        public Builder ClearRegionRef() {
          PrepareBuilder();
          result.hasRegionRef = false;
          result.regionRef_ = "";
          return this;
        }
      }
      static ShardEntry() {
        object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int ShardsFieldNumber = 1;
  private pbc::PopsicleList<global::CoordinatorState.Types.ShardEntry> shards_ = new pbc::PopsicleList<global::CoordinatorState.Types.ShardEntry>();
  public scg::IList<global::CoordinatorState.Types.ShardEntry> ShardsList {
    get { return shards_; }
  }
  public int ShardsCount {
    get { return shards_.Count; }
  }
  public global::CoordinatorState.Types.ShardEntry GetShards(int index) {
    return shards_[index];
  }
  
  public const int RegionsFieldNumber = 2;
  private pbc::PopsicleList<string> regions_ = new pbc::PopsicleList<string>();
  public scg::IList<string> RegionsList {
    get { return pbc::Lists.AsReadOnly(regions_); }
  }
  public int RegionsCount {
    get { return regions_.Count; }
  }
  public string GetRegions(int index) {
    return regions_[index];
  }
  
  public const int RegionProxiesFieldNumber = 3;
  private pbc::PopsicleList<string> regionProxies_ = new pbc::PopsicleList<string>();
  public scg::IList<string> RegionProxiesList {
    get { return pbc::Lists.AsReadOnly(regionProxies_); }
  }
  public int RegionProxiesCount {
    get { return regionProxies_.Count; }
  }
  public string GetRegionProxies(int index) {
    return regionProxies_[index];
  }
  
  public const int UnallocatedShardsFieldNumber = 4;
  private pbc::PopsicleList<string> unallocatedShards_ = new pbc::PopsicleList<string>();
  public scg::IList<string> UnallocatedShardsList {
    get { return pbc::Lists.AsReadOnly(unallocatedShards_); }
  }
  public int UnallocatedShardsCount {
    get { return unallocatedShards_.Count; }
  }
  public string GetUnallocatedShards(int index) {
    return unallocatedShards_[index];
  }
  
  public override bool IsInitialized {
    get {
      foreach (global::CoordinatorState.Types.ShardEntry element in ShardsList) {
        if (!element.IsInitialized) return false;
      }
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _coordinatorStateFieldNames;
    if (shards_.Count > 0) {
      output.WriteMessageArray(1, field_names[2], shards_);
    }
    if (regions_.Count > 0) {
      output.WriteStringArray(2, field_names[1], regions_);
    }
    if (regionProxies_.Count > 0) {
      output.WriteStringArray(3, field_names[0], regionProxies_);
    }
    if (unallocatedShards_.Count > 0) {
      output.WriteStringArray(4, field_names[3], unallocatedShards_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::CoordinatorState.Types.ShardEntry element in ShardsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      {
        int dataSize = 0;
        foreach (string element in RegionsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * regions_.Count;
      }
      {
        int dataSize = 0;
        foreach (string element in RegionProxiesList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * regionProxies_.Count;
      }
      {
        int dataSize = 0;
        foreach (string element in UnallocatedShardsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * unallocatedShards_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CoordinatorState ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CoordinatorState ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CoordinatorState ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CoordinatorState ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CoordinatorState ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CoordinatorState ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CoordinatorState ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CoordinatorState ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CoordinatorState ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CoordinatorState ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CoordinatorState MakeReadOnly() {
    shards_.MakeReadOnly();
    regions_.MakeReadOnly();
    regionProxies_.MakeReadOnly();
    unallocatedShards_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CoordinatorState prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CoordinatorState, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CoordinatorState cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CoordinatorState result;
    
    private CoordinatorState PrepareBuilder() {
      if (resultIsReadOnly) {
        CoordinatorState original = result;
        result = new CoordinatorState();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CoordinatorState MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CoordinatorState.Descriptor; }
    }
    
    public override CoordinatorState DefaultInstanceForType {
      get { return global::CoordinatorState.DefaultInstance; }
    }
    
    public override CoordinatorState BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CoordinatorState) {
        return MergeFrom((CoordinatorState) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CoordinatorState other) {
      if (other == global::CoordinatorState.DefaultInstance) return this;
      PrepareBuilder();
      if (other.shards_.Count != 0) {
        result.shards_.Add(other.shards_);
      }
      if (other.regions_.Count != 0) {
        result.regions_.Add(other.regions_);
      }
      if (other.regionProxies_.Count != 0) {
        result.regionProxies_.Add(other.regionProxies_);
      }
      if (other.unallocatedShards_.Count != 0) {
        result.unallocatedShards_.Add(other.unallocatedShards_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_coordinatorStateFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _coordinatorStateFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            input.ReadMessageArray(tag, field_name, result.shards_, global::CoordinatorState.Types.ShardEntry.DefaultInstance, extensionRegistry);
            break;
          }
          case 18: {
            input.ReadStringArray(tag, field_name, result.regions_);
            break;
          }
          case 26: {
            input.ReadStringArray(tag, field_name, result.regionProxies_);
            break;
          }
          case 34: {
            input.ReadStringArray(tag, field_name, result.unallocatedShards_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public pbc::IPopsicleList<global::CoordinatorState.Types.ShardEntry> ShardsList {
      get { return PrepareBuilder().shards_; }
    }
    public int ShardsCount {
      get { return result.ShardsCount; }
    }
    public global::CoordinatorState.Types.ShardEntry GetShards(int index) {
      return result.GetShards(index);
    }
    public Builder SetShards(int index, global::CoordinatorState.Types.ShardEntry value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.shards_[index] = value;
      return this;
    }
    public Builder SetShards(int index, global::CoordinatorState.Types.ShardEntry.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.shards_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddShards(global::CoordinatorState.Types.ShardEntry value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.shards_.Add(value);
      return this;
    }
    public Builder AddShards(global::CoordinatorState.Types.ShardEntry.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.shards_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeShards(scg::IEnumerable<global::CoordinatorState.Types.ShardEntry> values) {
      PrepareBuilder();
      result.shards_.Add(values);
      return this;
    }
    public Builder ClearShards() {
      PrepareBuilder();
      result.shards_.Clear();
      return this;
    }
    
    public pbc::IPopsicleList<string> RegionsList {
      get { return PrepareBuilder().regions_; }
    }
    public int RegionsCount {
      get { return result.RegionsCount; }
    }
    public string GetRegions(int index) {
      return result.GetRegions(index);
    }
    public Builder SetRegions(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.regions_[index] = value;
      return this;
    }
    public Builder AddRegions(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.regions_.Add(value);
      return this;
    }
    public Builder AddRangeRegions(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.regions_.Add(values);
      return this;
    }
    public Builder ClearRegions() {
      PrepareBuilder();
      result.regions_.Clear();
      return this;
    }
    
    public pbc::IPopsicleList<string> RegionProxiesList {
      get { return PrepareBuilder().regionProxies_; }
    }
    public int RegionProxiesCount {
      get { return result.RegionProxiesCount; }
    }
    public string GetRegionProxies(int index) {
      return result.GetRegionProxies(index);
    }
    public Builder SetRegionProxies(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.regionProxies_[index] = value;
      return this;
    }
    public Builder AddRegionProxies(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.regionProxies_.Add(value);
      return this;
    }
    public Builder AddRangeRegionProxies(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.regionProxies_.Add(values);
      return this;
    }
    public Builder ClearRegionProxies() {
      PrepareBuilder();
      result.regionProxies_.Clear();
      return this;
    }
    
    public pbc::IPopsicleList<string> UnallocatedShardsList {
      get { return PrepareBuilder().unallocatedShards_; }
    }
    public int UnallocatedShardsCount {
      get { return result.UnallocatedShardsCount; }
    }
    public string GetUnallocatedShards(int index) {
      return result.GetUnallocatedShards(index);
    }
    public Builder SetUnallocatedShards(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.unallocatedShards_[index] = value;
      return this;
    }
    public Builder AddUnallocatedShards(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.unallocatedShards_.Add(value);
      return this;
    }
    public Builder AddRangeUnallocatedShards(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.unallocatedShards_.Add(values);
      return this;
    }
    public Builder ClearUnallocatedShards() {
      PrepareBuilder();
      result.unallocatedShards_.Clear();
      return this;
    }
  }
  static CoordinatorState() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class ActorRefMessage : pb::GeneratedMessage<ActorRefMessage, ActorRefMessage.Builder> {
  private ActorRefMessage() { }
  private static readonly ActorRefMessage defaultInstance = new ActorRefMessage().MakeReadOnly();
  private static readonly string[] _actorRefMessageFieldNames = new string[] { "ref" };
  private static readonly uint[] _actorRefMessageFieldTags = new uint[] { 10 };
  public static ActorRefMessage DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override ActorRefMessage DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override ActorRefMessage ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_ActorRefMessage__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<ActorRefMessage, ActorRefMessage.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_ActorRefMessage__FieldAccessorTable; }
  }
  
  public const int RefFieldNumber = 1;
  private bool hasRef;
  private string ref_ = "";
  public bool HasRef {
    get { return hasRef; }
  }
  public string Ref {
    get { return ref_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasRef) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _actorRefMessageFieldNames;
    if (hasRef) {
      output.WriteString(1, field_names[0], Ref);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRef) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Ref);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static ActorRefMessage ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static ActorRefMessage ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static ActorRefMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ActorRefMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private ActorRefMessage MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(ActorRefMessage prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<ActorRefMessage, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(ActorRefMessage cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private ActorRefMessage result;
    
    private ActorRefMessage PrepareBuilder() {
      if (resultIsReadOnly) {
        ActorRefMessage original = result;
        result = new ActorRefMessage();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override ActorRefMessage MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::ActorRefMessage.Descriptor; }
    }
    
    public override ActorRefMessage DefaultInstanceForType {
      get { return global::ActorRefMessage.DefaultInstance; }
    }
    
    public override ActorRefMessage BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is ActorRefMessage) {
        return MergeFrom((ActorRefMessage) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(ActorRefMessage other) {
      if (other == global::ActorRefMessage.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasRef) {
        Ref = other.Ref;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_actorRefMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _actorRefMessageFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasRef = input.ReadString(ref result.ref_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasRef {
      get { return result.hasRef; }
    }
    public string Ref {
      get { return result.Ref; }
      set { SetRef(value); }
    }
    public Builder SetRef(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasRef = true;
      result.ref_ = value;
      return this;
    }
    public Builder ClearRef() {
      PrepareBuilder();
      result.hasRef = false;
      result.ref_ = "";
      return this;
    }
  }
  static ActorRefMessage() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class ShardIdMessage : pb::GeneratedMessage<ShardIdMessage, ShardIdMessage.Builder> {
  private ShardIdMessage() { }
  private static readonly ShardIdMessage defaultInstance = new ShardIdMessage().MakeReadOnly();
  private static readonly string[] _shardIdMessageFieldNames = new string[] { "shard" };
  private static readonly uint[] _shardIdMessageFieldTags = new uint[] { 10 };
  public static ShardIdMessage DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override ShardIdMessage DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override ShardIdMessage ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_ShardIdMessage__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<ShardIdMessage, ShardIdMessage.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_ShardIdMessage__FieldAccessorTable; }
  }
  
  public const int ShardFieldNumber = 1;
  private bool hasShard;
  private string shard_ = "";
  public bool HasShard {
    get { return hasShard; }
  }
  public string Shard {
    get { return shard_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasShard) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _shardIdMessageFieldNames;
    if (hasShard) {
      output.WriteString(1, field_names[0], Shard);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasShard) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Shard);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static ShardIdMessage ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static ShardIdMessage ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static ShardIdMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardIdMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private ShardIdMessage MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(ShardIdMessage prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<ShardIdMessage, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(ShardIdMessage cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private ShardIdMessage result;
    
    private ShardIdMessage PrepareBuilder() {
      if (resultIsReadOnly) {
        ShardIdMessage original = result;
        result = new ShardIdMessage();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override ShardIdMessage MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::ShardIdMessage.Descriptor; }
    }
    
    public override ShardIdMessage DefaultInstanceForType {
      get { return global::ShardIdMessage.DefaultInstance; }
    }
    
    public override ShardIdMessage BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is ShardIdMessage) {
        return MergeFrom((ShardIdMessage) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(ShardIdMessage other) {
      if (other == global::ShardIdMessage.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasShard) {
        Shard = other.Shard;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_shardIdMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _shardIdMessageFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasShard = input.ReadString(ref result.shard_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasShard {
      get { return result.hasShard; }
    }
    public string Shard {
      get { return result.Shard; }
      set { SetShard(value); }
    }
    public Builder SetShard(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasShard = true;
      result.shard_ = value;
      return this;
    }
    public Builder ClearShard() {
      PrepareBuilder();
      result.hasShard = false;
      result.shard_ = "";
      return this;
    }
  }
  static ShardIdMessage() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class ShardHomeAllocated : pb::GeneratedMessage<ShardHomeAllocated, ShardHomeAllocated.Builder> {
  private ShardHomeAllocated() { }
  private static readonly ShardHomeAllocated defaultInstance = new ShardHomeAllocated().MakeReadOnly();
  private static readonly string[] _shardHomeAllocatedFieldNames = new string[] { "region", "shard" };
  private static readonly uint[] _shardHomeAllocatedFieldTags = new uint[] { 18, 10 };
  public static ShardHomeAllocated DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override ShardHomeAllocated DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override ShardHomeAllocated ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_ShardHomeAllocated__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<ShardHomeAllocated, ShardHomeAllocated.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_ShardHomeAllocated__FieldAccessorTable; }
  }
  
  public const int ShardFieldNumber = 1;
  private bool hasShard;
  private string shard_ = "";
  public bool HasShard {
    get { return hasShard; }
  }
  public string Shard {
    get { return shard_; }
  }
  
  public const int RegionFieldNumber = 2;
  private bool hasRegion;
  private string region_ = "";
  public bool HasRegion {
    get { return hasRegion; }
  }
  public string Region {
    get { return region_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasShard) return false;
      if (!hasRegion) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _shardHomeAllocatedFieldNames;
    if (hasShard) {
      output.WriteString(1, field_names[1], Shard);
    }
    if (hasRegion) {
      output.WriteString(2, field_names[0], Region);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasShard) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Shard);
      }
      if (hasRegion) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Region);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static ShardHomeAllocated ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static ShardHomeAllocated ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static ShardHomeAllocated ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardHomeAllocated ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private ShardHomeAllocated MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(ShardHomeAllocated prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<ShardHomeAllocated, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(ShardHomeAllocated cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private ShardHomeAllocated result;
    
    private ShardHomeAllocated PrepareBuilder() {
      if (resultIsReadOnly) {
        ShardHomeAllocated original = result;
        result = new ShardHomeAllocated();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override ShardHomeAllocated MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::ShardHomeAllocated.Descriptor; }
    }
    
    public override ShardHomeAllocated DefaultInstanceForType {
      get { return global::ShardHomeAllocated.DefaultInstance; }
    }
    
    public override ShardHomeAllocated BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is ShardHomeAllocated) {
        return MergeFrom((ShardHomeAllocated) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(ShardHomeAllocated other) {
      if (other == global::ShardHomeAllocated.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasShard) {
        Shard = other.Shard;
      }
      if (other.HasRegion) {
        Region = other.Region;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_shardHomeAllocatedFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _shardHomeAllocatedFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasShard = input.ReadString(ref result.shard_);
            break;
          }
          case 18: {
            result.hasRegion = input.ReadString(ref result.region_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasShard {
      get { return result.hasShard; }
    }
    public string Shard {
      get { return result.Shard; }
      set { SetShard(value); }
    }
    public Builder SetShard(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasShard = true;
      result.shard_ = value;
      return this;
    }
    public Builder ClearShard() {
      PrepareBuilder();
      result.hasShard = false;
      result.shard_ = "";
      return this;
    }
    
    public bool HasRegion {
      get { return result.hasRegion; }
    }
    public string Region {
      get { return result.Region; }
      set { SetRegion(value); }
    }
    public Builder SetRegion(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasRegion = true;
      result.region_ = value;
      return this;
    }
    public Builder ClearRegion() {
      PrepareBuilder();
      result.hasRegion = false;
      result.region_ = "";
      return this;
    }
  }
  static ShardHomeAllocated() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class ShardHome : pb::GeneratedMessage<ShardHome, ShardHome.Builder> {
  private ShardHome() { }
  private static readonly ShardHome defaultInstance = new ShardHome().MakeReadOnly();
  private static readonly string[] _shardHomeFieldNames = new string[] { "region", "shard" };
  private static readonly uint[] _shardHomeFieldTags = new uint[] { 18, 10 };
  public static ShardHome DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override ShardHome DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override ShardHome ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_ShardHome__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<ShardHome, ShardHome.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_ShardHome__FieldAccessorTable; }
  }
  
  public const int ShardFieldNumber = 1;
  private bool hasShard;
  private string shard_ = "";
  public bool HasShard {
    get { return hasShard; }
  }
  public string Shard {
    get { return shard_; }
  }
  
  public const int RegionFieldNumber = 2;
  private bool hasRegion;
  private string region_ = "";
  public bool HasRegion {
    get { return hasRegion; }
  }
  public string Region {
    get { return region_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasShard) return false;
      if (!hasRegion) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _shardHomeFieldNames;
    if (hasShard) {
      output.WriteString(1, field_names[1], Shard);
    }
    if (hasRegion) {
      output.WriteString(2, field_names[0], Region);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasShard) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Shard);
      }
      if (hasRegion) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Region);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static ShardHome ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardHome ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardHome ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardHome ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardHome ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardHome ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static ShardHome ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static ShardHome ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static ShardHome ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardHome ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private ShardHome MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(ShardHome prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<ShardHome, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(ShardHome cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private ShardHome result;
    
    private ShardHome PrepareBuilder() {
      if (resultIsReadOnly) {
        ShardHome original = result;
        result = new ShardHome();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override ShardHome MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::ShardHome.Descriptor; }
    }
    
    public override ShardHome DefaultInstanceForType {
      get { return global::ShardHome.DefaultInstance; }
    }
    
    public override ShardHome BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is ShardHome) {
        return MergeFrom((ShardHome) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(ShardHome other) {
      if (other == global::ShardHome.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasShard) {
        Shard = other.Shard;
      }
      if (other.HasRegion) {
        Region = other.Region;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_shardHomeFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _shardHomeFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasShard = input.ReadString(ref result.shard_);
            break;
          }
          case 18: {
            result.hasRegion = input.ReadString(ref result.region_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasShard {
      get { return result.hasShard; }
    }
    public string Shard {
      get { return result.Shard; }
      set { SetShard(value); }
    }
    public Builder SetShard(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasShard = true;
      result.shard_ = value;
      return this;
    }
    public Builder ClearShard() {
      PrepareBuilder();
      result.hasShard = false;
      result.shard_ = "";
      return this;
    }
    
    public bool HasRegion {
      get { return result.hasRegion; }
    }
    public string Region {
      get { return result.Region; }
      set { SetRegion(value); }
    }
    public Builder SetRegion(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasRegion = true;
      result.region_ = value;
      return this;
    }
    public Builder ClearRegion() {
      PrepareBuilder();
      result.hasRegion = false;
      result.region_ = "";
      return this;
    }
  }
  static ShardHome() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class EntityState : pb::GeneratedMessage<EntityState, EntityState.Builder> {
  private EntityState() { }
  private static readonly EntityState defaultInstance = new EntityState().MakeReadOnly();
  private static readonly string[] _entityStateFieldNames = new string[] { "entities" };
  private static readonly uint[] _entityStateFieldTags = new uint[] { 10 };
  public static EntityState DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override EntityState DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override EntityState ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_EntityState__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<EntityState, EntityState.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_EntityState__FieldAccessorTable; }
  }
  
  public const int EntitiesFieldNumber = 1;
  private pbc::PopsicleList<string> entities_ = new pbc::PopsicleList<string>();
  public scg::IList<string> EntitiesList {
    get { return pbc::Lists.AsReadOnly(entities_); }
  }
  public int EntitiesCount {
    get { return entities_.Count; }
  }
  public string GetEntities(int index) {
    return entities_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _entityStateFieldNames;
    if (entities_.Count > 0) {
      output.WriteStringArray(1, field_names[0], entities_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      {
        int dataSize = 0;
        foreach (string element in EntitiesList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * entities_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static EntityState ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static EntityState ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static EntityState ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static EntityState ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static EntityState ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static EntityState ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static EntityState ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static EntityState ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static EntityState ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static EntityState ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private EntityState MakeReadOnly() {
    entities_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(EntityState prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<EntityState, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(EntityState cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private EntityState result;
    
    private EntityState PrepareBuilder() {
      if (resultIsReadOnly) {
        EntityState original = result;
        result = new EntityState();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override EntityState MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::EntityState.Descriptor; }
    }
    
    public override EntityState DefaultInstanceForType {
      get { return global::EntityState.DefaultInstance; }
    }
    
    public override EntityState BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is EntityState) {
        return MergeFrom((EntityState) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(EntityState other) {
      if (other == global::EntityState.DefaultInstance) return this;
      PrepareBuilder();
      if (other.entities_.Count != 0) {
        result.entities_.Add(other.entities_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_entityStateFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _entityStateFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            input.ReadStringArray(tag, field_name, result.entities_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public pbc::IPopsicleList<string> EntitiesList {
      get { return PrepareBuilder().entities_; }
    }
    public int EntitiesCount {
      get { return result.EntitiesCount; }
    }
    public string GetEntities(int index) {
      return result.GetEntities(index);
    }
    public Builder SetEntities(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.entities_[index] = value;
      return this;
    }
    public Builder AddEntities(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.entities_.Add(value);
      return this;
    }
    public Builder AddRangeEntities(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.entities_.Add(values);
      return this;
    }
    public Builder ClearEntities() {
      PrepareBuilder();
      result.entities_.Clear();
      return this;
    }
  }
  static EntityState() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class EntityStarted : pb::GeneratedMessage<EntityStarted, EntityStarted.Builder> {
  private EntityStarted() { }
  private static readonly EntityStarted defaultInstance = new EntityStarted().MakeReadOnly();
  private static readonly string[] _entityStartedFieldNames = new string[] { "entityId" };
  private static readonly uint[] _entityStartedFieldTags = new uint[] { 10 };
  public static EntityStarted DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override EntityStarted DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override EntityStarted ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_EntityStarted__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<EntityStarted, EntityStarted.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_EntityStarted__FieldAccessorTable; }
  }
  
  public const int EntityIdFieldNumber = 1;
  private bool hasEntityId;
  private string entityId_ = "";
  public bool HasEntityId {
    get { return hasEntityId; }
  }
  public string EntityId {
    get { return entityId_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasEntityId) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _entityStartedFieldNames;
    if (hasEntityId) {
      output.WriteString(1, field_names[0], EntityId);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEntityId) {
        size += pb::CodedOutputStream.ComputeStringSize(1, EntityId);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static EntityStarted ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static EntityStarted ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static EntityStarted ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static EntityStarted ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static EntityStarted ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static EntityStarted ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static EntityStarted ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static EntityStarted ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static EntityStarted ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static EntityStarted ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private EntityStarted MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(EntityStarted prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<EntityStarted, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(EntityStarted cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private EntityStarted result;
    
    private EntityStarted PrepareBuilder() {
      if (resultIsReadOnly) {
        EntityStarted original = result;
        result = new EntityStarted();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override EntityStarted MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::EntityStarted.Descriptor; }
    }
    
    public override EntityStarted DefaultInstanceForType {
      get { return global::EntityStarted.DefaultInstance; }
    }
    
    public override EntityStarted BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is EntityStarted) {
        return MergeFrom((EntityStarted) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(EntityStarted other) {
      if (other == global::EntityStarted.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasEntityId) {
        EntityId = other.EntityId;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_entityStartedFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _entityStartedFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasEntityId = input.ReadString(ref result.entityId_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasEntityId {
      get { return result.hasEntityId; }
    }
    public string EntityId {
      get { return result.EntityId; }
      set { SetEntityId(value); }
    }
    public Builder SetEntityId(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEntityId = true;
      result.entityId_ = value;
      return this;
    }
    public Builder ClearEntityId() {
      PrepareBuilder();
      result.hasEntityId = false;
      result.entityId_ = "";
      return this;
    }
  }
  static EntityStarted() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class EntityStopped : pb::GeneratedMessage<EntityStopped, EntityStopped.Builder> {
  private EntityStopped() { }
  private static readonly EntityStopped defaultInstance = new EntityStopped().MakeReadOnly();
  private static readonly string[] _entityStoppedFieldNames = new string[] { "entityId" };
  private static readonly uint[] _entityStoppedFieldTags = new uint[] { 10 };
  public static EntityStopped DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override EntityStopped DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override EntityStopped ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_EntityStopped__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<EntityStopped, EntityStopped.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_EntityStopped__FieldAccessorTable; }
  }
  
  public const int EntityIdFieldNumber = 1;
  private bool hasEntityId;
  private string entityId_ = "";
  public bool HasEntityId {
    get { return hasEntityId; }
  }
  public string EntityId {
    get { return entityId_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasEntityId) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _entityStoppedFieldNames;
    if (hasEntityId) {
      output.WriteString(1, field_names[0], EntityId);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEntityId) {
        size += pb::CodedOutputStream.ComputeStringSize(1, EntityId);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static EntityStopped ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static EntityStopped ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static EntityStopped ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static EntityStopped ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static EntityStopped ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static EntityStopped ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static EntityStopped ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static EntityStopped ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static EntityStopped ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static EntityStopped ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private EntityStopped MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(EntityStopped prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<EntityStopped, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(EntityStopped cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private EntityStopped result;
    
    private EntityStopped PrepareBuilder() {
      if (resultIsReadOnly) {
        EntityStopped original = result;
        result = new EntityStopped();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override EntityStopped MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::EntityStopped.Descriptor; }
    }
    
    public override EntityStopped DefaultInstanceForType {
      get { return global::EntityStopped.DefaultInstance; }
    }
    
    public override EntityStopped BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is EntityStopped) {
        return MergeFrom((EntityStopped) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(EntityStopped other) {
      if (other == global::EntityStopped.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasEntityId) {
        EntityId = other.EntityId;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_entityStoppedFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _entityStoppedFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasEntityId = input.ReadString(ref result.entityId_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasEntityId {
      get { return result.hasEntityId; }
    }
    public string EntityId {
      get { return result.EntityId; }
      set { SetEntityId(value); }
    }
    public Builder SetEntityId(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEntityId = true;
      result.entityId_ = value;
      return this;
    }
    public Builder ClearEntityId() {
      PrepareBuilder();
      result.hasEntityId = false;
      result.entityId_ = "";
      return this;
    }
  }
  static EntityStopped() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class ShardStats : pb::GeneratedMessage<ShardStats, ShardStats.Builder> {
  private ShardStats() { }
  private static readonly ShardStats defaultInstance = new ShardStats().MakeReadOnly();
  private static readonly string[] _shardStatsFieldNames = new string[] { "entityCount", "shard" };
  private static readonly uint[] _shardStatsFieldTags = new uint[] { 16, 10 };
  public static ShardStats DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override ShardStats DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override ShardStats ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::ClusterShardingMessages.internal__static_ShardStats__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<ShardStats, ShardStats.Builder> InternalFieldAccessors {
    get { return global::ClusterShardingMessages.internal__static_ShardStats__FieldAccessorTable; }
  }
  
  public const int ShardFieldNumber = 1;
  private bool hasShard;
  private string shard_ = "";
  public bool HasShard {
    get { return hasShard; }
  }
  public string Shard {
    get { return shard_; }
  }
  
  public const int EntityCountFieldNumber = 2;
  private bool hasEntityCount;
  private int entityCount_;
  public bool HasEntityCount {
    get { return hasEntityCount; }
  }
  public int EntityCount {
    get { return entityCount_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasShard) return false;
      if (!hasEntityCount) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _shardStatsFieldNames;
    if (hasShard) {
      output.WriteString(1, field_names[1], Shard);
    }
    if (hasEntityCount) {
      output.WriteInt32(2, field_names[0], EntityCount);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasShard) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Shard);
      }
      if (hasEntityCount) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, EntityCount);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static ShardStats ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardStats ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardStats ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static ShardStats ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static ShardStats ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardStats ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static ShardStats ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static ShardStats ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static ShardStats ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static ShardStats ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private ShardStats MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(ShardStats prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<ShardStats, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(ShardStats cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private ShardStats result;
    
    private ShardStats PrepareBuilder() {
      if (resultIsReadOnly) {
        ShardStats original = result;
        result = new ShardStats();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override ShardStats MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::ShardStats.Descriptor; }
    }
    
    public override ShardStats DefaultInstanceForType {
      get { return global::ShardStats.DefaultInstance; }
    }
    
    public override ShardStats BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is ShardStats) {
        return MergeFrom((ShardStats) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(ShardStats other) {
      if (other == global::ShardStats.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasShard) {
        Shard = other.Shard;
      }
      if (other.HasEntityCount) {
        EntityCount = other.EntityCount;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_shardStatsFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _shardStatsFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasShard = input.ReadString(ref result.shard_);
            break;
          }
          case 16: {
            result.hasEntityCount = input.ReadInt32(ref result.entityCount_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasShard {
      get { return result.hasShard; }
    }
    public string Shard {
      get { return result.Shard; }
      set { SetShard(value); }
    }
    public Builder SetShard(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasShard = true;
      result.shard_ = value;
      return this;
    }
    public Builder ClearShard() {
      PrepareBuilder();
      result.hasShard = false;
      result.shard_ = "";
      return this;
    }
    
    public bool HasEntityCount {
      get { return result.hasEntityCount; }
    }
    public int EntityCount {
      get { return result.EntityCount; }
      set { SetEntityCount(value); }
    }
    public Builder SetEntityCount(int value) {
      PrepareBuilder();
      result.hasEntityCount = true;
      result.entityCount_ = value;
      return this;
    }
    public Builder ClearEntityCount() {
      PrepareBuilder();
      result.hasEntityCount = false;
      result.entityCount_ = 0;
      return this;
    }
  }
  static ShardStats() {
    object.ReferenceEquals(global::ClusterShardingMessages.Descriptor, null);
  }
}

#endregion


#endregion Designer generated code
