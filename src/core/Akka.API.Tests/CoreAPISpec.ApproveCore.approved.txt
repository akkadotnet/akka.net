[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Benchmarks")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tests.MultiNode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tools")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.DistributedData")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.MultiNodeTestRunner.Shared.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Persistence")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Persistence.TCK")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.TestKit.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests.MultiNode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Streams")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Streams.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.TestKit.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Tests.Performance")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.InteropServices.GuidAttribute("1a5cab08-b032-49ca-8db3-9428c5a9db14")]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName="")]
namespace Akka.Actor
{
    public abstract class ActorBase : Akka.Actor.IInternalActor
    {
        protected ActorBase() { }
        protected static Akka.Actor.IActorContext Context { get; }
        protected static Akka.Actor.Receive EmptyReceive { get; }
        protected Akka.Actor.IActorRef Self { get; }
        protected Akka.Actor.IActorRef Sender { get; }
        public virtual void AroundPostRestart(System.Exception cause, object message) { }
        public virtual void AroundPostStop() { }
        public virtual void AroundPreRestart(System.Exception cause, object message) { }
        public virtual void AroundPreStart() { }
        protected virtual bool AroundReceive(Akka.Actor.Receive receive, object message) { }
        protected void Become(Akka.Actor.Receive receive) { }
        protected void BecomeStacked(Akka.Actor.Receive receive) { }
        protected virtual void PostRestart(System.Exception reason) { }
        protected virtual void PostStop() { }
        protected virtual void PreRestart(System.Exception reason, object message) { }
        protected virtual void PreStart() { }
        protected abstract bool Receive(object message);
        protected void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout) { }
        protected virtual Akka.Actor.SupervisorStrategy SupervisorStrategy() { }
        protected void UnbecomeStacked() { }
        protected virtual void Unhandled(object message) { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{Self,nq}")]
    public class ActorCell : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch, Akka.Actor.ICell, Akka.Actor.IUntypedActorContext
    {
        public const int UndefinedUid = 0;
        public ActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef parent) { }
        protected Akka.Actor.ActorBase Actor { get; }
        public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }
        public int CurrentEnvelopeId { get; }
        public object CurrentMessage { get; }
        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        public bool HasMessages { get; }
        public bool IsLocal { get; }
        protected bool IsNormal { get; }
        public bool IsTerminated { get; }
        protected bool IsTerminating { get; }
        public Akka.Dispatch.Mailbox Mailbox { get; }
        public int NumberOfMessages { get; }
        public Akka.Actor.IInternalActorRef Parent { get; }
        public Akka.Actor.Props Props { get; }
        public System.Nullable<System.TimeSpan> ReceiveTimeout { get; }
        public Akka.Actor.IActorRef Self { get; }
        public Akka.Actor.IActorRef Sender { get; }
        public Akka.Actor.ActorSystem System { get; }
        public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }
        public Akka.Dispatch.ActorTaskScheduler TaskScheduler { get; }
        public virtual Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }
        public Akka.Actor.ActorSelection ActorSelection(string path) { }
        public Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath path) { }
        protected void AddWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }
        protected void AddressTerminated(Akka.Actor.Address address) { }
        public virtual Akka.Actor.IActorRef AttachChild(Akka.Actor.Props props, bool isSystemService, string name = null) { }
        protected virtual void AutoReceiveMessage(Akka.Actor.Envelope envelope) { }
        public void Become(Akka.Actor.Receive receive) { }
        public void BecomeStacked(Akka.Actor.Receive receive) { }
        public void CheckReceiveTimeout(bool reschedule = True) { }
        protected void ClearActor(Akka.Actor.ActorBase actor) { }
        protected void ClearActorCell() { }
        protected virtual Akka.Actor.ActorBase CreateNewActorInstance() { }
        [System.ObsoleteAttribute("Use TryGetChildStatsByName [0.7.1]", true)]
        public Akka.Actor.IInternalActorRef GetChildByName(string name) { }
        public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }
        public static Akka.Actor.IActorRef GetCurrentSelfOrNoSender() { }
        public static Akka.Actor.IActorRef GetCurrentSenderOrNoSender() { }
        [System.ObsoleteAttribute("Use TryGetSingleChild [0.7.1]")]
        public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public void Init(bool sendSupervise, Akka.Dispatch.MailboxType mailboxType) { }
        public Akka.Actor.Internal.ChildRestartStats InitChild(Akka.Actor.IInternalActorRef actor) { }
        public void Invoke(Akka.Actor.Envelope envelope) { }
        protected virtual void PreStart() { }
        protected void PrepareForNewActor() { }
        protected virtual void ReceiveMessage(object message) { }
        public void ReceiveMessageForTest(Akka.Actor.Envelope envelope) { }
        protected void ReceivedTerminated(Akka.Actor.Terminated t) { }
        protected void RemWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }
        protected Akka.Actor.Internal.SuspendReason RemoveChildAndGetStateChange(Akka.Actor.IActorRef child) { }
        public void ReserveChild(string name) { }
        public void Restart(System.Exception cause) { }
        public void Resume(System.Exception causedByFailure) { }
        public virtual void SendMessage(Akka.Actor.Envelope message) { }
        public virtual void SendMessage(Akka.Actor.IActorRef sender, object message) { }
        public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }
        protected void SetActorFields(Akka.Actor.ActorBase actor) { }
        protected bool SetChildrenTerminationReason(Akka.Actor.Internal.SuspendReason reason) { }
        public void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout = null) { }
        protected void SetTerminated() { }
        public static Akka.Actor.NameAndUid SplitNameAndUid(string name) { }
        public virtual void Start() { }
        protected void Stash(Akka.Dispatch.SysMsg.SystemMessage msg) { }
        public void Stop(Akka.Actor.IActorRef child) { }
        public void Stop() { }
        protected void StopFunctionRefs() { }
        public void Suspend() { }
        protected void TellWatchersWeDied() { }
        public void TerminatedQueuedFor(Akka.Actor.IActorRef subject, Akka.Util.Option<object> customMessage) { }
        public bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child) { }
        protected bool TryGetChildStatsByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats child) { }
        public bool TryGetSingleChild(string name, out Akka.Actor.IInternalActorRef child) { }
        public void UnbecomeStacked() { }
        protected void UnreserveChild(string name) { }
        public Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject) { }
        protected void UnwatchWatchedActors(Akka.Actor.ActorBase actor) { }
        public void UseThreadContext(System.Action action) { }
        public Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject) { }
        public Akka.Actor.IActorRef WatchWith(Akka.Actor.IActorRef subject, object message) { }
        protected void WatchedActorTerminated(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }
    }
    public sealed class ActorIdentity
    {
        public ActorIdentity(object messageId, Akka.Actor.IActorRef subject) { }
        public object MessageId { get; }
        public Akka.Actor.IActorRef Subject { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class ActorInitializationException : Akka.Actor.AkkaException
    {
        public ActorInitializationException() { }
        public ActorInitializationException(string message) { }
        public ActorInitializationException(string message, System.Exception cause) { }
        public ActorInitializationException(Akka.Actor.IActorRef actor, string message, System.Exception cause = null) { }
        public Akka.Actor.IActorRef Actor { get; set; }
        public override string ToString() { }
    }
    public class ActorInterruptedException : Akka.Actor.AkkaException
    {
        public ActorInterruptedException(string message = null, System.Exception cause = null) { }
    }
    public class ActorKilledException : Akka.Actor.AkkaException
    {
        public ActorKilledException() { }
        public ActorKilledException(string message) { }
    }
    public class ActorNotFoundException : Akka.Actor.AkkaException
    {
        public ActorNotFoundException() { }
        public ActorNotFoundException(string message, System.Exception innerException = null) { }
    }
    public abstract class ActorPath : Akka.Util.ISurrogated, System.IComparable<Akka.Actor.ActorPath>, System.IEquatable<Akka.Actor.ActorPath>
    {
        protected ActorPath(Akka.Actor.Address address, string name) { }
        protected ActorPath(Akka.Actor.ActorPath parentPath, string name, long uid) { }
        public Akka.Actor.Address Address { get; }
        public abstract System.Collections.Generic.IReadOnlyList<string> Elements { get; }
        public string Name { get; }
        public abstract Akka.Actor.ActorPath Parent { get; }
        public abstract Akka.Actor.ActorPath Root { get; }
        public long Uid { get; }
        public Akka.Actor.ActorPath Child(string childName) { }
        public abstract int CompareTo(Akka.Actor.ActorPath other);
        public bool Equals(Akka.Actor.ActorPath other) { }
        public override bool Equals(object obj) { }
        public static string FormatPathElements(System.Collections.Generic.IEnumerable<string> pathElements) { }
        public override int GetHashCode() { }
        public static bool IsValidPathElement(string s) { }
        public static Akka.Actor.ActorPath Parse(string path) { }
        public string ToSerializationFormat() { }
        public string ToSerializationFormatWithAddress(Akka.Actor.Address address) { }
        public override string ToString() { }
        public string ToStringWithAddress() { }
        public string ToStringWithAddress(Akka.Actor.Address address) { }
        public string ToStringWithUid() { }
        public string ToStringWithoutAddress() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public static bool TryParse(string path, out Akka.Actor.ActorPath actorPath) { }
        public static bool TryParseAddress(string path, out Akka.Actor.Address address) { }
        public abstract Akka.Actor.ActorPath WithUid(long uid);
        public static Akka.Actor.ActorPath /(Akka.Actor.ActorPath path, string name) { }
        public static Akka.Actor.ActorPath /(Akka.Actor.ActorPath path, System.Collections.Generic.IEnumerable<string> name) { }
        public static bool ==(Akka.Actor.ActorPath left, Akka.Actor.ActorPath right) { }
        public static bool !=(Akka.Actor.ActorPath left, Akka.Actor.ActorPath right) { }
        public class Surrogate : Akka.Util.ISurrogate, System.IEquatable<Akka.Actor.ActorPath.Surrogate>, System.IEquatable<Akka.Actor.ActorPath>
        {
            public Surrogate(string path) { }
            public string Path { get; }
            public bool Equals(Akka.Actor.ActorPath.Surrogate other) { }
            public bool Equals(Akka.Actor.ActorPath other) { }
            public override bool Equals(object obj) { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
            public override int GetHashCode() { }
        }
    }
    [System.ObsoleteAttribute("Actor producer pipeline API will be removed in v1.5.")]
    public class ActorProducerPipeline : System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin>, System.Collections.IEnumerable
    {
        public ActorProducerPipeline(System.Lazy<Akka.Event.ILoggingAdapter> log, System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin> plugins) { }
        public int Count { get; }
        public void AfterActorIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public void BeforeActorIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public System.Collections.Generic.IEnumerator<Akka.Actor.IActorProducerPlugin> GetEnumerator() { }
    }
    [System.ObsoleteAttribute("Actor producer pipeline API will be removed in v1.5.")]
    public class ActorProducerPipelineResolver
    {
        public ActorProducerPipelineResolver(System.Func<Akka.Event.ILoggingAdapter> logBuilder) { }
        public int TotalPluginCount { get; }
        public bool Insert(int index, Akka.Actor.IActorProducerPlugin plugin) { }
        public bool IsRegistered(Akka.Actor.IActorProducerPlugin plugin) { }
        public bool Register(Akka.Actor.IActorProducerPlugin plugin) { }
        public bool Unregister(Akka.Actor.IActorProducerPlugin plugin) { }
    }
    [System.ObsoleteAttribute("Actor producer pipeline API will be removed in v1.5.")]
    public abstract class ActorProducerPluginBase : Akka.Actor.IActorProducerPlugin
    {
        protected ActorProducerPluginBase() { }
        public virtual void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public virtual void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public virtual bool CanBeAppliedTo(System.Type actorType) { }
    }
    [System.ObsoleteAttribute("Actor producer pipeline API will be removed in v1.5.")]
    public abstract class ActorProducerPluginBase<TActor> : Akka.Actor.IActorProducerPlugin
        where TActor : Akka.Actor.ActorBase
    {
        protected ActorProducerPluginBase() { }
        public virtual void AfterIncarnated(TActor actor, Akka.Actor.IActorContext context) { }
        public virtual void BeforeIncarnated(TActor actor, Akka.Actor.IActorContext context) { }
        public virtual bool CanBeAppliedTo(System.Type actorType) { }
    }
    public abstract class ActorRefBase : Akka.Actor.IActorRef, Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        protected ActorRefBase() { }
        public abstract Akka.Actor.ActorPath Path { get; }
        public int CompareTo(object obj) { }
        public int CompareTo(Akka.Actor.IActorRef other) { }
        public override bool Equals(object obj) { }
        public bool Equals(Akka.Actor.IActorRef other) { }
        public override int GetHashCode() { }
        public void Tell(object message, Akka.Actor.IActorRef sender) { }
        protected abstract void TellInternal(object message, Akka.Actor.IActorRef sender);
        public override string ToString() { }
        public virtual Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class Surrogate : Akka.Util.ISurrogate
        {
            public Surrogate(string path) { }
            public string Path { get; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class static ActorRefExtensions
    {
        public static Akka.Actor.IActorRef GetOrElse(this Akka.Actor.IActorRef actorRef, System.Func<Akka.Actor.IActorRef> elseValue) { }
        public static bool IsNobody(this Akka.Actor.IActorRef actorRef) { }
    }
    public class static ActorRefFactoryExtensions
    {
        public static Akka.Actor.IActorRef ActorOf<TActor>(this Akka.Actor.IActorRefFactory factory, string name = null)
            where TActor : Akka.Actor.ActorBase, new () { }
        public static Akka.Actor.ActorSelection ActorSelection(this Akka.Actor.IActorRefFactory factory, Akka.Actor.IActorRef anchorRef, string actorPath) { }
    }
    public class static ActorRefFactoryShared
    {
        public static Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath, Akka.Actor.ActorSystem system) { }
        public static Akka.Actor.ActorSelection ActorSelection(string path, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef lookupRoot) { }
        public static Akka.Actor.ActorSelection ActorSelection(Akka.Actor.IActorRef anchorActorRef, string path) { }
    }
    public class static ActorRefImplicitSenderExtensions
    {
        public static void Forward(this Akka.Actor.IActorRef receiver, object message) { }
        public static void Tell(this Akka.Actor.IActorRef receiver, object message) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class ActorRefWithCell : Akka.Actor.InternalActorRefBase
    {
        protected ActorRefWithCell() { }
        public abstract System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }
        public abstract Akka.Actor.ICell Underlying { get; }
        public abstract Akka.Actor.IInternalActorRef GetSingleChild(string name);
    }
    public class static ActorRefs
    {
        public static readonly Akka.Actor.IActorRef NoSender;
        public static readonly Akka.Actor.Nobody Nobody;
    }
    public class ActorSelection : Akka.Actor.ICanTell
    {
        public ActorSelection() { }
        public ActorSelection(Akka.Actor.IActorRef anchor, Akka.Actor.SelectionPathElement[] path) { }
        public ActorSelection(Akka.Actor.IActorRef anchor, string path) { }
        public ActorSelection(Akka.Actor.IActorRef anchor, System.Collections.Generic.IEnumerable<string> elements) { }
        public Akka.Actor.IActorRef Anchor { get; }
        public Akka.Actor.SelectionPathElement[] Path { get; }
        public string PathString { get; }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Actor.ActorSelection other) { }
        public override int GetHashCode() { }
        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ResolveOne(System.TimeSpan timeout) { }
        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ResolveOne(System.TimeSpan timeout, System.Threading.CancellationToken ct) { }
        public void Tell(object message, Akka.Actor.IActorRef sender = null) { }
        public override string ToString() { }
    }
    public class ActorSelectionMessage : Akka.Actor.IAutoReceivedMessage, Akka.Actor.IPossiblyHarmful
    {
        public ActorSelectionMessage(object message, Akka.Actor.SelectionPathElement[] elements, bool wildCardFanOut = False) { }
        public Akka.Actor.SelectionPathElement[] Elements { get; }
        public object Message { get; }
        public bool WildCardFanOut { get; }
        public Akka.Actor.ActorSelectionMessage Copy(object message = null, Akka.Actor.SelectionPathElement[] elements = null, System.Nullable<bool> wildCardFanOut = null) { }
        public override string ToString() { }
    }
    public class ActorStashPlugin : Akka.Actor.ActorProducerPluginBase
    {
        public ActorStashPlugin() { }
        public override void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public override void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public override bool CanBeAppliedTo(System.Type actorType) { }
    }
    public abstract class ActorSystem : Akka.Actor.IActorRefFactory, System.IDisposable
    {
        protected ActorSystem() { }
        public abstract Akka.Actor.IActorRef DeadLetters { get; }
        public abstract Akka.Dispatch.Dispatchers Dispatchers { get; }
        public abstract Akka.Event.EventStream EventStream { get; }
        public abstract Akka.Event.ILoggingAdapter Log { get; }
        public abstract Akka.Dispatch.Mailboxes Mailboxes { get; }
        public abstract string Name { get; }
        public abstract Akka.Actor.IScheduler Scheduler { get; }
        public abstract Akka.Serialization.Serialization Serialization { get; }
        public abstract Akka.Actor.Settings Settings { get; }
        public System.TimeSpan StartTime { get; }
        public System.TimeSpan Uptime { get; }
        public abstract System.Threading.Tasks.Task WhenTerminated { get; }
        public abstract Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null);
        public abstract Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath);
        public abstract Akka.Actor.ActorSelection ActorSelection(string actorPath);
        public static Akka.Actor.ActorSystem Create(string name, Akka.Configuration.Config config) { }
        public static Akka.Actor.ActorSystem Create(string name, Akka.Actor.BootstrapSetup setup) { }
        public static Akka.Actor.ActorSystem Create(string name, Akka.Actor.Setup.ActorSystemSetup setup) { }
        public static Akka.Actor.ActorSystem Create(string name) { }
        public void Dispose() { }
        public abstract object GetExtension(Akka.Actor.IExtensionId extensionId);
        public abstract T GetExtension<T>()
            where T :  class, Akka.Actor.IExtension;
        public abstract bool HasExtension(System.Type type);
        public abstract bool HasExtension<T>()
            where T :  class, Akka.Actor.IExtension;
        public abstract object RegisterExtension(Akka.Actor.IExtensionId extension);
        public abstract void RegisterOnTermination(System.Action code);
        public abstract void Stop(Akka.Actor.IActorRef actor);
        public abstract System.Threading.Tasks.Task Terminate();
        public abstract bool TryGetExtension(System.Type extensionType, out object extension);
        public abstract bool TryGetExtension<T>(out T extension)
            where T :  class, Akka.Actor.IExtension;
    }
    public class static ActorSystemWithExtensions
    {
        public static T WithExtension<T>(this Akka.Actor.ActorSystem system)
            where T :  class, Akka.Actor.IExtension { }
        public static T WithExtension<T>(this Akka.Actor.ActorSystem system, System.Type extensionId)
            where T :  class, Akka.Actor.IExtension { }
        public static T WithExtension<T, TI>(this Akka.Actor.ActorSystem system)
            where T :  class, Akka.Actor.IExtension
            where TI : Akka.Actor.IExtensionId { }
    }
    public sealed class Address : Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.Address>, System.IEquatable<Akka.Actor.Address>
    {
        public static readonly Akka.Actor.Address AllSystems;
        public static readonly System.Collections.Generic.IComparer<Akka.Actor.Address> Comparer;
        public Address(string protocol, string system, string host = null, System.Nullable<int> port = null) { }
        public bool HasGlobalScope { get; }
        public bool HasLocalScope { get; }
        public string Host { get; }
        public System.Nullable<int> Port { get; }
        public string Protocol { get; }
        public string System { get; }
        public object Clone() { }
        public int CompareTo(Akka.Actor.Address other) { }
        public bool Equals(Akka.Actor.Address other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public string HostPort() { }
        public static Akka.Actor.Address Parse(string address) { }
        public override string ToString() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Address WithHost(string host = null) { }
        public Akka.Actor.Address WithPort(System.Nullable<int> port = null) { }
        public Akka.Actor.Address WithProtocol(string protocol) { }
        public Akka.Actor.Address WithSystem(string system) { }
        public static bool ==(Akka.Actor.Address left, Akka.Actor.Address right) { }
        public static bool !=(Akka.Actor.Address left, Akka.Actor.Address right) { }
        public class AddressSurrogate : Akka.Util.ISurrogate
        {
            public AddressSurrogate() { }
            public string Host { get; set; }
            public System.Nullable<int> Port { get; set; }
            public string Protocol { get; set; }
            public string System { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public abstract class AkkaException : System.Exception
    {
        protected AkkaException() { }
        protected AkkaException(string message, System.Exception cause = null) { }
        protected System.Exception Cause { get; }
    }
    public class AllForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.AllForOneStrategy>
    {
        public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }
        public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }
        public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }
        public AllForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public AllForOneStrategy(Akka.Actor.IDecider decider) { }
        protected AllForOneStrategy() { }
        public override Akka.Actor.IDecider Decider { get; }
        public int MaxNumberOfRetries { get; }
        public int WithinTimeRangeMilliseconds { get; }
        public bool Equals(Akka.Actor.AllForOneStrategy other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception) { }
        public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }
        public override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class AllForOneStrategySurrogate : Akka.Util.ISurrogate
        {
            public AllForOneStrategySurrogate() { }
            public Akka.Actor.IDecider Decider { get; set; }
            public bool LoggingEnabled { get; set; }
            public int MaxNumberOfRetries { get; set; }
            public int WithinTimeRangeMilliseconds { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class AskTimeoutException : Akka.Actor.AkkaException
    {
        public AskTimeoutException(string message) { }
    }
    public sealed class BootstrapSetup : Akka.Actor.Setup.Setup
    {
        public Akka.Util.Option<Akka.Actor.ProviderSelection> ActorRefProvider { get; }
        public Akka.Util.Option<Akka.Configuration.Config> Config { get; }
        public static Akka.Actor.BootstrapSetup Create() { }
        public Akka.Actor.BootstrapSetup WithActorRefProvider(Akka.Actor.ProviderSelection name) { }
        public Akka.Actor.BootstrapSetup WithConfig(Akka.Configuration.Config config) { }
    }
    public class Cancelable : Akka.Actor.ICancelable, System.IDisposable
    {
        public Cancelable(Akka.Actor.IActionScheduler scheduler, System.TimeSpan delay) { }
        public Cancelable(Akka.Actor.IScheduler scheduler, System.TimeSpan delay) { }
        public Cancelable(Akka.Actor.IScheduler scheduler, int millisecondsDelay) { }
        public Cancelable(Akka.Actor.IScheduler scheduler) { }
        public Cancelable(Akka.Actor.IActionScheduler scheduler) { }
        public bool IsCancellationRequested { get; }
        public System.Threading.CancellationToken Token { get; }
        public void Cancel() { }
        public void Cancel(bool throwOnFirstException) { }
        public void CancelAfter(System.TimeSpan delay) { }
        public void CancelAfter(int millisecondsDelay) { }
        public static Akka.Actor.ICancelable CreateCanceled() { }
        public static Akka.Actor.ICancelable CreateLinkedCancelable(Akka.Actor.IScheduler scheduler, params Akka.Actor.ICancelable[] cancelables) { }
        public static Akka.Actor.ICancelable CreateLinkedCancelable(Akka.Actor.IActionScheduler scheduler, params Akka.Actor.ICancelable[] cancelables) { }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
    }
    public class static CancelableExtensions
    {
        public static void CancelIfNotNull(this Akka.Actor.ICancelable cancelable) { }
    }
    public class ChildActorPath : Akka.Actor.ActorPath
    {
        public ChildActorPath(Akka.Actor.ActorPath parentPath, string name, long uid) { }
        public override System.Collections.Generic.IReadOnlyList<string> Elements { get; }
        public override Akka.Actor.ActorPath Parent { get; }
        public override Akka.Actor.ActorPath Root { get; }
        public override int CompareTo(Akka.Actor.ActorPath other) { }
        public override int GetHashCode() { }
        public override Akka.Actor.ActorPath WithUid(long uid) { }
    }
    public sealed class CoordinatedShutdown : Akka.Actor.IExtension
    {
        public const string PhaseActorSystemTerminate = "actor-system-terminate";
        public const string PhaseBeforeActorSystemTerminate = "before-actor-system-terminate";
        public const string PhaseBeforeClusterShutdown = "before-cluster-shutdown";
        public const string PhaseBeforeServiceUnbind = "before-service-unbind";
        public const string PhaseClusterExiting = "cluster-exiting";
        public const string PhaseClusterExitingDone = "cluster-exiting-done";
        public const string PhaseClusterLeave = "cluster-leave";
        public const string PhaseClusterShardingShutdownRegion = "cluster-sharding-shutdown-region";
        public const string PhaseClusterShutdown = "cluster-shutdown";
        public const string PhaseServiceRequestsDone = "service-requests-done";
        public const string PhaseServiceStop = "service-stop";
        public const string PhaseServiceUnbind = "service-unbind";
        public Akka.Actor.CoordinatedShutdown.Reason ShutdownReason { get; }
        public Akka.Actor.ExtendedActorSystem System { get; }
        public System.TimeSpan TotalTimeout { get; }
        public void AddTask(string phase, string taskName, System.Func<System.Threading.Tasks.Task<Akka.Done>> task) { }
        public static Akka.Actor.CoordinatedShutdown Get(Akka.Actor.ActorSystem sys) { }
        public System.Threading.Tasks.Task<Akka.Done> Run(Akka.Actor.CoordinatedShutdown.Reason reason, string fromPhase = null) { }
        public System.TimeSpan Timeout(string phase) { }
        public class ActorSystemTerminateReason : Akka.Actor.CoordinatedShutdown.Reason
        {
            public static readonly Akka.Actor.CoordinatedShutdown.Reason Instance;
        }
        public class ClrExitReason : Akka.Actor.CoordinatedShutdown.Reason
        {
            public static readonly Akka.Actor.CoordinatedShutdown.Reason Instance;
        }
        public class ClusterDowningReason : Akka.Actor.CoordinatedShutdown.Reason
        {
            public static readonly Akka.Actor.CoordinatedShutdown.Reason Instance;
        }
        public class ClusterJoinUnsuccessfulReason : Akka.Actor.CoordinatedShutdown.Reason
        {
            public static readonly Akka.Actor.CoordinatedShutdown.Reason Instance;
        }
        public class ClusterLeavingReason : Akka.Actor.CoordinatedShutdown.Reason
        {
            public static readonly Akka.Actor.CoordinatedShutdown.Reason Instance;
        }
        public class Reason
        {
            protected Reason() { }
        }
        public class UnknownReason : Akka.Actor.CoordinatedShutdown.Reason
        {
            public static readonly Akka.Actor.CoordinatedShutdown.Reason Instance;
        }
    }
    public sealed class CoordinatedShutdownExtension : Akka.Actor.ExtensionIdProvider<Akka.Actor.CoordinatedShutdown>
    {
        public CoordinatedShutdownExtension() { }
        public override Akka.Actor.CoordinatedShutdown CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
    }
    public class DateTimeOffsetNowTimeProvider : Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider
    {
        public System.TimeSpan HighResMonotonicClock { get; }
        public static Akka.Actor.DateTimeOffsetNowTimeProvider Instance { get; }
        public System.TimeSpan MonotonicClock { get; }
        public System.DateTimeOffset Now { get; }
    }
    public class DeadLetterActorRef : Akka.Actor.EmptyLocalActorRef
    {
        public DeadLetterActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }
        protected override bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class DeadLetterMailbox : Akka.Dispatch.Mailbox
    {
        public DeadLetterMailbox(Akka.Actor.IActorRef deadLetters) { }
    }
    public class DeathPactException : Akka.Actor.AkkaException
    {
        public DeathPactException(Akka.Actor.IActorRef deadActor) { }
        public Akka.Actor.IActorRef DeadActor { get; }
    }
    public class static Decider
    {
        public static Akka.Actor.DeployableDecider From(Akka.Actor.Directive defaultDirective, params System.Collections.Generic.KeyValuePair<, >[] pairs) { }
        public static Akka.Actor.DeployableDecider From(Akka.Actor.Directive defaultDirective, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive>> pairs) { }
        public static Akka.Actor.LocalOnlyDecider From(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
    }
    public class DefaultSupervisorStrategy : Akka.Actor.SupervisorStrategyConfigurator
    {
        public DefaultSupervisorStrategy() { }
        public override Akka.Actor.SupervisorStrategy Create() { }
    }
    public class Deploy : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Deploy>
    {
        public static readonly Akka.Actor.Deploy Local;
        public static readonly string NoDispatcherGiven;
        public static readonly string NoMailboxGiven;
        public static readonly Akka.Actor.Scope NoScopeGiven;
        public static readonly Akka.Actor.Deploy None;
        public Deploy() { }
        public Deploy(string path, Akka.Actor.Scope scope) { }
        public Deploy(Akka.Actor.Scope scope) { }
        public Deploy(Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope) { }
        public Deploy(Akka.Routing.RouterConfig routerConfig) { }
        public Deploy(string path, Akka.Configuration.Config config, Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope, string dispatcher) { }
        public Deploy(string path, Akka.Configuration.Config config, Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope, string dispatcher, string mailbox) { }
        public Akka.Configuration.Config Config { get; }
        public string Dispatcher { get; }
        public string Mailbox { get; }
        public string Path { get; }
        public Akka.Routing.RouterConfig RouterConfig { get; }
        public Akka.Actor.Scope Scope { get; }
        public bool Equals(Akka.Actor.Deploy other) { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Deploy WithDispatcher(string dispatcher) { }
        public Akka.Actor.Deploy WithFallback(Akka.Actor.Deploy other) { }
        public Akka.Actor.Deploy WithMailbox(string mailbox) { }
        public Akka.Actor.Deploy WithRouterConfig(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Actor.Deploy WithScope(Akka.Actor.Scope scope) { }
        public class DeploySurrogate : Akka.Util.ISurrogate
        {
            public DeploySurrogate() { }
            public Akka.Configuration.Config Config { get; set; }
            public string Dispatcher { get; set; }
            public string Mailbox { get; set; }
            public string Path { get; set; }
            public Akka.Routing.RouterConfig RouterConfig { get; set; }
            public Akka.Actor.Scope Scope { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class DeployableDecider : Akka.Actor.IDecider, System.IEquatable<Akka.Actor.DeployableDecider>
    {
        protected DeployableDecider() { }
        public DeployableDecider(Akka.Actor.Directive defaultDirective, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive>> pairs) { }
        public DeployableDecider(Akka.Actor.Directive defaultDirective, params System.Collections.Generic.KeyValuePair<, >[] pairs) { }
        public Akka.Actor.Directive DefaultDirective { get; }
        public System.Collections.Generic.KeyValuePair<, >[] Pairs { get; }
        public Akka.Actor.Directive Decide(System.Exception cause) { }
        public bool Equals(Akka.Actor.DeployableDecider other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public class Deployer
    {
        protected readonly Akka.Configuration.Config Default;
        public Deployer(Akka.Actor.Settings settings) { }
        public Akka.Actor.Deploy Lookup(Akka.Actor.ActorPath path) { }
        public Akka.Actor.Deploy Lookup(System.Collections.Generic.IEnumerable<string> path) { }
        public virtual Akka.Actor.Deploy ParseConfig(string key, Akka.Configuration.Config config) { }
        public void SetDeploy(Akka.Actor.Deploy deploy) { }
    }
    public enum Directive
    {
        Resume = 0,
        Restart = 1,
        Escalate = 2,
        Stop = 3,
    }
    public class static DirectiveExtensions
    {
        public static System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive> When<TException>(this Akka.Actor.Directive self)
            where TException : System.Exception { }
    }
    public class EmptyLocalActorRef : Akka.Actor.MinimalActorRef
    {
        public EmptyLocalActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
        public override bool IsTerminated { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        protected virtual bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public struct Envelope
    {
        public Envelope(object message, Akka.Actor.IActorRef sender, Akka.Actor.ActorSystem system) { }
        public Envelope(object message, Akka.Actor.IActorRef sender) { }
        public object Message { get; }
        public Akka.Actor.IActorRef Sender { get; }
        public override string ToString() { }
    }
    public class EventStreamActor : Akka.Actor.ActorBase
    {
        public EventStreamActor() { }
        protected override bool Receive(object message) { }
    }
    public abstract class ExtendedActorSystem : Akka.Actor.ActorSystem
    {
        protected ExtendedActorSystem() { }
        [System.ObsoleteAttribute("Actor producer pipeline API will be removed in v1.5.")]
        public abstract Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }
        public abstract Akka.Actor.IInternalActorRef Guardian { get; }
        public abstract Akka.Actor.IInternalActorRef LookupRoot { get; }
        public abstract Akka.Actor.IActorRefProvider Provider { get; }
        public abstract Akka.Actor.IInternalActorRef SystemGuardian { get; }
        public abstract void Abort();
        public abstract Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null);
        public abstract Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)
            where TActor : Akka.Actor.ActorBase, new ();
    }
    public abstract class ExtensionIdProvider<T> : Akka.Actor.IExtensionId, Akka.Actor.IExtensionId<T>
        where T : Akka.Actor.IExtension
    {
        protected ExtensionIdProvider() { }
        public System.Type ExtensionType { get; }
        public T Apply(Akka.Actor.ActorSystem system) { }
        public abstract T CreateExtension(Akka.Actor.ExtendedActorSystem system);
        public override bool Equals(object obj) { }
        public T Get(Akka.Actor.ActorSystem system) { }
        public override int GetHashCode() { }
    }
    public abstract class FSMBase : Akka.Actor.ActorBase
    {
        protected FSMBase() { }
        public sealed class CurrentState<TS>
        {
            public CurrentState(Akka.Actor.IActorRef fsmRef, TS state) { }
            public Akka.Actor.IActorRef FsmRef { get; }
            public TS State { get; }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class Event<TD> : Akka.Actor.INoSerializationVerificationNeeded
        {
            public Event(object fsmEvent, TD stateData) { }
            public object FsmEvent { get; }
            public TD StateData { get; }
            public override string ToString() { }
        }
        public sealed class Failure : Akka.Actor.FSMBase.Reason
        {
            public Failure(object cause) { }
            public object Cause { get; }
            public override string ToString() { }
        }
        public sealed class LogEntry<TS, TD>
        {
            public LogEntry(TS stateName, TD stateData, object fsmEvent) { }
            public object FsmEvent { get; }
            public TD StateData { get; }
            public TS StateName { get; }
            public override string ToString() { }
        }
        public sealed class Normal : Akka.Actor.FSMBase.Reason
        {
            public static Akka.Actor.FSMBase.Normal Instance { get; }
        }
        public abstract class Reason
        {
            protected Reason() { }
        }
        public sealed class Shutdown : Akka.Actor.FSMBase.Reason
        {
            public static Akka.Actor.FSMBase.Shutdown Instance { get; }
        }
        public sealed class StateTimeout
        {
            public static Akka.Actor.FSMBase.StateTimeout Instance { get; }
        }
        public class State<TS, TD> : System.IEquatable<Akka.Actor.FSMBase.State<TS, TD>>
        {
            public State(TS stateName, TD stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.IReadOnlyList<object> replies = null, bool notifies = True) { }
            public System.Collections.Generic.IReadOnlyList<object> Replies { get; set; }
            public TD StateData { get; }
            public TS StateName { get; }
            public Akka.Actor.FSMBase.Reason StopReason { get; }
            public System.Nullable<System.TimeSpan> Timeout { get; }
            public bool Equals(Akka.Actor.FSMBase.State<TS, TD> other) { }
            public override bool Equals(object obj) { }
            public Akka.Actor.FSMBase.State<TS, TD> ForMax(System.TimeSpan timeout) { }
            public override int GetHashCode() { }
            public Akka.Actor.FSMBase.State<TS, TD> Replying(object replyValue) { }
            public override string ToString() { }
            public Akka.Actor.FSMBase.State<TS, TD> Using(TD nextStateData) { }
        }
        public sealed class StopEvent<TS, TD> : Akka.Actor.INoSerializationVerificationNeeded
        {
            public StopEvent(Akka.Actor.FSMBase.Reason reason, TS terminatedState, TD stateData) { }
            public Akka.Actor.FSMBase.Reason Reason { get; }
            public TD StateData { get; }
            public TS TerminatedState { get; }
            public override string ToString() { }
        }
        public sealed class SubscribeTransitionCallBack
        {
            public SubscribeTransitionCallBack(Akka.Actor.IActorRef actorRef) { }
            public Akka.Actor.IActorRef ActorRef { get; }
        }
        public sealed class Transition<TS>
        {
            public Transition(Akka.Actor.IActorRef fsmRef, TS from, TS to) { }
            public TS From { get; }
            public Akka.Actor.IActorRef FsmRef { get; }
            public TS To { get; }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class UnsubscribeTransitionCallBack
        {
            public UnsubscribeTransitionCallBack(Akka.Actor.IActorRef actorRef) { }
            public Akka.Actor.IActorRef ActorRef { get; }
        }
    }
    public abstract class FSM<TState, TData> : Akka.Actor.FSMBase, Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState, TData>, Akka.Routing.IListeners
    {
        protected bool DebugEvent;
        protected FSM() { }
        public Akka.Routing.ListenerSupport Listeners { get; }
        public TData NextStateData { get; }
        public TData StateData { get; }
        public TState StateName { get; }
        public void CancelTimer(string name) { }
        public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName) { }
        [System.ObsoleteAttribute("This method is obsoleted. Use GoTo(nextStateName).Using(newStateData) [1.2.0]")]
        public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName, TData stateData) { }
        public void Initialize() { }
        public bool IsTimerActive(string name) { }
        protected virtual void LogTermination(Akka.Actor.FSMBase.Reason reason) { }
        public void OnTermination(System.Action<Akka.Actor.FSMBase.StopEvent<TState, TData>> terminationHandler) { }
        public void OnTransition(Akka.Actor.FSM<TState, TData>.TransitionHandler transitionHandler) { }
        protected override void PostStop() { }
        protected override bool Receive(object message) { }
        public void SetStateTimeout(TState state, System.Nullable<System.TimeSpan> timeout) { }
        public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }
        public void StartWith(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }
        public Akka.Actor.FSMBase.State<TState, TData> Stay() { }
        public Akka.Actor.FSMBase.State<TState, TData> Stop() { }
        public Akka.Actor.FSMBase.State<TState, TData> Stop(Akka.Actor.FSMBase.Reason reason) { }
        public Akka.Actor.FSMBase.State<TState, TData> Stop(Akka.Actor.FSMBase.Reason reason, TData stateData) { }
        public Akka.Actor.FSM<TState, TData>.TransformHelper Transform(Akka.Actor.FSM<TState, TData>.StateFunction func) { }
        public void When(TState stateName, Akka.Actor.FSM<TState, TData>.StateFunction func, System.Nullable<System.TimeSpan> timeout = null) { }
        public void WhenUnhandled(Akka.Actor.FSM<TState, TData>.StateFunction stateFunction) { }
        public delegate Akka.Actor.FSMBase.State<TState, TData> StateFunction<TState, TData>(Akka.Actor.FSMBase.Event<TData> fsmEvent);
        public sealed class TransformHelper<TState, TData>
        {
            public TransformHelper(Akka.Actor.FSM<TState, TData>.StateFunction func) { }
            public Akka.Actor.FSM<TState, TData>.StateFunction Func { get; }
            public Akka.Actor.FSM<TState, TData>.StateFunction Using(System.Func<Akka.Actor.FSMBase.State<TState, TData>, Akka.Actor.FSMBase.State<TState, TData>> andThen) { }
        }
        public delegate void TransitionHandler<TState, TData>(TState initialState, TState nextState);
    }
    public class Failure
    {
        public Failure() { }
        public System.Exception Exception { get; set; }
        public System.DateTime Timestamp { get; set; }
    }
    public class Failures
    {
        public Failures() { }
        public System.Collections.Generic.List<Akka.Actor.Failure> Entries { get; }
    }
    public class FutureActorRef : Akka.Actor.MinimalActorRef
    {
        public FutureActorRef(System.Threading.Tasks.TaskCompletionSource<object> result, System.Action unregister, Akka.Actor.ActorPath path) { }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class static Futures
    {
        public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }
        public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, System.Func<Akka.Actor.IActorRef, object> messageFactory, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }
    }
    public class static GracefulStopSupport
    {
        public static System.Threading.Tasks.Task<bool> GracefulStop(this Akka.Actor.IActorRef target, System.TimeSpan timeout) { }
        public static System.Threading.Tasks.Task<bool> GracefulStop(this Akka.Actor.IActorRef target, System.TimeSpan timeout, object stopMessage) { }
    }
    public class GuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        public GuardianActor() { }
        protected override void PreStart() { }
        protected override bool Receive(object message) { }
    }
    public class HashedWheelTimerScheduler : Akka.Actor.SchedulerBase, Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider, System.IDisposable
    {
        public HashedWheelTimerScheduler(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }
        public override System.TimeSpan HighResMonotonicClock { get; }
        public override System.TimeSpan MonotonicClock { get; }
        protected override System.DateTimeOffset TimeNow { get; }
        public void Dispose() { }
        protected override void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }
    }
    public interface IActionScheduler
    {
        void ScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);
        void ScheduleOnce(System.TimeSpan delay, System.Action action);
        void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);
        void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action);
    }
    public interface IActorContext : Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch
    {
        Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        Akka.Actor.IActorRef Parent { get; }
        Akka.Actor.Props Props { get; }
        System.Nullable<System.TimeSpan> ReceiveTimeout { get; }
        Akka.Actor.IActorRef Self { get; }
        Akka.Actor.IActorRef Sender { get; }
        Akka.Actor.ActorSystem System { get; }
        void Become(Akka.Actor.Receive receive);
        void BecomeStacked(Akka.Actor.Receive receive);
        Akka.Actor.IActorRef Child(string name);
        System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> GetChildren();
        void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout);
        void Stop(Akka.Actor.IActorRef child);
        void UnbecomeStacked();
    }
    [System.ObsoleteAttribute("Actor producer pipeline API will be removed in v1.5.")]
    public interface IActorProducerPlugin
    {
        void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context);
        void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context);
        bool CanBeAppliedTo(System.Type actorType);
    }
    public interface IActorRef : Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        Akka.Actor.ActorPath Path { get; }
    }
    public interface IActorRefFactory
    {
        Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null);
        Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath);
        Akka.Actor.ActorSelection ActorSelection(string actorPath);
    }
    public interface IActorRefProvider
    {
        Akka.Actor.IActorRef DeadLetters { get; }
        Akka.Actor.Address DefaultAddress { get; }
        Akka.Actor.Deployer Deployer { get; }
        Akka.Actor.LocalActorRef Guardian { get; }
        Akka.Actor.IInternalActorRef RootGuardian { get; }
        Akka.Actor.ActorPath RootPath { get; }
        [Akka.Annotations.InternalApiAttribute()]
        Akka.Serialization.Information SerializationInformation { get; }
        Akka.Actor.Settings Settings { get; }
        Akka.Actor.LocalActorRef SystemGuardian { get; }
        Akka.Actor.IInternalActorRef TempContainer { get; }
        System.Threading.Tasks.Task TerminationTask { get; }
        Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async);
        Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address);
        void Init(Akka.Actor.Internal.ActorSystemImpl system);
        void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path);
        Akka.Actor.IActorRef ResolveActorRef(string path);
        Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath actorPath);
        Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address);
        Akka.Actor.ActorPath TempPath();
        void UnregisterTempActor(Akka.Actor.ActorPath path);
    }
    [Akka.Annotations.InternalApiAttribute()]
    public interface IActorRefScope
    {
        bool IsLocal { get; }
    }
    public interface IActorStash
    {
        Akka.Actor.IStash Stash { get; set; }
    }
    public interface IAdvancedScheduler : Akka.Actor.IActionScheduler { }
    public interface IAutoReceivedMessage { }
    public interface ICanTell
    {
        void Tell(object message, Akka.Actor.IActorRef sender);
    }
    public interface ICanWatch
    {
        Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject);
        Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject);
        Akka.Actor.IActorRef WatchWith(Akka.Actor.IActorRef subject, object message);
    }
    public interface ICancelable
    {
        bool IsCancellationRequested { get; }
        System.Threading.CancellationToken Token { get; }
        void Cancel();
        void Cancel(bool throwOnFirstException);
        void CancelAfter(System.TimeSpan delay);
        void CancelAfter(int millisecondsDelay);
    }
    [Akka.Annotations.InternalApiAttribute()]
    public interface ICell
    {
        Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }
        bool HasMessages { get; }
        bool IsLocal { get; }
        bool IsTerminated { get; }
        int NumberOfMessages { get; }
        Akka.Actor.IInternalActorRef Parent { get; }
        Akka.Actor.Props Props { get; }
        Akka.Actor.IActorRef Self { get; }
        Akka.Actor.ActorSystem System { get; }
        Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }
        Akka.Actor.IInternalActorRef GetChildByName(string name);
        [System.ObsoleteAttribute("Used ChildrenRefs instead [1.1.0]")]
        System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren();
        Akka.Actor.IInternalActorRef GetSingleChild(string name);
        void Restart(System.Exception cause);
        void Resume(System.Exception causedByFailure);
        void SendMessage(Akka.Actor.IActorRef sender, object message);
        void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);
        void Start();
        void Stop();
        void Suspend();
        bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child);
    }
    public interface IDateTimeOffsetNowTimeProvider : Akka.Actor.ITimeProvider { }
    public interface IDecider
    {
        Akka.Actor.Directive Decide(System.Exception cause);
    }
    public interface IExtension { }
    public interface IExtensionId
    {
        System.Type ExtensionType { get; }
        object Apply(Akka.Actor.ActorSystem system);
        object CreateExtension(Akka.Actor.ExtendedActorSystem system);
        object Get(Akka.Actor.ActorSystem system);
    }
    public interface IExtensionId<out T> : Akka.Actor.IExtensionId
        where out T : Akka.Actor.IExtension
    {
        T Apply(Akka.Actor.ActorSystem system);
        T CreateExtension(Akka.Actor.ExtendedActorSystem system);
        T Get(Akka.Actor.ActorSystem system);
    }
    public interface IHandle<in TMessage>
    {
        void Handle(TMessage message);
    }
    public interface IInboxable : Akka.Actor.ICanWatch
    {
        Akka.Actor.IActorRef Receiver { get; }
        object Receive();
        object Receive(System.TimeSpan timeout);
        System.Threading.Tasks.Task<object> ReceiveAsync();
        System.Threading.Tasks.Task<object> ReceiveAsync(System.TimeSpan timeout);
        object ReceiveWhere(System.Predicate<object> predicate);
        object ReceiveWhere(System.Predicate<object> predicate, System.TimeSpan timeout);
        void Send(Akka.Actor.IActorRef target, object message);
    }
    public interface IIndirectActorProducer
    {
        System.Type ActorType { get; }
        Akka.Actor.ActorBase Produce();
        void Release(Akka.Actor.ActorBase actor);
    }
    public interface IInternalActor
    {
        Akka.Actor.IActorContext ActorContext { get; }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public interface IInternalActorRef : Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
        bool IsTerminated { get; }
        Akka.Actor.IInternalActorRef Parent { get; }
        Akka.Actor.IActorRefProvider Provider { get; }
        Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name);
        void Restart(System.Exception cause);
        void Resume(System.Exception causedByFailure = null);
        [System.ObsoleteAttribute("Use SendSystemMessage(message) [1.1.0]")]
        void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message, Akka.Actor.IActorRef sender);
        void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);
        void Start();
        void Stop();
        void Suspend();
    }
    public interface ILogReceive { }
    public interface ILoggingFSM { }
    public interface INoSerializationVerificationNeeded { }
    public interface INotInfluenceReceiveTimeout { }
    public interface IPossiblyHarmful { }
    public interface IRepointableRef : Akka.Actor.IActorRefScope
    {
        bool IsStarted { get; }
    }
    public interface IScheduler : Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider
    {
        Akka.Actor.IAdvancedScheduler Advanced { get; }
    }
    public interface IStash
    {
        System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> ClearStash();
        void Prepend(System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> envelopes);
        void Stash();
        void Unstash();
        void UnstashAll();
        void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate);
    }
    public interface ITellScheduler
    {
        void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender);
        void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
        void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender);
        void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
    }
    public interface ITimeProvider
    {
        System.TimeSpan HighResMonotonicClock { get; }
        System.TimeSpan MonotonicClock { get; }
        System.DateTimeOffset Now { get; }
    }
    public interface ITimerScheduler
    {
        void Cancel(object key);
        void CancelAll();
        bool IsTimerActive(object key);
        void StartPeriodicTimer(object key, object msg, System.TimeSpan interval);
        void StartPeriodicTimer(object key, object msg, System.TimeSpan initialDelay, System.TimeSpan interval);
        void StartSingleTimer(object key, object msg, System.TimeSpan timeout);
    }
    public interface IUntypedActorContext : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch
    {
        void Become(Akka.Actor.UntypedReceive receive);
        void BecomeStacked(Akka.Actor.UntypedReceive receive);
    }
    [System.ObsoleteAttribute("Bounded stashing is not yet implemented. Unbounded stashing will be used instead " +
        "[0.7.0]")]
    public interface IWithBoundedStash : Akka.Actor.IActorStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics> { }
    public interface IWithTimers
    {
        Akka.Actor.ITimerScheduler Timers { get; set; }
    }
    public interface IWithUnboundedStash : Akka.Actor.IActorStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics> { }
    public sealed class Identify : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INotInfluenceReceiveTimeout
    {
        public Identify(object messageId) { }
        public object MessageId { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class IllegalActorNameException : Akka.Actor.AkkaException
    {
        public IllegalActorNameException(string message) { }
    }
    public class IllegalActorStateException : Akka.Actor.AkkaException
    {
        public IllegalActorStateException(string message) { }
    }
    public class Inbox : Akka.Actor.ICanWatch, Akka.Actor.IInboxable, System.IDisposable
    {
        public Akka.Actor.IActorRef Receiver { get; }
        public static Akka.Actor.Inbox Create(Akka.Actor.ActorSystem system) { }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
        public object Receive() { }
        public object Receive(System.TimeSpan timeout) { }
        public System.Threading.Tasks.Task<object> ReceiveAsync() { }
        public System.Threading.Tasks.Task<object> ReceiveAsync(System.TimeSpan timeout) { }
        public object ReceiveWhere(System.Predicate<object> predicate) { }
        public object ReceiveWhere(System.Predicate<object> predicate, System.TimeSpan timeout) { }
        public void Send(Akka.Actor.IActorRef actorRef, object message) { }
        public Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject) { }
        public Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject) { }
        public Akka.Actor.IActorRef WatchWith(Akka.Actor.IActorRef subject, object message) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class InternalActorRefBase : Akka.Actor.ActorRefBase, Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Actor.IInternalActorRef, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        protected InternalActorRefBase() { }
        public abstract bool IsLocal { get; }
        public abstract bool IsTerminated { get; }
        public abstract Akka.Actor.IInternalActorRef Parent { get; }
        public abstract Akka.Actor.IActorRefProvider Provider { get; }
        public abstract Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name);
        public abstract void Restart(System.Exception cause);
        public abstract void Resume(System.Exception causedByFailure = null);
        [System.ObsoleteAttribute("Use SendSystemMessage(message) instead [1.1.0]")]
        public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message, Akka.Actor.IActorRef sender) { }
        public abstract void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);
        public abstract void Start();
        public abstract void Stop();
        public abstract void Suspend();
    }
    public class InvalidActorNameException : Akka.Actor.AkkaException
    {
        public InvalidActorNameException(string message) { }
        public InvalidActorNameException(string message, System.Exception innerException) { }
    }
    public class InvalidMessageException : Akka.Actor.AkkaException
    {
        public InvalidMessageException() { }
        public InvalidMessageException(string message) { }
    }
    public sealed class Kill : Akka.Actor.IAutoReceivedMessage
    {
        public static Akka.Actor.Kill Instance { get; }
        public override string ToString() { }
    }
    public class LocalActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope
    {
        public LocalActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }
        public Akka.Actor.ActorCell Cell { get; }
        public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }
        protected Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        public override bool IsLocal { get; }
        public override bool IsTerminated { get; }
        protected Akka.Dispatch.MailboxType MailboxType { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.ActorPath Path { get; }
        protected Akka.Actor.Props Props { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        protected Akka.Actor.IInternalActorRef Supervisor { get; }
        protected Akka.Actor.ActorSystem System { get; }
        public override Akka.Actor.ICell Underlying { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        protected virtual Akka.Actor.ActorCell NewActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef supervisor) { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class LocalActorRefProvider : Akka.Actor.IActorRefProvider
    {
        public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }
        public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream, Akka.Actor.Deployer deployer, System.Func<Akka.Actor.ActorPath, Akka.Actor.IInternalActorRef> deadLettersFactory) { }
        public Akka.Actor.IActorRef DeadLetters { get; }
        public Akka.Actor.Address DefaultAddress { get; }
        public Akka.Actor.Deployer Deployer { get; }
        public Akka.Event.EventStream EventStream { get; }
        public Akka.Actor.LocalActorRef Guardian { get; }
        public Akka.Event.ILoggingAdapter Log { get; }
        public Akka.Actor.IInternalActorRef RootGuardian { get; }
        public Akka.Actor.ActorPath RootPath { get; }
        public Akka.Serialization.Information SerializationInformation { get; }
        public Akka.Actor.Settings Settings { get; }
        public Akka.Actor.LocalActorRef SystemGuardian { get; }
        public Akka.Actor.IInternalActorRef TempContainer { get; }
        public System.Threading.Tasks.Task TerminationTask { get; }
        public Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async) { }
        public Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address) { }
        public void Init(Akka.Actor.Internal.ActorSystemImpl system) { }
        public void RegisterExtraName(string name, Akka.Actor.IInternalActorRef actor) { }
        public void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path) { }
        public Akka.Actor.IActorRef ResolveActorRef(string path) { }
        public Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath path) { }
        public Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address) { }
        public Akka.Actor.ActorPath TempPath() { }
        public void UnregisterTempActor(Akka.Actor.ActorPath path) { }
    }
    public class LocalOnlyDecider : Akka.Actor.IDecider
    {
        public LocalOnlyDecider(System.Func<System.Exception, Akka.Actor.Directive> decider) { }
        public Akka.Actor.Directive Decide(System.Exception cause) { }
    }
    public class LocalScope : Akka.Actor.Scope, Akka.Util.ISurrogated
    {
        public static Akka.Actor.LocalScope Instance { get; }
        public override Akka.Actor.Scope Copy() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }
        public class LocalScopeSurrogate : Akka.Util.ISurrogate
        {
            public LocalScopeSurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class LoggerInitializationException : Akka.Actor.AkkaException
    {
        public LoggerInitializationException() { }
        public LoggerInitializationException(string message) { }
        public LoggerInitializationException(string message, System.Exception cause = null) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class MinimalActorRef : Akka.Actor.InternalActorRefBase, Akka.Actor.IActorRefScope
    {
        protected MinimalActorRef() { }
        public override bool IsLocal { get; }
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
        public override bool IsTerminated { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class NameAndUid
    {
        public NameAndUid(string name, int uid) { }
        public string Name { get; }
        public int Uid { get; }
        public override string ToString() { }
    }
    public sealed class Nobody : Akka.Actor.MinimalActorRef
    {
        public static Akka.Actor.Nobody Instance;
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class NobodySurrogate : Akka.Util.ISurrogate
        {
            public NobodySurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class OneForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.OneForOneStrategy>
    {
        public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }
        public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }
        public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }
        public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }
        public OneForOneStrategy(Akka.Actor.IDecider decider) { }
        protected OneForOneStrategy() { }
        public override Akka.Actor.IDecider Decider { get; }
        public int MaxNumberOfRetries { get; }
        public int WithinTimeRangeMilliseconds { get; }
        public bool Equals(Akka.Actor.OneForOneStrategy other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception) { }
        public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }
        public override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.OneForOneStrategy WithMaxNrOfRetries(int maxNrOfRetries) { }
        public class OneForOneStrategySurrogate : Akka.Util.ISurrogate
        {
            public OneForOneStrategySurrogate() { }
            public Akka.Actor.IDecider Decider { get; set; }
            public bool LoggingEnabled { get; set; }
            public int MaxNumberOfRetries { get; set; }
            public int WithinTimeRangeMilliseconds { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class static PipeToSupport
    {
        public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }
        public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<object> success = null, System.Func<System.Exception, object> failure = null) { }
    }
    public sealed class PoisonPill : Akka.Actor.IAutoReceivedMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression
    {
        public static Akka.Actor.PoisonPill Instance { get; }
        public override string ToString() { }
    }
    public class PostRestartException : Akka.Actor.ActorInitializationException
    {
        public PostRestartException(Akka.Actor.IActorRef actor, System.Exception cause, System.Exception originalCause) { }
        public System.Exception OriginalCause { get; }
    }
    public class PreRestartException : Akka.Actor.AkkaException
    {
        public PreRestartException(Akka.Actor.IActorRef actor, System.Exception restartException, System.Exception cause, object optionalMessage) { }
    }
    public class Props : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Props>
    {
        public static readonly Akka.Actor.Props None;
        protected Props() { }
        protected Props(Akka.Actor.Props copy) { }
        public Props(System.Type type, object[] args) { }
        public Props(System.Type type) { }
        public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Collections.Generic.IEnumerable<object> args) { }
        public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, params object[] args) { }
        public Props(Akka.Actor.Deploy deploy, System.Type type, System.Collections.Generic.IEnumerable<object> args) { }
        public Props(Akka.Actor.Deploy deploy, System.Type type, params object[] args) { }
        public object[] Arguments { get; }
        public Akka.Actor.Deploy Deploy { get; set; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public string Dispatcher { get; }
        public static Akka.Actor.Props Empty { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public string Mailbox { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public Akka.Routing.RouterConfig RouterConfig { get; }
        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public System.Type Type { get; }
        public string TypeName { get; }
        protected virtual Akka.Actor.Props Copy() { }
        public static Akka.Actor.Props Create<TActor>(System.Linq.Expressions.Expression<System.Func<TActor>> factory, Akka.Actor.SupervisorStrategy supervisorStrategy = null)
            where TActor : Akka.Actor.ActorBase { }
        public static Akka.Actor.Props Create<TActor>(params object[] args)
            where TActor : Akka.Actor.ActorBase { }
        public static Akka.Actor.Props Create<TActor>(Akka.Actor.SupervisorStrategy supervisorStrategy)
            where TActor : Akka.Actor.ActorBase, new () { }
        public static Akka.Actor.Props Create(System.Type type, params object[] args) { }
        public static Akka.Actor.Props CreateBy<TProducer>(params object[] args)
            where TProducer :  class, Akka.Actor.IIndirectActorProducer { }
        public bool Equals(Akka.Actor.Props other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public virtual Akka.Actor.ActorBase NewActor() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Props WithDeploy(Akka.Actor.Deploy deploy) { }
        public Akka.Actor.Props WithDispatcher(string dispatcher) { }
        public Akka.Actor.Props WithMailbox(string mailbox) { }
        public Akka.Actor.Props WithRouter(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Actor.Props WithSupervisorStrategy(Akka.Actor.SupervisorStrategy supervisorStrategy) { }
        public class PropsSurrogate : Akka.Util.ISurrogate
        {
            public PropsSurrogate() { }
            public object[] Arguments { get; set; }
            public Akka.Actor.Deploy Deploy { get; set; }
            public System.Type Type { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public abstract class ProviderSelection
    {
        public sealed class Cluster : Akka.Actor.ProviderSelection
        {
            public static readonly Akka.Actor.ProviderSelection.Cluster Instance;
        }
        public sealed class Custom : Akka.Actor.ProviderSelection
        {
            public Custom(string fqn, string identifier = null, bool hasCluster = False) { }
        }
        public sealed class Local : Akka.Actor.ProviderSelection
        {
            public static readonly Akka.Actor.ProviderSelection.Local Instance;
        }
        public sealed class Remote : Akka.Actor.ProviderSelection
        {
            public static readonly Akka.Actor.ProviderSelection.Remote Instance;
        }
    }
    public delegate bool Receive(object message);
    public abstract class ReceiveActor : Akka.Actor.UntypedActor, Akka.Actor.Internal.IInitializableActor
    {
        protected ReceiveActor() { }
        protected void Become(System.Action configure) { }
        protected void BecomeStacked(System.Action configure) { }
        protected virtual void OnReceive(object message) { }
        protected void Receive<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }
        protected void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }
        protected void Receive(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }
        protected void Receive(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }
        protected void Receive<T>(System.Func<T, bool> handler) { }
        protected void Receive(System.Type messageType, System.Func<object, bool> handler) { }
        protected void ReceiveAny(System.Action<object> handler) { }
        protected void ReceiveAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }
        protected void ReceiveAsync<T>(System.Func<T, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }
        protected void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, System.Threading.Tasks.Task> handler) { }
        protected void ReceiveAsync(System.Type messageType, System.Func<object, System.Threading.Tasks.Task> handler, System.Predicate<object> shouldHandle = null) { }
        protected void ReceiveAsync(System.Type messageType, System.Predicate<object> shouldHandle, System.Func<object, System.Threading.Tasks.Task> handler) { }
    }
    public class ReceiveTimeout : Akka.Actor.IPossiblyHarmful
    {
        public static Akka.Actor.ReceiveTimeout Instance { get; }
    }
    public class static RelativeActorPath
    {
        public static System.Collections.Generic.IEnumerable<string> Unapply(string addr) { }
    }
    public class RemoteScope : Akka.Actor.Scope, System.IEquatable<Akka.Actor.RemoteScope>
    {
        protected RemoteScope() { }
        public RemoteScope(Akka.Actor.Address address) { }
        public Akka.Actor.Address Address { get; set; }
        public override Akka.Actor.Scope Copy() { }
        public bool Equals(Akka.Actor.RemoteScope other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }
    }
    public class RepointableActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope, Akka.Actor.IRepointableRef
    {
        protected readonly Akka.Dispatch.MessageDispatcher Dispatcher;
        protected readonly Akka.Actor.Props Props;
        protected readonly Akka.Actor.IInternalActorRef Supervisor;
        protected readonly Akka.Actor.Internal.ActorSystemImpl System;
        protected readonly Akka.Actor.ActorPath _path;
        public RepointableActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }
        public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }
        public override bool IsLocal { get; }
        public bool IsStarted { get; }
        public override bool IsTerminated { get; }
        public Akka.Actor.ICell Lookup { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Actor.ICell Underlying { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public Akka.Actor.RepointableActorRef Initialize(bool async) { }
        protected virtual Akka.Actor.ActorCell NewCell() { }
        public void Point() { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        public void SwapUnderlying(Akka.Actor.ICell cell) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class RootActorPath : Akka.Actor.ActorPath
    {
        public RootActorPath(Akka.Actor.Address address, string name = "") { }
        public override System.Collections.Generic.IReadOnlyList<string> Elements { get; }
        public override Akka.Actor.ActorPath Parent { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public override Akka.Actor.ActorPath Root { get; }
        public override int CompareTo(Akka.Actor.ActorPath other) { }
        public override Akka.Actor.ActorPath WithUid(long uid) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class RootGuardianActorRef : Akka.Actor.LocalActorRef
    {
        public RootGuardianActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef deadLetters, System.Collections.Generic.IReadOnlyDictionary<string, Akka.Actor.IInternalActorRef> extraNames) { }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public void SetTempContainer(Akka.Actor.IInternalActorRef tempContainer) { }
    }
    public class RootGuardianSupervisor : Akka.Actor.MinimalActorRef
    {
        public RootGuardianSupervisor(Akka.Actor.RootActorPath root, Akka.Actor.IActorRefProvider provider, System.Threading.Tasks.TaskCompletionSource<Akka.Actor.Status> terminationPromise, Akka.Event.ILoggingAdapter log) { }
        public System.Exception CauseOfTermination { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }
        public override void Stop() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public abstract class SchedulerBase : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider
    {
        protected readonly Akka.Event.ILoggingAdapter Log;
        protected readonly Akka.Configuration.Config SchedulerConfig;
        protected SchedulerBase(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }
        public abstract System.TimeSpan HighResMonotonicClock { get; }
        public abstract System.TimeSpan MonotonicClock { get; }
        protected abstract System.DateTimeOffset TimeNow { get; }
        protected abstract void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);
        protected abstract void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);
        protected abstract void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
        protected abstract void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
        protected static void ValidateDelay(System.TimeSpan delay, string parameterName) { }
        protected static void ValidateInterval(System.TimeSpan interval, string parameterName) { }
    }
    public sealed class SchedulerException : Akka.Actor.AkkaException
    {
        public SchedulerException(string message) { }
    }
    public class static SchedulerExtensions
    {
        public static void ScheduleOnce(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan delay, System.Action action) { }
        public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action) { }
        public static void ScheduleRepeatedly(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }
        public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action) { }
        public static void ScheduleTellOnce(this Akka.Actor.ITellScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
        public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
        public static void ScheduleTellRepeatedly(this Akka.Actor.ITellScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
        public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
    }
    public abstract class Scope : System.IEquatable<Akka.Actor.Scope>
    {
        public static readonly Akka.Actor.LocalScope Local;
        protected Scope() { }
        public abstract Akka.Actor.Scope Copy();
        public virtual bool Equals(Akka.Actor.Scope other) { }
        public abstract Akka.Actor.Scope WithFallback(Akka.Actor.Scope other);
    }
    public class SelectChildName : Akka.Actor.SelectionPathElement
    {
        public SelectChildName(string name) { }
        public string Name { get; }
        protected bool Equals(Akka.Actor.SelectChildName other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class SelectChildPattern : Akka.Actor.SelectionPathElement
    {
        public SelectChildPattern(string patternStr) { }
        public string PatternStr { get; }
        protected bool Equals(Akka.Actor.SelectChildPattern other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class SelectParent : Akka.Actor.SelectionPathElement
    {
        public SelectParent() { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public abstract class SelectionPathElement
    {
        protected SelectionPathElement() { }
    }
    public class Settings
    {
        public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config) { }
        public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup) { }
        public bool AddLoggingReceive { get; }
        public System.TimeSpan AskTimeout { get; }
        public Akka.Configuration.Config Config { get; }
        public string ConfigVersion { get; }
        public bool CoordinatedShutdownRunByActorSystemTerminate { get; }
        public bool CoordinatedShutdownTerminateActorSystem { get; }
        public System.TimeSpan CreationTimeout { get; }
        public bool DebugAutoReceive { get; }
        public bool DebugEventStream { get; }
        public bool DebugLifecycle { get; }
        public bool DebugRouterMisconfiguration { get; }
        public bool DebugUnhandledMessage { get; }
        public int DefaultVirtualNodesFactor { get; }
        public bool FsmDebugEvent { get; }
        public bool HasCluster { get; }
        public string Home { get; }
        public bool LogConfigOnStart { get; }
        public int LogDeadLetters { get; }
        public bool LogDeadLettersDuringShutdown { get; }
        public System.TimeSpan LogDeadLettersSuspendDuration { get; }
        public string LogLevel { get; }
        public bool LoggerAsyncStart { get; }
        public System.TimeSpan LoggerStartTimeout { get; }
        public System.Collections.Generic.IList<string> Loggers { get; }
        public string LoggersDispatcher { get; }
        public string ProviderClass { get; }
        public Akka.Actor.ProviderSelection ProviderSelectionType { get; }
        public string SchedulerClass { get; }
        public System.TimeSpan SchedulerShutdownTimeout { get; }
        public bool SerializeAllCreators { get; }
        public bool SerializeAllMessages { get; }
        public Akka.Actor.Setup.ActorSystemSetup Setup { get; }
        public string StdoutLogLevel { get; }
        public string SupervisorStrategyClass { get; }
        public Akka.Actor.ActorSystem System { get; }
        public System.TimeSpan UnstartedPushTimeout { get; }
        public void InjectTopLevelFallback(Akka.Configuration.Config config) { }
        public override string ToString() { }
    }
    public class static StashFactory
    {
        public static Akka.Actor.IStash CreateStash<T>(this Akka.Actor.IActorContext context)
            where T : Akka.Actor.ActorBase { }
        public static Akka.Actor.IStash CreateStash(this Akka.Actor.IActorContext context, Akka.Actor.IActorStash actorInstance) { }
        public static Akka.Actor.IStash CreateStash(this Akka.Actor.IActorContext context, System.Type actorType) { }
    }
    public class StashOverflowException : Akka.Actor.AkkaException
    {
        public StashOverflowException(string message, System.Exception cause = null) { }
    }
    public abstract class Status
    {
        protected Status() { }
        public class Failure : Akka.Actor.Status
        {
            public readonly System.Exception Cause;
            public Failure(System.Exception cause) { }
            public override string ToString() { }
        }
        public class Success : Akka.Actor.Status
        {
            public readonly object Status;
            public Success(object status) { }
        }
    }
    public class StoppingSupervisorStrategy : Akka.Actor.SupervisorStrategyConfigurator
    {
        public StoppingSupervisorStrategy() { }
        public override Akka.Actor.SupervisorStrategy Create() { }
    }
    public abstract class SupervisorStrategy : Akka.Util.ISurrogated
    {
        public static Akka.Actor.IDecider DefaultDecider;
        public static readonly Akka.Actor.SupervisorStrategy DefaultStrategy;
        public static readonly Akka.Actor.OneForOneStrategy StoppingStrategy;
        protected SupervisorStrategy() { }
        public abstract Akka.Actor.IDecider Decider { get; }
        protected bool LoggingEnabled { get; set; }
        protected abstract Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception exception);
        public abstract void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children);
        public bool HandleFailure(Akka.Actor.ActorCell actorCell, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }
        protected virtual void LogFailure(Akka.Actor.IActorContext context, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Directive directive) { }
        public abstract void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children);
        protected void RestartChild(Akka.Actor.IActorRef child, System.Exception cause, bool suspendFirst) { }
        protected void ResumeChild(Akka.Actor.IActorRef child, System.Exception exception) { }
        public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);
    }
    public abstract class SupervisorStrategyConfigurator
    {
        protected SupervisorStrategyConfigurator() { }
        public abstract Akka.Actor.SupervisorStrategy Create();
        public static Akka.Actor.SupervisorStrategyConfigurator CreateConfigurator(string typeName) { }
    }
    public class SystemGuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        public SystemGuardianActor(Akka.Actor.IActorRef userGuardian) { }
        protected override void PreRestart(System.Exception reason, object message) { }
        protected override bool Receive(object message) { }
    }
    public sealed class Terminated : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression, System.IEquatable<Akka.Actor.Terminated>
    {
        public Terminated(Akka.Actor.IActorRef actorRef, bool existenceConfirmed, bool addressTerminated) { }
        public Akka.Actor.IActorRef ActorRef { get; }
        public bool AddressTerminated { get; }
        public bool ExistenceConfirmed { get; }
        public bool Equals(Akka.Actor.Terminated other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class TerminatedProps : Akka.Actor.Props
    {
        public TerminatedProps() { }
        public override Akka.Actor.ActorBase NewActor() { }
    }
    [System.ObsoleteAttribute("TypedActor in its current shape will be removed in v1.5")]
    public abstract class TypedActor : Akka.Actor.ActorBase
    {
        protected TypedActor() { }
        protected virtual bool Receive(object message) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class UnstartedCell : Akka.Actor.ICell
    {
        public UnstartedCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.RepointableActorRef self, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor) { }
        public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }
        public bool HasMessages { get; }
        public bool IsLocal { get; }
        public bool IsTerminated { get; }
        public int NumberOfMessages { get; }
        public Akka.Actor.IInternalActorRef Parent { get; }
        public Akka.Actor.Props Props { get; }
        public Akka.Actor.IActorRef Self { get; }
        public Akka.Actor.ActorSystem System { get; }
        public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }
        public Akka.Actor.IInternalActorRef GetChildByName(string name) { }
        public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }
        public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public void ReplaceWith(Akka.Actor.ICell cell) { }
        public void Restart(System.Exception cause) { }
        public void Resume(System.Exception causedByFailure) { }
        public void SendMessage(Akka.Actor.IActorRef sender, object message) { }
        public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public void Start() { }
        public void Stop() { }
        public void Suspend() { }
        public bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child) { }
    }
    public abstract class UntypedActor : Akka.Actor.ActorBase
    {
        protected UntypedActor() { }
        protected static Akka.Actor.IUntypedActorContext Context { get; }
        protected void Become(Akka.Actor.UntypedReceive receive) { }
        protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }
        protected abstract void OnReceive(object message);
        protected virtual bool Receive(object message) { }
        protected void RunTask(System.Action action) { }
        protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }
    }
    public delegate void UntypedReceive(object message);
}
namespace Akka.Actor.Dsl
{
    public sealed class Act : Akka.Actor.ReceiveActor, Akka.Actor.Dsl.IActorDsl
    {
        public Act(System.Action<Akka.Actor.Dsl.IActorDsl> config) { }
        public Act(System.Action<Akka.Actor.Dsl.IActorDsl, Akka.Actor.IActorContext> config) { }
        public System.Action<System.Exception, Akka.Actor.IActorContext> OnPostRestart { get; set; }
        public System.Action<Akka.Actor.IActorContext> OnPostStop { get; set; }
        public System.Action<System.Exception, object, Akka.Actor.IActorContext> OnPreRestart { get; set; }
        public System.Action<Akka.Actor.IActorContext> OnPreStart { get; set; }
        public Akka.Actor.SupervisorStrategy Strategy { get; set; }
        public Akka.Actor.IActorRef ActorOf(System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null) { }
        public void Become(System.Action<object, Akka.Actor.IActorContext> handler) { }
        public void BecomeStacked(System.Action<object, Akka.Actor.IActorContext> handler) { }
        public void DefaultPostRestart(System.Exception reason) { }
        public void DefaultPostStop() { }
        public void DefaultPreRestart(System.Exception reason, object message) { }
        public void DefaultPreStart() { }
        protected override void PostRestart(System.Exception reason) { }
        protected override void PostStop() { }
        protected override void PreRestart(System.Exception reason, object message) { }
        protected override void PreStart() { }
        public void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler) { }
        public void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle) { }
        public void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler) { }
        public void ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler) { }
        public void ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler) { }
        public void ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }
        public void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler) { }
        protected override Akka.Actor.SupervisorStrategy SupervisorStrategy() { }
    }
    public class static ActExtensions
    {
        public static Akka.Actor.IActorRef ActorOf(this Akka.Actor.IActorRefFactory factory, System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null) { }
        public static Akka.Actor.IActorRef ActorOf(this Akka.Actor.IActorRefFactory factory, System.Action<Akka.Actor.Dsl.IActorDsl, Akka.Actor.IActorContext> config, string name = null) { }
    }
    public interface IActorDsl
    {
        System.Action<System.Exception, Akka.Actor.IActorContext> OnPostRestart { get; set; }
        System.Action<Akka.Actor.IActorContext> OnPostStop { get; set; }
        System.Action<System.Exception, object, Akka.Actor.IActorContext> OnPreRestart { get; set; }
        System.Action<Akka.Actor.IActorContext> OnPreStart { get; set; }
        Akka.Actor.SupervisorStrategy Strategy { get; set; }
        Akka.Actor.IActorRef ActorOf(System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null);
        void Become(System.Action<object, Akka.Actor.IActorContext> handler);
        void BecomeStacked(System.Action<object, Akka.Actor.IActorContext> handler);
        void DefaultPostRestart(System.Exception reason);
        void DefaultPostStop();
        void DefaultPreRestart(System.Exception reason, object message);
        void DefaultPreStart();
        void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler);
        void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler);
        void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle);
        void ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler);
        void ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);
        void ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null);
        void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);
        void UnbecomeStacked();
    }
}
namespace Akka.Actor.Internal
{
    public abstract class AbstractStash : Akka.Actor.IStash
    {
        protected AbstractStash(Akka.Actor.IActorContext context, int capacity = 100) { }
        public System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> ClearStash() { }
        public void Prepend(System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> envelopes) { }
        public void Stash() { }
        public void Unstash() { }
        public void UnstashAll() { }
        public void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate) { }
    }
    public class ActorSystemImpl : Akka.Actor.ExtendedActorSystem
    {
        public ActorSystemImpl(string name) { }
        public ActorSystemImpl(string name, Akka.Configuration.Config config, Akka.Actor.Setup.ActorSystemSetup setup) { }
        public override Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }
        public override Akka.Actor.IActorRef DeadLetters { get; }
        public override Akka.Dispatch.Dispatchers Dispatchers { get; }
        public override Akka.Event.EventStream EventStream { get; }
        public override Akka.Actor.IInternalActorRef Guardian { get; }
        public override Akka.Event.ILoggingAdapter Log { get; }
        public override Akka.Actor.IInternalActorRef LookupRoot { get; }
        public override Akka.Dispatch.Mailboxes Mailboxes { get; }
        public override string Name { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Actor.IScheduler Scheduler { get; }
        public override Akka.Serialization.Serialization Serialization { get; }
        public override Akka.Actor.Settings Settings { get; }
        public override Akka.Actor.IInternalActorRef SystemGuardian { get; }
        public override System.Threading.Tasks.Task WhenTerminated { get; }
        public override void Abort() { }
        public override Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }
        public override Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath) { }
        public override Akka.Actor.ActorSelection ActorSelection(string actorPath) { }
        public override object GetExtension(Akka.Actor.IExtensionId extensionId) { }
        public override T GetExtension<T>()
            where T :  class, Akka.Actor.IExtension { }
        public override bool HasExtension(System.Type type) { }
        public override bool HasExtension<T>()
            where T :  class, Akka.Actor.IExtension { }
        public override object RegisterExtension(Akka.Actor.IExtensionId extension) { }
        public override void RegisterOnTermination(System.Action code) { }
        public void Start() { }
        public override void Stop(Akka.Actor.IActorRef actor) { }
        public override Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null) { }
        public override Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)
            where TActor : Akka.Actor.ActorBase, new () { }
        public override System.Threading.Tasks.Task Terminate() { }
        public override string ToString() { }
        public override bool TryGetExtension(System.Type extensionType, out object extension) { }
        public override bool TryGetExtension<T>(out T extension)
            where T :  class, Akka.Actor.IExtension { }
    }
    public class BoundedStashImpl : Akka.Actor.Internal.AbstractStash
    {
        public BoundedStashImpl(Akka.Actor.IActorContext context, int capacity = 100) { }
    }
    public class ChildNameReserved : Akka.Actor.Internal.IChildStats
    {
        public static Akka.Actor.Internal.ChildNameReserved Instance { get; }
        public override string ToString() { }
    }
    public class ChildRestartStats : Akka.Actor.Internal.IChildStats
    {
        public ChildRestartStats(Akka.Actor.IInternalActorRef child, uint maxNrOfRetriesCount = 0, long restartTimeWindowStartTicks = 0) { }
        public Akka.Actor.IInternalActorRef Child { get; }
        public uint MaxNrOfRetriesCount { get; }
        public long RestartTimeWindowStartTicks { get; }
        public long Uid { get; }
        public bool RequestRestartPermission(int maxNrOfRetries, int withinTimeMilliseconds) { }
    }
    public abstract class ChildrenContainerBase : Akka.Actor.Internal.IChildrenContainer
    {
        protected ChildrenContainerBase(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }
        protected System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> InternalChildren { get; }
        public virtual bool IsNormal { get; }
        public virtual bool IsTerminating { get; }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }
        public abstract Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);
        protected void ChildStatsAppender(System.Text.StringBuilder sb, System.Collections.Generic.KeyValuePair<string, Akka.Actor.Internal.IChildStats> kvp, int index) { }
        public bool Contains(Akka.Actor.IActorRef actor) { }
        public abstract Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);
        public abstract Akka.Actor.Internal.IChildrenContainer Reserve(string name);
        public abstract Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);
        public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }
        public bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }
        public abstract Akka.Actor.Internal.IChildrenContainer Unreserve(string name);
    }
    public class EmptyChildrenContainer : Akka.Actor.Internal.IChildrenContainer
    {
        protected EmptyChildrenContainer() { }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }
        public static Akka.Actor.Internal.IChildrenContainer Instance { get; }
        public virtual bool IsNormal { get; }
        public virtual bool IsTerminating { get; }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }
        public virtual Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public bool Contains(Akka.Actor.IActorRef actor) { }
        public Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }
        public virtual Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }
        public override string ToString() { }
        public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }
        public bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }
        public Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }
    }
    public interface IChildStats { }
    public interface IChildrenContainer
    {
        System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }
        bool IsNormal { get; }
        bool IsTerminating { get; }
        System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }
        Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);
        bool Contains(Akka.Actor.IActorRef actor);
        Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);
        Akka.Actor.Internal.IChildrenContainer Reserve(string name);
        Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);
        bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats);
        bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats stats);
        Akka.Actor.Internal.IChildrenContainer Unreserve(string name);
    }
    public interface IInitializableActor
    {
        void Init();
    }
    [Akka.Annotations.InternalApiAttribute()]
    public interface IInternalSupportsTestFSMRef<TState, TData>
    {
        bool IsStateTimerActive { get; }
        void ApplyState(Akka.Actor.FSMBase.State<TState, TData> upcomingState);
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class InternalActivateFsmLogging
    {
        public static Akka.Actor.Internal.InternalActivateFsmLogging Instance { get; }
    }
    public class static InternalCurrentActorCellKeeper
    {
        public static Akka.Actor.ActorCell Current { get; set; }
    }
    public class NormalChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase
    {
        public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public static Akka.Actor.Internal.IChildrenContainer Create(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }
        public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }
        public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }
        public override string ToString() { }
        public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }
    }
    public abstract class SuspendReason
    {
        protected SuspendReason() { }
        public class Creation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren
        {
            public Creation() { }
        }
        public interface IWaitingForChildren { }
        public class Recreation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren
        {
            public Recreation(System.Exception cause) { }
            public System.Exception Cause { get; }
        }
        public class Termination : Akka.Actor.Internal.SuspendReason
        {
            public static Akka.Actor.Internal.SuspendReason.Termination Instance { get; }
        }
        public class UserRequest : Akka.Actor.Internal.SuspendReason
        {
            public static Akka.Actor.Internal.SuspendReason.UserRequest Instance { get; }
        }
    }
    public class TerminatedChildrenContainer : Akka.Actor.Internal.EmptyChildrenContainer
    {
        public new static Akka.Actor.Internal.IChildrenContainer Instance { get; }
        public override bool IsNormal { get; }
        public override bool IsTerminating { get; }
        public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public override string ToString() { }
    }
    public class TerminatingChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase
    {
        public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, Akka.Actor.IActorRef toDie, Akka.Actor.Internal.SuspendReason reason) { }
        public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.IActorRef> toDie, Akka.Actor.Internal.SuspendReason reason) { }
        public override bool IsNormal { get; }
        public override bool IsTerminating { get; }
        public Akka.Actor.Internal.SuspendReason Reason { get; }
        public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public Akka.Actor.Internal.IChildrenContainer CreateCopyWithReason(Akka.Actor.Internal.SuspendReason reason) { }
        public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }
        public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }
        public override string ToString() { }
        public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }
    }
    public class UnboundedStashImpl : Akka.Actor.Internal.AbstractStash
    {
        public UnboundedStashImpl(Akka.Actor.IActorContext context) { }
    }
}
namespace Akka.Actor.Setup
{
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ActorSystemSetup
    {
        public static readonly Akka.Actor.Setup.ActorSystemSetup Empty;
        public Akka.Actor.Setup.ActorSystemSetup And<T>(T setup)
            where T : Akka.Actor.Setup.Setup { }
        public static Akka.Actor.Setup.ActorSystemSetup Create(params Akka.Actor.Setup.Setup[] setup) { }
        public Akka.Util.Option<T> Get<T>()
            where T : Akka.Actor.Setup.Setup { }
        public override string ToString() { }
        public Akka.Actor.Setup.ActorSystemSetup WithSetup<T>(T setup)
            where T : Akka.Actor.Setup.Setup { }
    }
    public abstract class Setup
    {
        protected Setup() { }
        public Akka.Actor.Setup.ActorSystemSetup And(Akka.Actor.Setup.Setup other) { }
    }
}
namespace Akka.Annotations
{
    [System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.All, AllowMultiple=false, Inherited=true)]
    public sealed class ApiMayChangeAttribute : System.Attribute
    {
        public ApiMayChangeAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Module | System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.All, AllowMultiple=false, Inherited=true)]
    public sealed class InternalApiAttribute : System.Attribute
    {
        public InternalApiAttribute() { }
    }
}
namespace Akka
{
    public class Case : Akka.IMatchResult
    {
        public Case(object message) { }
        public bool WasHandled { get; }
        public Akka.IMatchResult Default(System.Action<object> action) { }
        public Akka.Case With<TMessage>(System.Action action) { }
        public Akka.Case With<TMessage>(System.Action<TMessage> action) { }
    }
    public class Case<T> : Akka.IMatchResult
    {
        public Case(object message) { }
        public bool WasHandled { get; }
        public T ResultOrDefault(System.Func<object, T> function) { }
        public Akka.Case<T> With<TMessage>(System.Func<T> function) { }
        public Akka.Case<T> With<TMessage>(System.Func<TMessage, T> function) { }
    }
    public sealed class Done
    {
        public static readonly Akka.Done Instance;
    }
    public interface IMatchResult
    {
        bool WasHandled { get; }
    }
    public sealed class NotUsed : System.IComparable<Akka.NotUsed>, System.IEquatable<Akka.NotUsed>
    {
        public static readonly Akka.NotUsed Instance;
        public int CompareTo(Akka.NotUsed other) { }
        public override bool Equals(object obj) { }
        public bool Equals(Akka.NotUsed other) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class static PatternMatch
    {
        public static Akka.Case Match(this object target) { }
        public static Akka.Case<T> Match<T>(this object target) { }
    }
}
namespace Akka.Configuration
{
    public class Config
    {
        public static readonly Akka.Configuration.Config Empty;
        public Config() { }
        public Config(Akka.Configuration.Hocon.HoconRoot root) { }
        public Config(Akka.Configuration.Config source, Akka.Configuration.Config fallback) { }
        public Akka.Configuration.Config Fallback { get; }
        public virtual bool IsEmpty { get; }
        public Akka.Configuration.Hocon.HoconValue Root { get; }
        public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; set; }
        public virtual System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Akka.Configuration.Hocon.HoconValue>> AsEnumerable() { }
        protected Akka.Configuration.Config Copy(Akka.Configuration.Config fallback = null) { }
        public virtual bool GetBoolean(string path, bool default = False) { }
        public virtual System.Collections.Generic.IList<bool> GetBooleanList(string path) { }
        public virtual System.Collections.Generic.IList<byte> GetByteList(string path) { }
        public virtual System.Nullable<long> GetByteSize(string path) { }
        public virtual System.Nullable<long> GetByteSize(string path, System.Nullable<long> def = null) { }
        public virtual Akka.Configuration.Config GetConfig(string path) { }
        public virtual decimal GetDecimal(string path, [System.Runtime.CompilerServices.DecimalConstantAttribute(0, 0, 0u, 0u, 0u)] decimal @default) { }
        public virtual System.Collections.Generic.IList<decimal> GetDecimalList(string path) { }
        public virtual double GetDouble(string path, double default = 0) { }
        public virtual System.Collections.Generic.IList<double> GetDoubleList(string path) { }
        public virtual float GetFloat(string path, float default = 0) { }
        public virtual System.Collections.Generic.IList<float> GetFloatList(string path) { }
        public virtual int GetInt(string path, int default = 0) { }
        public virtual System.Collections.Generic.IList<int> GetIntList(string path) { }
        public virtual long GetLong(string path, long default = 0) { }
        public virtual System.Collections.Generic.IList<long> GetLongList(string path) { }
        public virtual string GetString(string path, string default = null) { }
        public virtual System.Collections.Generic.IList<string> GetStringList(string path) { }
        public virtual System.Collections.Generic.IList<string> GetStringList(string path, string[] defaultPaths) { }
        public virtual System.TimeSpan GetTimeSpan(string path, System.Nullable<System.TimeSpan> default = null, bool allowInfinite = True) { }
        public Akka.Configuration.Hocon.HoconValue GetValue(string path) { }
        public virtual bool HasPath(string path) { }
        public override string ToString() { }
        public string ToString(bool includeFallback) { }
        public virtual Akka.Configuration.Config WithFallback(Akka.Configuration.Config fallback) { }
        public static Akka.Configuration.Config +(Akka.Configuration.Config config, string fallback) { }
        public static Akka.Configuration.Config +(string configHocon, Akka.Configuration.Config fallbackConfig) { }
        public static Akka.Configuration.Config op_Implicit(string str) { }
    }
    public class static ConfigExtensions
    {
        public static bool IsNullOrEmpty(this Akka.Configuration.Config config) { }
        public static Akka.Configuration.Config SafeWithFallback(this Akka.Configuration.Config config, Akka.Configuration.Config fallback) { }
    }
    public class ConfigurationException : Akka.Actor.AkkaException
    {
        public ConfigurationException(string message) { }
        public ConfigurationException(string message, System.Exception exception) { }
        public static Akka.Configuration.ConfigurationException NullOrEmptyConfig<T>(string path = null) { }
    }
    public class ConfigurationFactory
    {
        public ConfigurationFactory() { }
        public static Akka.Configuration.Config Empty { get; }
        public static Akka.Configuration.Config Default() { }
        public static Akka.Configuration.Config FromObject(object source) { }
        public static Akka.Configuration.Config FromResource(string resourceName, object instanceInAssembly) { }
        public static Akka.Configuration.Config FromResource<TAssembly>(string resourceName) { }
        public static Akka.Configuration.Config FromResource(string resourceName, System.Reflection.Assembly assembly) { }
        public static Akka.Configuration.Config Load() { }
        public static Akka.Configuration.Config ParseString(string hocon, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }
        public static Akka.Configuration.Config ParseString(string hocon) { }
    }
}
namespace Akka.Configuration.Hocon
{
    public class AkkaConfigurationSection : System.Configuration.ConfigurationSection
    {
        public AkkaConfigurationSection() { }
        public Akka.Configuration.Config AkkaConfig { get; }
        [System.Configuration.ConfigurationPropertyAttribute("hocon", IsRequired=true)]
        public Akka.Configuration.Hocon.HoconConfigurationElement Hocon { get; set; }
    }
    public abstract class CDataConfigurationElement : System.Configuration.ConfigurationElement
    {
        protected const string ContentPropertyName = "content";
        protected CDataConfigurationElement() { }
        protected override void DeserializeElement(System.Xml.XmlReader reader, bool serializeCollectionKey) { }
    }
    public class HoconArray : System.Collections.Generic.List<Akka.Configuration.Hocon.HoconValue>, Akka.Configuration.Hocon.IHoconElement
    {
        public HoconArray() { }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsString() { }
        public override string ToString() { }
    }
    public class HoconConfigurationElement : Akka.Configuration.Hocon.CDataConfigurationElement
    {
        public HoconConfigurationElement() { }
        [System.Configuration.ConfigurationPropertyAttribute("content", IsKey=true, IsRequired=true)]
        public string Content { get; set; }
    }
    public class HoconLiteral : Akka.Configuration.Hocon.IHoconElement
    {
        public HoconLiteral() { }
        public string Value { get; set; }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsString() { }
        public override string ToString() { }
    }
    public class HoconObject : Akka.Configuration.Hocon.IHoconElement
    {
        public HoconObject() { }
        public System.Collections.Generic.Dictionary<string, Akka.Configuration.Hocon.HoconValue> Items { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public System.Collections.Generic.IDictionary<string, object> Unwrapped { get; }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public Akka.Configuration.Hocon.HoconValue GetKey(string key) { }
        public Akka.Configuration.Hocon.HoconValue GetOrCreateKey(string key) { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsString() { }
        public void Merge(Akka.Configuration.Hocon.HoconObject other) { }
        public override string ToString() { }
        public string ToString(int indent) { }
    }
    public class HoconRoot
    {
        protected HoconRoot() { }
        public HoconRoot(Akka.Configuration.Hocon.HoconValue value, System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> substitutions) { }
        public HoconRoot(Akka.Configuration.Hocon.HoconValue value) { }
        public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; }
        public Akka.Configuration.Hocon.HoconValue Value { get; }
    }
    public class HoconSubstitution : Akka.Configuration.Hocon.IHoconElement, Akka.Configuration.Hocon.IMightBeAHoconObject
    {
        protected HoconSubstitution() { }
        public HoconSubstitution(string path) { }
        public string Path { get; set; }
        public Akka.Configuration.Hocon.HoconValue ResolvedValue { get; set; }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public Akka.Configuration.Hocon.HoconObject GetObject() { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsObject() { }
        public bool IsString() { }
    }
    public class HoconTokenizer : Akka.Configuration.Hocon.Tokenizer
    {
        public HoconTokenizer(string text) { }
        public bool IsArrayEnd() { }
        public bool IsArrayStart() { }
        public bool IsAssignment() { }
        public bool IsComma() { }
        public bool IsDot() { }
        public bool IsEndOfObject() { }
        public bool IsInclude() { }
        public bool IsObjectStart() { }
        public bool IsSpaceOrTab() { }
        public bool IsStartOfComment() { }
        public bool IsStartOfQuotedText() { }
        public bool IsStartOfTripleQuotedText() { }
        public bool IsStartSimpleValue() { }
        public bool IsSubstitutionStart() { }
        public bool IsUnquotedKey() { }
        public bool IsUnquotedKeyStart() { }
        public bool IsWhitespace() { }
        public bool IsWhitespaceOrComment() { }
        public Akka.Configuration.Hocon.Token PullArrayEnd() { }
        public Akka.Configuration.Hocon.Token PullArrayStart() { }
        public Akka.Configuration.Hocon.Token PullAssignment() { }
        public Akka.Configuration.Hocon.Token PullComma() { }
        public Akka.Configuration.Hocon.Token PullComment() { }
        public Akka.Configuration.Hocon.Token PullDot() { }
        public Akka.Configuration.Hocon.Token PullEndOfObject() { }
        public Akka.Configuration.Hocon.Token PullInclude() { }
        public Akka.Configuration.Hocon.Token PullNext() { }
        public Akka.Configuration.Hocon.Token PullQuotedKey() { }
        public Akka.Configuration.Hocon.Token PullQuotedText() { }
        public string PullRestOfLine() { }
        public Akka.Configuration.Hocon.Token PullSimpleValue() { }
        public Akka.Configuration.Hocon.Token PullSpaceOrTab() { }
        public Akka.Configuration.Hocon.Token PullStartOfObject() { }
        public Akka.Configuration.Hocon.Token PullSubstitution() { }
        public Akka.Configuration.Hocon.Token PullTripleQuotedText() { }
        public Akka.Configuration.Hocon.Token PullUnquotedKey() { }
        public Akka.Configuration.Hocon.Token PullValue() { }
        public void PullWhitespaceAndComments() { }
    }
    public class HoconValue : Akka.Configuration.Hocon.IMightBeAHoconObject
    {
        public HoconValue() { }
        public HoconValue(System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> values, bool adoptedFromFallback = True) { }
        public bool IsEmpty { get; }
        public System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> Values { get; }
        public void AppendValue(Akka.Configuration.Hocon.IHoconElement value) { }
        public Akka.Configuration.Config AtKey(string key) { }
        public void Clear() { }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public bool GetBoolean() { }
        public System.Collections.Generic.IList<bool> GetBooleanList() { }
        public byte GetByte() { }
        public System.Collections.Generic.IList<byte> GetByteList() { }
        public System.Nullable<long> GetByteSize() { }
        public Akka.Configuration.Hocon.HoconValue GetChildObject(string key) { }
        public decimal GetDecimal() { }
        public System.Collections.Generic.IList<decimal> GetDecimalList() { }
        public double GetDouble() { }
        public System.Collections.Generic.IList<double> GetDoubleList() { }
        public float GetFloat() { }
        public System.Collections.Generic.IList<float> GetFloatList() { }
        public int GetInt() { }
        public System.Collections.Generic.IList<int> GetIntList() { }
        public long GetLong() { }
        public System.Collections.Generic.IList<long> GetLongList() { }
        public Akka.Configuration.Hocon.HoconObject GetObject() { }
        public string GetString() { }
        public System.Collections.Generic.IList<string> GetStringList() { }
        public System.TimeSpan GetTimeSpan(bool allowInfinite = True) { }
        public bool IsArray() { }
        public bool IsObject() { }
        public bool IsString() { }
        public void NewValue(Akka.Configuration.Hocon.IHoconElement value) { }
        public override string ToString() { }
        public virtual string ToString(int indent) { }
    }
    public interface IHoconElement
    {
        System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray();
        string GetString();
        bool IsArray();
        bool IsString();
    }
    public interface IMightBeAHoconObject
    {
        Akka.Configuration.Hocon.HoconObject GetObject();
        bool IsObject();
    }
    public class Parser
    {
        public Parser() { }
        public static Akka.Configuration.Hocon.HoconRoot Parse(string text, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }
        public Akka.Configuration.Hocon.HoconArray ParseArray(string currentPath) { }
        public void ParseValue(Akka.Configuration.Hocon.HoconValue owner, string currentPath) { }
    }
    public class Token
    {
        protected Token() { }
        public Token(Akka.Configuration.Hocon.TokenType type) { }
        public Token(string value) { }
        public Akka.Configuration.Hocon.TokenType Type { get; set; }
        public string Value { get; set; }
        public static Akka.Configuration.Hocon.Token Key(string key) { }
        public static Akka.Configuration.Hocon.Token LiteralValue(string value) { }
        public static Akka.Configuration.Hocon.Token Substitution(string path) { }
    }
    public enum TokenType
    {
        Comment = 0,
        Key = 1,
        LiteralValue = 2,
        Assign = 3,
        ObjectStart = 4,
        ObjectEnd = 5,
        Dot = 6,
        EoF = 7,
        ArrayStart = 8,
        ArrayEnd = 9,
        Comma = 10,
        Substitute = 11,
        Include = 12,
    }
    public class Tokenizer
    {
        public Tokenizer(string text) { }
        public bool EoF { get; }
        public bool Matches(string pattern) { }
        public bool Matches(params string[] patterns) { }
        public char Peek() { }
        protected string PickErrorLine(out int index) { }
        public void Pop() { }
        public void PullWhitespace() { }
        public void Push() { }
        public string Take(int length) { }
        public char Take() { }
    }
}
namespace Akka.Dispatch
{
    public sealed class ActionRunnable : Akka.Dispatch.IRunnable
    {
        public ActionRunnable(System.Action action) { }
        public void Run() { }
    }
    public sealed class ActionWithStateRunnable : Akka.Dispatch.IRunnable
    {
        public ActionWithStateRunnable(System.Action<object> actionWithState, object state) { }
        public void Run() { }
    }
    public class ActorTaskScheduler : System.Threading.Tasks.TaskScheduler
    {
        public object CurrentMessage { get; }
        public override int MaximumConcurrencyLevel { get; }
        protected override System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks() { }
        protected override void QueueTask(System.Threading.Tasks.Task task) { }
        public static void RunTask(System.Action action) { }
        public static void RunTask(System.Func<System.Threading.Tasks.Task> asyncAction) { }
        protected override bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) { }
    }
    public sealed class BoundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue>
    {
        public BoundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int Capacity { get; }
        public System.TimeSpan PushTimeout { get; }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public sealed class BoundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedMessageQueue>
    {
        public BoundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int Capacity { get; }
        public System.TimeSpan PushTimeout { get; }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public sealed class CurrentSynchronizationContextDispatcher : Akka.Dispatch.Dispatcher
    {
        public CurrentSynchronizationContextDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }
    }
    public sealed class DefaultDispatcherPrerequisites : Akka.Dispatch.IDispatcherPrerequisites
    {
        public DefaultDispatcherPrerequisites(Akka.Event.EventStream eventStream, Akka.Actor.IScheduler scheduler, Akka.Actor.Settings settings, Akka.Dispatch.Mailboxes mailboxes) { }
        public Akka.Event.EventStream EventStream { get; }
        public Akka.Dispatch.Mailboxes Mailboxes { get; }
        public Akka.Actor.IScheduler Scheduler { get; }
        public Akka.Actor.Settings Settings { get; }
    }
    public class Dispatcher : Akka.Dispatch.MessageDispatcher
    {
        public Dispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }
        protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }
        [Akka.Annotations.InternalApiAttribute()]
        protected override void Shutdown() { }
    }
    public sealed class DispatcherConfigurator : Akka.Dispatch.MessageDispatcherConfigurator
    {
        public DispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public override Akka.Dispatch.MessageDispatcher Dispatcher() { }
    }
    public sealed class Dispatchers
    {
        public static readonly string DefaultDispatcherId;
        public static readonly string SynchronizedDispatcherId;
        public Dispatchers(Akka.Actor.ActorSystem system, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public Akka.Configuration.Config DefaultDispatcherConfig { get; }
        public Akka.Dispatch.MessageDispatcher DefaultGlobalDispatcher { get; }
        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }
        public bool HasDispatcher(string id) { }
        public Akka.Dispatch.MessageDispatcher Lookup(string dispatcherName) { }
        public bool RegisterConfigurator(string id, Akka.Dispatch.MessageDispatcherConfigurator configurator) { }
    }
    public abstract class ExecutorService
    {
        protected ExecutorService(string id) { }
        public string Id { get; }
        public abstract void Execute(Akka.Dispatch.IRunnable run);
        public abstract void Shutdown();
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class ExecutorServiceConfigurator : Akka.Dispatch.ExecutorServiceFactory
    {
        protected ExecutorServiceConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public Akka.Configuration.Config Config { get; }
        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class ExecutorServiceFactory
    {
        protected ExecutorServiceFactory() { }
        public abstract Akka.Dispatch.ExecutorService Produce(string id);
    }
    public class FutureActor : Akka.Actor.ActorBase
    {
        public FutureActor() { }
        public FutureActor(System.Threading.Tasks.TaskCompletionSource<object> completionSource, Akka.Actor.IActorRef respondTo) { }
        protected override bool Receive(object message) { }
    }
    public interface IBlockingMessageQueueSemantics : Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics
    {
        System.TimeSpan BlockTimeOut { get; set; }
    }
    public interface IBoundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics { }
    public interface IBoundedMessageQueueSemantics : Akka.Dispatch.ISemantics
    {
        System.TimeSpan PushTimeOut { get; }
    }
    public interface IDequeBasedMessageQueueSemantics : Akka.Dispatch.ISemantics
    {
        void EnqueueFirst(Akka.Actor.Envelope envelope);
    }
    public interface IDispatcherPrerequisites
    {
        Akka.Event.EventStream EventStream { get; }
        Akka.Dispatch.Mailboxes Mailboxes { get; }
        Akka.Actor.IScheduler Scheduler { get; }
        Akka.Actor.Settings Settings { get; }
    }
    public interface IMultipleConsumerSemantics : Akka.Dispatch.ISemantics { }
    public interface IProducesMessageQueue<TQueue>
        where TQueue : Akka.Dispatch.MessageQueues.IMessageQueue { }
    public interface IRequiresMessageQueue<T>
        where T : Akka.Dispatch.ISemantics { }
    public interface IRunnable
    {
        void Run();
    }
    public interface ISemantics { }
    public interface IUnboundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics { }
    public interface IUnboundedMessageQueueSemantics : Akka.Dispatch.ISemantics { }
    public class Mailbox : Akka.Dispatch.IRunnable
    {
        public Mailbox(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }
        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        public Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue { get; }
        public virtual void CleanUp() { }
        [System.Diagnostics.ConditionalAttribute("MAILBOXDEBUG")]
        public static void DebugPrint(string message, params object[] args) { }
        public void Run() { }
        public virtual void SetActor(Akka.Actor.ActorCell actorCell) { }
    }
    public abstract class MailboxType
    {
        protected readonly Akka.Configuration.Config Config;
        protected readonly Akka.Actor.Settings Settings;
        protected MailboxType(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public abstract Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system);
    }
    public class Mailboxes
    {
        public static readonly string DefaultMailboxId;
        public static readonly string NoMailboxRequirement;
        public Mailboxes(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.DeadLetterMailbox DeadLetterMailbox { get; }
        public System.Type FromConfig(string path) { }
        public Akka.Dispatch.MailboxType GetMailboxType(Akka.Actor.Props props, Akka.Configuration.Config dispatcherConfig) { }
        public System.Type GetRequiredType(System.Type actorType) { }
        public bool HasRequiredType(System.Type actorType) { }
        public Akka.Dispatch.MailboxType Lookup(string id) { }
        public Akka.Dispatch.MailboxType LookupByQueueType(System.Type queueType) { }
        public bool ProducesMessageQueue(System.Type mailboxType) { }
    }
    public abstract class MessageDispatcher
    {
        public const int DefaultThroughput = 100;
        protected MessageDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }
        public Akka.Dispatch.MessageDispatcherConfigurator Configurator { get; }
        public Akka.Event.EventStream EventStream { get; }
        public string Id { get; set; }
        protected long Inhabitants { get; }
        public Akka.Dispatch.Mailboxes Mailboxes { get; }
        [Akka.Annotations.InternalApiAttribute()]
        public System.TimeSpan ShutdownTimeout { get; set; }
        public int Throughput { get; set; }
        public System.Nullable<long> ThroughputDeadlineTime { get; set; }
        public virtual void Attach(Akka.Actor.ActorCell cell) { }
        public virtual void Detach(Akka.Actor.ActorCell cell) { }
        public virtual void Dispatch(Akka.Actor.ActorCell cell, Akka.Actor.Envelope envelope) { }
        protected abstract void ExecuteTask(Akka.Dispatch.IRunnable run);
        protected void ReportFailure(System.Exception ex) { }
        public void Schedule(System.Action run) { }
        public void Schedule(Akka.Dispatch.IRunnable run) { }
        [Akka.Annotations.InternalApiAttribute()]
        protected abstract void Shutdown();
        public virtual void SystemDispatch(Akka.Actor.ActorCell cell, Akka.Dispatch.SysMsg.SystemMessage message) { }
    }
    public abstract class MessageDispatcherConfigurator
    {
        protected MessageDispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public Akka.Configuration.Config Config { get; }
        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }
        protected Akka.Dispatch.ExecutorServiceConfigurator ConfigureExecutor() { }
        public abstract Akka.Dispatch.MessageDispatcher Dispatcher();
    }
    public sealed class PinnedDispatcher : Akka.Dispatch.Dispatcher
    {
        public PinnedDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }
    }
    public class RejectedExecutionException : Akka.Actor.AkkaException
    {
        public RejectedExecutionException(string message = null, System.Exception inner = null) { }
    }
    public class ThreadPoolConfig
    {
        public ThreadPoolConfig(Akka.Configuration.Config config) { }
        public double PoolSizeFactor { get; }
        public int PoolSizeMax { get; }
        public int PoolSizeMin { get; }
        public static int ScaledPoolSize(int floor, double scalar, int ceiling) { }
    }
    public sealed class UnboundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue>
    {
        public UnboundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public sealed class UnboundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedMessageQueue>
    {
        public UnboundedMailbox() { }
        public UnboundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public abstract class UnboundedPriorityMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue>
    {
        public const int DefaultCapacity = 11;
        protected UnboundedPriorityMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int InitialCapacity { get; }
        public virtual Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
        protected abstract int PriorityGenerator(object message);
    }
    public abstract class UnboundedStablePriorityMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedStablePriorityMessageQueue>
    {
        public const int DefaultCapacity = 11;
        protected UnboundedStablePriorityMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int InitialCapacity { get; }
        public virtual Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
        protected abstract int PriorityGenerator(object message);
    }
}
namespace Akka.Dispatch.MessageQueues
{
    public abstract class BlockingMessageQueue : Akka.Dispatch.IBlockingMessageQueueSemantics, Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        protected BlockingMessageQueue() { }
        public System.TimeSpan BlockTimeOut { get; set; }
        public int Count { get; }
        public bool HasMessages { get; }
        protected abstract int LockedCount { get; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        protected abstract void LockedEnqueue(Akka.Actor.Envelope envelope);
        protected abstract bool LockedTryDequeue(out Akka.Actor.Envelope envelope);
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class BoundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics
    {
        public BoundedDequeMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }
        public System.TimeSpan PushTimeOut { get; }
    }
    public class BoundedMessageQueue : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        public BoundedMessageQueue(Akka.Configuration.Config config) { }
        public BoundedMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }
        public int Count { get; }
        public bool HasMessages { get; }
        public System.TimeSpan PushTimeOut { get; set; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class DequeWrapperMessageQueue : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        protected readonly Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue;
        public DequeWrapperMessageQueue(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }
        public int Count { get; }
        public bool HasMessages { get; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        public void EnqueueFirst(Akka.Actor.Envelope envelope) { }
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public interface IMessageQueue
    {
        int Count { get; }
        bool HasMessages { get; }
        void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters);
        void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope);
        bool TryDequeue(out Akka.Actor.Envelope envelope);
    }
    public class UnboundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics
    {
        public UnboundedDequeMessageQueue() { }
    }
    public class UnboundedMessageQueue : Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        public UnboundedMessageQueue() { }
        public int Count { get; }
        public bool HasMessages { get; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class UnboundedPriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics
    {
        [System.ObsoleteAttribute("Use UnboundedPriorityMessageQueue(Func<object, int> priorityGenerator, int initia" +
            "lCapacity) instead. [1.1.3]")]
        public UnboundedPriorityMessageQueue(int initialCapacity) { }
        public UnboundedPriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }
        protected override int LockedCount { get; }
        public void EnqueueFirst(Akka.Actor.Envelope envelope) { }
        protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }
        protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class UnboundedStablePriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics
    {
        public UnboundedStablePriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }
        protected override int LockedCount { get; }
        public void EnqueueFirst(Akka.Actor.Envelope envelope) { }
        protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }
        protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }
    }
}
namespace Akka.Dispatch.SysMsg
{
    public sealed class ActorTask : Akka.Dispatch.SysMsg.SystemMessage
    {
        public ActorTask(System.Threading.Tasks.Task task) { }
        public System.Threading.Tasks.Task Task { get; }
    }
    public sealed class Create : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Create(Akka.Actor.ActorInitializationException failure = null) { }
        public Akka.Actor.ActorInitializationException Failure { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public sealed class DeathWatchNotification : Akka.Dispatch.SysMsg.SystemMessage, Akka.Event.IDeadLetterSuppression
    {
        public DeathWatchNotification(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }
        public Akka.Actor.IActorRef Actor { get; }
        public bool AddressTerminated { get; }
        public bool ExistenceConfirmed { get; }
        public override string ToString() { }
    }
    public sealed class Escalate : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Escalate(System.Exception reason) { }
        public System.Exception Reason { get; }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Failed : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Failed(Akka.Actor.IActorRef child, System.Exception cause, long uid) { }
        public System.Exception Cause { get; }
        public Akka.Actor.IActorRef Child { get; }
        public long Uid { get; }
        public override string ToString() { }
    }
    public interface ISystemMessage : Akka.Actor.INoSerializationVerificationNeeded { }
    public sealed class NoMessage : Akka.Dispatch.SysMsg.SystemMessage
    {
        public NoMessage() { }
        public override string ToString() { }
    }
    public sealed class Recreate : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Recreate(System.Exception cause) { }
        public System.Exception Cause { get; }
        public override string ToString() { }
    }
    public sealed class RegisterTerminationHook
    {
        public static Akka.Dispatch.SysMsg.RegisterTerminationHook Instance { get; }
        public override string ToString() { }
    }
    public sealed class Resume : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Resume(System.Exception causedByFailure) { }
        public System.Exception CausedByFailure { get; set; }
        public override string ToString() { }
    }
    public sealed class Stop : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Stop() { }
        public override string ToString() { }
    }
    public sealed class StopChild
    {
        public StopChild(Akka.Actor.IActorRef child) { }
        public Akka.Actor.IActorRef Child { get; }
        public override string ToString() { }
    }
    public sealed class Supervise : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Supervise(Akka.Actor.IActorRef child, bool async) { }
        public bool Async { get; }
        public Akka.Actor.IActorRef Child { get; }
        public override string ToString() { }
    }
    public sealed class Suspend : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Suspend() { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class SystemMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Dispatch.SysMsg.ISystemMessage
    {
        protected SystemMessage() { }
        public bool Unlinked { get; }
        public void Unlink() { }
    }
    public sealed class Terminate : Akka.Dispatch.SysMsg.SystemMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression
    {
        public Terminate() { }
        public override string ToString() { }
    }
    public sealed class TerminationHook
    {
        public static Akka.Dispatch.SysMsg.TerminationHook Instance { get; }
        public override string ToString() { }
    }
    public sealed class TerminationHookDone
    {
        public static Akka.Dispatch.SysMsg.TerminationHookDone Instance { get; }
        public override string ToString() { }
    }
    public sealed class Unwatch : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Unwatch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        public Akka.Actor.IInternalActorRef Watchee { get; }
        public Akka.Actor.IInternalActorRef Watcher { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class Watch : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Watch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        public Akka.Actor.IInternalActorRef Watchee { get; }
        public Akka.Actor.IInternalActorRef Watcher { get; }
        protected bool Equals(Akka.Dispatch.SysMsg.Watch other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
}
namespace Akka.Event
{
    public abstract class ActorEventBus<TEvent, TClassifier> : Akka.Event.EventBus<TEvent, TClassifier, Akka.Actor.IActorRef>
    {
        protected ActorEventBus() { }
    }
    public abstract class AllDeadLetters
    {
        protected AllDeadLetters(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
        public object Message { get; }
        public Akka.Actor.IActorRef Recipient { get; }
        public Akka.Actor.IActorRef Sender { get; }
        public override string ToString() { }
    }
    public class BusLogging : Akka.Event.LoggingAdapterBase
    {
        public BusLogging(Akka.Event.LoggingBus bus, string logSource, System.Type logClass, Akka.Event.ILogMessageFormatter logMessageFormatter) { }
        public override bool IsDebugEnabled { get; }
        public override bool IsErrorEnabled { get; }
        public override bool IsInfoEnabled { get; }
        public override bool IsWarningEnabled { get; }
        protected override void NotifyDebug(object message) { }
        protected override void NotifyDebug(System.Exception cause, object message) { }
        protected override void NotifyError(object message) { }
        protected override void NotifyError(System.Exception cause, object message) { }
        protected override void NotifyInfo(object message) { }
        protected override void NotifyInfo(System.Exception cause, object message) { }
        protected override void NotifyWarning(object message) { }
        protected override void NotifyWarning(System.Exception cause, object message) { }
    }
    public sealed class DeadLetter : Akka.Event.AllDeadLetters
    {
        public DeadLetter(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
    }
    public class DeadLetterListener : Akka.Actor.ActorBase
    {
        public DeadLetterListener() { }
        protected override void PostRestart(System.Exception reason) { }
        protected override void PostStop() { }
        protected override void PreRestart(System.Exception reason, object message) { }
        protected override void PreStart() { }
        protected override bool Receive(object message) { }
    }
    public class Debug : Akka.Event.LogEvent
    {
        public Debug(string logSource, System.Type logClass, object message) { }
        public Debug(System.Exception cause, string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public class DefaultLogMessageFormatter : Akka.Event.ILogMessageFormatter
    {
        public DefaultLogMessageFormatter() { }
        public string Format(string format, params object[] args) { }
    }
    public class DefaultLogger : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Event.ILoggerMessageQueueSemantics>
    {
        public DefaultLogger() { }
        protected virtual void Print(Akka.Event.LogEvent logEvent) { }
        protected override bool Receive(object message) { }
    }
    public class DummyClassForStringSources
    {
        public DummyClassForStringSources() { }
    }
    public class Error : Akka.Event.LogEvent
    {
        public Error(System.Exception cause, string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public abstract class EventBus<TEvent, TClassifier, TSubscriber>
    {
        protected EventBus() { }
        protected abstract bool Classify(TEvent @event, TClassifier classifier);
        protected abstract TClassifier GetClassifier(TEvent @event);
        protected abstract bool IsSubClassification(TClassifier parent, TClassifier child);
        protected abstract void Publish(TEvent @event, TSubscriber subscriber);
        public virtual void Publish(TEvent @event) { }
        protected string SimpleName(object source) { }
        protected string SimpleName(System.Type source) { }
        public virtual bool Subscribe(TSubscriber subscriber, TClassifier classifier) { }
        public virtual bool Unsubscribe(TSubscriber subscriber) { }
        public virtual bool Unsubscribe(TSubscriber subscriber, TClassifier classifier) { }
    }
    public class EventStream : Akka.Event.LoggingBus
    {
        public EventStream(bool debug) { }
        public bool InitUnsubscriber(Akka.Actor.IActorRef unsubscriber, Akka.Actor.ActorSystem system) { }
        public void StartUnsubscriber(Akka.Actor.Internal.ActorSystemImpl system) { }
        public override bool Subscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }
        public override bool Unsubscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }
        public override bool Unsubscribe(Akka.Actor.IActorRef subscriber) { }
    }
    public class static EventStreamExtensions
    {
        public static bool Subscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }
        public static bool Unsubscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }
    }
    public interface IDeadLetterSuppression { }
    public interface ILogMessageFormatter
    {
        string Format(string format, params object[] args);
    }
    public interface ILoggerMessageQueueSemantics : Akka.Dispatch.ISemantics { }
    public interface ILoggingAdapter
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarningEnabled { get; }
        void Debug(string format, params object[] args);
        void Debug(System.Exception cause, string format, params object[] args);
        void Error(string format, params object[] args);
        void Error(System.Exception cause, string format, params object[] args);
        void Info(string format, params object[] args);
        void Info(System.Exception cause, string format, params object[] args);
        bool IsEnabled(Akka.Event.LogLevel logLevel);
        void Log(Akka.Event.LogLevel logLevel, string format, params object[] args);
        void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format, params object[] args);
        void Warning(string format, params object[] args);
        void Warning(System.Exception cause, string format, params object[] args);
    }
    public class Info : Akka.Event.LogEvent
    {
        public Info(string logSource, System.Type logClass, object message) { }
        public Info(System.Exception cause, string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public class InitializeLogger : Akka.Actor.INoSerializationVerificationNeeded
    {
        public InitializeLogger(Akka.Event.LoggingBus loggingBus) { }
        public Akka.Event.LoggingBus LoggingBus { get; }
    }
    public abstract class LogEvent : Akka.Actor.INoSerializationVerificationNeeded
    {
        protected LogEvent() { }
        public System.Exception Cause { get; set; }
        public System.Type LogClass { get; set; }
        public string LogSource { get; set; }
        public object Message { get; set; }
        public System.Threading.Thread Thread { get; }
        public System.DateTime Timestamp { get; }
        public abstract Akka.Event.LogLevel LogLevel();
        public override string ToString() { }
    }
    public enum LogLevel
    {
        DebugLevel = 0,
        InfoLevel = 1,
        WarningLevel = 2,
        ErrorLevel = 3,
    }
    public class LogMessage
    {
        public LogMessage(Akka.Event.ILogMessageFormatter formatter, string format, params object[] args) { }
        public object[] Args { get; }
        public string Format { get; }
        public override string ToString() { }
    }
    public struct LogSource
    {
        public string Source { get; }
        public System.Type Type { get; }
        public static Akka.Event.LogSource Create(object o) { }
        public static Akka.Event.LogSource Create(object o, Akka.Actor.ActorSystem system) { }
        public static string FromActor(Akka.Actor.IActorContext actor, Akka.Actor.ActorSystem system) { }
        public static string FromActorRef(Akka.Actor.IActorRef a, Akka.Actor.ActorSystem system) { }
        public static string FromString(string source, Akka.Actor.ActorSystem system) { }
        public static string FromType(System.Type t, Akka.Actor.ActorSystem system) { }
        public static System.Type SourceType(object o) { }
    }
    public class LoggerInitialized : Akka.Actor.INoSerializationVerificationNeeded
    {
        public LoggerInitialized() { }
    }
    public class LoggerMailbox : Akka.Dispatch.Mailbox, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue, Akka.Event.ILoggerMessageQueueSemantics
    {
        public LoggerMailbox(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public class static Logging
    {
        public static readonly Akka.Event.StandardOutLogger StandardOutLogger;
        public static System.Type ClassFor(this Akka.Event.LogLevel logLevel) { }
        public static Akka.Event.ILoggingAdapter GetLogger(this Akka.Actor.IActorContext context, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }
        public static Akka.Event.ILoggingAdapter GetLogger(Akka.Actor.ActorSystem system, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }
        public static Akka.Event.ILoggingAdapter GetLogger(Akka.Event.LoggingBus loggingBus, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }
        public static Akka.Event.LogLevel LogLevelFor(string logLevel) { }
        public static Akka.Event.LogLevel LogLevelFor<T>()
            where T : Akka.Event.LogEvent { }
        public static string SimpleName(object o) { }
        public static string SimpleName(System.Type t) { }
        public static string StringFor(this Akka.Event.LogLevel logLevel) { }
    }
    public abstract class LoggingAdapterBase : Akka.Event.ILoggingAdapter
    {
        protected LoggingAdapterBase(Akka.Event.ILogMessageFormatter logMessageFormatter) { }
        public abstract bool IsDebugEnabled { get; }
        public abstract bool IsErrorEnabled { get; }
        public abstract bool IsInfoEnabled { get; }
        public abstract bool IsWarningEnabled { get; }
        public virtual void Debug(string format, params object[] args) { }
        public virtual void Debug(System.Exception cause, string format, params object[] args) { }
        public virtual void Error(System.Exception cause, string format, params object[] args) { }
        public virtual void Error(string format, params object[] args) { }
        public virtual void Info(System.Exception cause, string format, params object[] args) { }
        public virtual void Info(string format, params object[] args) { }
        public bool IsEnabled(Akka.Event.LogLevel logLevel) { }
        public virtual void Log(Akka.Event.LogLevel logLevel, string format, params object[] args) { }
        public virtual void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format, params object[] args) { }
        protected abstract void NotifyDebug(object message);
        protected abstract void NotifyDebug(System.Exception cause, object message);
        protected abstract void NotifyError(object message);
        protected abstract void NotifyError(System.Exception cause, object message);
        protected abstract void NotifyInfo(object message);
        protected abstract void NotifyInfo(System.Exception cause, object message);
        protected void NotifyLog(Akka.Event.LogLevel logLevel, object message) { }
        protected void NotifyLog(Akka.Event.LogLevel logLevel, System.Exception cause, object message) { }
        protected abstract void NotifyWarning(object message);
        protected abstract void NotifyWarning(System.Exception cause, object message);
        public virtual void Warn(string format, params object[] args) { }
        public virtual void Warning(string format, params object[] args) { }
        public virtual void Warning(System.Exception cause, string format, params object[] args) { }
    }
    public class LoggingBus : Akka.Event.ActorEventBus<object, System.Type>
    {
        public LoggingBus() { }
        public Akka.Event.LogLevel LogLevel { get; }
        protected override bool Classify(object @event, System.Type classifier) { }
        protected override System.Type GetClassifier(object @event) { }
        protected override bool IsSubClassification(System.Type parent, System.Type child) { }
        protected override void Publish(object @event, Akka.Actor.IActorRef subscriber) { }
        public void SetLogLevel(Akka.Event.LogLevel logLevel) { }
        public void StartStdoutLogger(Akka.Actor.Settings config) { }
    }
    public sealed class NoLogger : Akka.Event.ILoggingAdapter
    {
        public static readonly Akka.Event.ILoggingAdapter Instance;
        public bool IsDebugEnabled { get; }
        public bool IsErrorEnabled { get; }
        public bool IsInfoEnabled { get; }
        public bool IsWarningEnabled { get; }
        public void Debug(string format, params object[] args) { }
        public void Debug(System.Exception cause, string format, params object[] args) { }
        public void Error(string format, params object[] args) { }
        public void Error(System.Exception cause, string format, params object[] args) { }
        public void Info(string format, params object[] args) { }
        public void Info(System.Exception cause, string format, params object[] args) { }
        public bool IsEnabled(Akka.Event.LogLevel logLevel) { }
        public void Log(Akka.Event.LogLevel logLevel, string format, params object[] args) { }
        public void Log(Akka.Event.LogLevel logLevel, System.Exception cause, string format, params object[] args) { }
        public void Warn(string format, params object[] args) { }
        public void Warning(string format, params object[] args) { }
        public void Warning(System.Exception cause, string format, params object[] args) { }
    }
    public class StandardOutLogger : Akka.Actor.MinimalActorRef
    {
        public StandardOutLogger() { }
        public static System.ConsoleColor DebugColor { get; set; }
        public static System.ConsoleColor ErrorColor { get; set; }
        public static System.ConsoleColor InfoColor { get; set; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public static bool UseColors { get; set; }
        public static System.ConsoleColor WarningColor { get; set; }
        public static void PrintLogEvent(Akka.Event.LogEvent logEvent) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class Subscription<TSubscriber, TClassifier>
    {
        public Subscription(TSubscriber subscriber, System.Collections.Generic.IEnumerable<TClassifier> unsubscriptions) { }
        public Subscription(TSubscriber subscriber) { }
        public TSubscriber Subscriber { get; }
        public System.Collections.Generic.ISet<TClassifier> Unsubscriptions { get; }
    }
    public sealed class SuppressedDeadLetter : Akka.Event.AllDeadLetters
    {
        public SuppressedDeadLetter(Akka.Event.IDeadLetterSuppression message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
    }
    public class TraceLogger : Akka.Actor.UntypedActor
    {
        public TraceLogger() { }
        protected override void OnReceive(object message) { }
    }
    public sealed class UnhandledMessage
    {
        public UnhandledMessage(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
        public object Message { get; }
        public Akka.Actor.IActorRef Recipient { get; }
        public Akka.Actor.IActorRef Sender { get; }
    }
    public class Warning : Akka.Event.LogEvent
    {
        public Warning(string logSource, System.Type logClass, object message) { }
        public Warning(System.Exception cause, string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
}
namespace Akka.IO.Buffers
{
    public class BufferPoolAllocationException : Akka.Actor.AkkaException
    {
        public BufferPoolAllocationException(string message) { }
    }
    public interface IBufferPool
    {
        void Release(System.ArraySegment<byte> buf);
        void Release(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buf);
        System.ArraySegment<byte> Rent();
        System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> Rent(int minimumSize);
    }
}
namespace Akka.IO
{
    public enum ByteOrder
    {
        BigEndian = 0,
        LittleEndian = 1,
    }
    [System.Diagnostics.DebuggerDisplayAttribute("(Count = {_count}, Buffers = {_buffers})")]
    public sealed class ByteString : System.Collections.Generic.IEnumerable<byte>, System.Collections.IEnumerable, System.IEquatable<Akka.IO.ByteString>
    {
        public int Count { get; }
        public static Akka.IO.ByteString Empty { get; }
        public bool IsCompact { get; }
        public bool IsEmpty { get; }
        public byte this[int index] { get; }
        public Akka.IO.ByteString Compact() { }
        public Akka.IO.ByteString Concat(Akka.IO.ByteString other) { }
        public static Akka.IO.ByteString CopyFrom(byte[] array) { }
        public static Akka.IO.ByteString CopyFrom(System.ArraySegment<byte> buffer) { }
        public static Akka.IO.ByteString CopyFrom(byte[] array, int offset, int count) { }
        public static Akka.IO.ByteString CopyFrom(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buffers) { }
        public int CopyTo(byte[] buffer, int index, int count) { }
        public override bool Equals(object obj) { }
        public bool Equals(Akka.IO.ByteString other) { }
        public static Akka.IO.ByteString FromBytes(byte[] array) { }
        public static Akka.IO.ByteString FromBytes(System.ArraySegment<byte> buffer) { }
        public static Akka.IO.ByteString FromBytes(byte[] array, int offset, int count) { }
        public static Akka.IO.ByteString FromBytes(System.Collections.Generic.IEnumerable<System.ArraySegment<byte>> buffers) { }
        public static Akka.IO.ByteString FromString(string str) { }
        public static Akka.IO.ByteString FromString(string str, System.Text.Encoding encoding) { }
        public System.Collections.Generic.IEnumerator<byte> GetEnumerator() { }
        public override int GetHashCode() { }
        public bool HasSubstring(Akka.IO.ByteString other, int index) { }
        public int IndexOf(byte b) { }
        public int IndexOf(byte b, int from) { }
        public Akka.IO.ByteString Slice(int index) { }
        public Akka.IO.ByteString Slice(int index, int count) { }
        public byte[] ToArray() { }
        public override string ToString() { }
        public string ToString(System.Text.Encoding encoding) { }
        public void WriteTo(System.IO.Stream stream) { }
        public System.Threading.Tasks.Task WriteToAsync(System.IO.Stream stream) { }
        public static Akka.IO.ByteString +(Akka.IO.ByteString x, Akka.IO.ByteString y) { }
        public static bool ==(Akka.IO.ByteString x, Akka.IO.ByteString y) { }
        public static Akka.IO.ByteString op_Explicit(byte[] bytes) { }
        public static byte[] op_Explicit(Akka.IO.ByteString byteString) { }
        public static bool !=(Akka.IO.ByteString x, Akka.IO.ByteString y) { }
    }
    public class Dns : Akka.Actor.ExtensionIdProvider<Akka.IO.DnsExt>
    {
        public static readonly Akka.IO.Dns Instance;
        public Dns() { }
        public static Akka.IO.Dns.Resolved Cached(string name, Akka.Actor.ActorSystem system) { }
        public override Akka.IO.DnsExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.IO.Dns.Resolved ResolveName(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }
        public abstract class Command
        {
            protected Command() { }
        }
        public class Resolve : Akka.IO.Dns.Command, Akka.Routing.IConsistentHashable
        {
            public Resolve(string name) { }
            public object ConsistentHashKey { get; }
            public string Name { get; }
        }
        public class Resolved : Akka.IO.Dns.Command
        {
            public Resolved(string name, System.Collections.Generic.IEnumerable<System.Net.IPAddress> ipv4, System.Collections.Generic.IEnumerable<System.Net.IPAddress> ipv6) { }
            public System.Net.IPAddress Addr { get; }
            public System.Collections.Generic.IEnumerable<System.Net.IPAddress> Ipv4 { get; }
            public System.Collections.Generic.IEnumerable<System.Net.IPAddress> Ipv6 { get; }
            public string Name { get; }
            public static Akka.IO.Dns.Resolved Create(string name, System.Collections.Generic.IEnumerable<System.Net.IPAddress> addresses) { }
        }
    }
    public abstract class DnsBase
    {
        protected DnsBase() { }
        public virtual Akka.IO.Dns.Resolved Cached(string name) { }
        public virtual Akka.IO.Dns.Resolved Resolve(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }
    }
    public class DnsExt : Akka.IO.IOExtension
    {
        public DnsExt(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.IO.DnsBase Cache { get; }
        public override Akka.Actor.IActorRef Manager { get; }
        public Akka.IO.IDnsProvider Provider { get; }
        public Akka.IO.DnsExt.DnsSettings Settings { get; }
        public Akka.Actor.IActorRef GetResolver() { }
        public class DnsSettings
        {
            public DnsSettings(Akka.Configuration.Config config) { }
            public string Dispatcher { get; }
            public string ProviderObjectName { get; }
            public string Resolver { get; }
            public Akka.Configuration.Config ResolverConfig { get; }
        }
    }
    public interface IDnsProvider
    {
        System.Type ActorClass { get; }
        Akka.IO.DnsBase Cache { get; }
        System.Type ManagerClass { get; }
    }
    public abstract class IOExtension : Akka.Actor.IExtension
    {
        protected IOExtension() { }
        public abstract Akka.Actor.IActorRef Manager { get; }
    }
    public interface ISocketEventArgsPool
    {
        System.Net.Sockets.SocketAsyncEventArgs Acquire(Akka.Actor.IActorRef actor);
        void Release(System.Net.Sockets.SocketAsyncEventArgs e);
    }
    public class Inet
    {
        public Inet() { }
        public abstract class AbstractSocketOption : Akka.IO.Inet.SocketOption
        {
            protected AbstractSocketOption() { }
        }
        public abstract class AbstractSocketOptionV2 : Akka.IO.Inet.SocketOptionV2
        {
            protected AbstractSocketOptionV2() { }
        }
        public class DatagramChannelCreator : Akka.IO.Inet.SocketOption
        {
            public DatagramChannelCreator() { }
            public virtual System.Net.Sockets.Socket Create() { }
        }
        public class static SO
        {
            public class ReceiveBufferSize : Akka.IO.Inet.SocketOption
            {
                public ReceiveBufferSize(int size) { }
                public override void BeforeConnect(System.Net.Sockets.Socket s) { }
                public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }
                public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }
            }
            public class ReuseAddress : Akka.IO.Inet.SocketOption
            {
                public ReuseAddress(bool on) { }
                public override void BeforeConnect(System.Net.Sockets.Socket s) { }
                public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }
                public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }
            }
            public class SendBufferSize : Akka.IO.Inet.SocketOption
            {
                public SendBufferSize(int size) { }
                public override void AfterConnect(System.Net.Sockets.Socket s) { }
            }
            public class TrafficClass : Akka.IO.Inet.SocketOption
            {
                public TrafficClass(int tc) { }
                public override void AfterConnect(System.Net.Sockets.Socket s) { }
            }
        }
        public abstract class SoForwarders
        {
            protected SoForwarders() { }
        }
        public abstract class SocketOption
        {
            protected SocketOption() { }
            public virtual void AfterConnect(System.Net.Sockets.Socket s) { }
            public virtual void BeforeConnect(System.Net.Sockets.Socket s) { }
            public virtual void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }
            public virtual void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }
        }
        public abstract class SocketOptionV2 : Akka.IO.Inet.SocketOption
        {
            protected SocketOptionV2() { }
            public virtual void AfterBind(System.Net.Sockets.Socket s) { }
        }
    }
    public class InetAddressDnsProvider : Akka.IO.IDnsProvider
    {
        public InetAddressDnsProvider() { }
        public System.Type ActorClass { get; }
        public Akka.IO.DnsBase Cache { get; }
        public System.Type ManagerClass { get; }
    }
    public class InetAddressDnsResolver : Akka.Actor.ActorBase
    {
        public InetAddressDnsResolver(Akka.IO.SimpleDnsCache cache, Akka.Configuration.Config config) { }
        protected override bool Receive(object message) { }
    }
    public class SimpleDnsCache : Akka.IO.DnsBase
    {
        public SimpleDnsCache() { }
        public override Akka.IO.Dns.Resolved Cached(string name) { }
        public void CleanUp() { }
        protected virtual long Clock() { }
    }
    public class SimpleDnsManager : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        public SimpleDnsManager(Akka.IO.DnsExt ext) { }
        protected override void PostStop() { }
        protected override bool Receive(object message) { }
    }
    public class Tcp : Akka.Actor.ExtensionIdProvider<Akka.IO.TcpExt>
    {
        public static readonly Akka.Actor.SupervisorStrategy ConnectionSupervisorStrategy;
        public static readonly Akka.IO.Tcp Instance;
        public Tcp() { }
        public override Akka.IO.TcpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }
        public class Abort : Akka.IO.Tcp.CloseCommand
        {
            public static readonly Akka.IO.Tcp.Abort Instance;
            public override Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public class Aborted : Akka.IO.Tcp.ConnectionClosed
        {
            public static readonly Akka.IO.Tcp.Aborted Instance;
            public override bool IsAborted { get; }
        }
        public class Bind : Akka.IO.Tcp.Command
        {
            public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, int backlog = 100, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, bool pullMode = False) { }
            public int Backlog { get; }
            public Akka.Actor.IActorRef Handler { get; }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
            public bool PullMode { get; }
            public override string ToString() { }
        }
        public class Bound : Akka.IO.Tcp.Event
        {
            public Bound(System.Net.EndPoint localAddress) { }
            public System.Net.EndPoint LocalAddress { get; }
            public override string ToString() { }
        }
        public class Close : Akka.IO.Tcp.CloseCommand
        {
            public static readonly Akka.IO.Tcp.Close Instance;
            public override Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public abstract class CloseCommand : Akka.IO.Tcp.Command, Akka.Event.IDeadLetterSuppression
        {
            protected CloseCommand() { }
            public abstract Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public class Closed : Akka.IO.Tcp.ConnectionClosed
        {
            public static readonly Akka.IO.Tcp.Closed Instance;
        }
        public abstract class Command : Akka.IO.Tcp.Message
        {
            protected Command() { }
            public Akka.IO.Tcp.CommandFailed FailureMessage { get; }
        }
        public sealed class CommandFailed : Akka.IO.Tcp.Event
        {
            public CommandFailed(Akka.IO.Tcp.Command cmd) { }
            public Akka.IO.Tcp.Command Cmd { get; }
            public override string ToString() { }
        }
        public class CompoundWrite : Akka.IO.Tcp.WriteCommand, System.Collections.Generic.IEnumerable<Akka.IO.Tcp.SimpleWriteCommand>, System.Collections.IEnumerable
        {
            public CompoundWrite(Akka.IO.Tcp.SimpleWriteCommand head, Akka.IO.Tcp.WriteCommand tailCommand) { }
            public Akka.IO.Tcp.SimpleWriteCommand Head { get; }
            public Akka.IO.Tcp.WriteCommand TailCommand { get; }
            public System.Collections.Generic.IEnumerator<Akka.IO.Tcp.SimpleWriteCommand> GetEnumerator() { }
            public override string ToString() { }
        }
        public class ConfirmedClose : Akka.IO.Tcp.CloseCommand
        {
            public static readonly Akka.IO.Tcp.ConfirmedClose Instance;
            public override Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public class ConfirmedClosed : Akka.IO.Tcp.ConnectionClosed
        {
            public static readonly Akka.IO.Tcp.ConfirmedClosed Instance;
            public override bool IsConfirmed { get; }
        }
        public class Connect : Akka.IO.Tcp.Command
        {
            public Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, System.Nullable<System.TimeSpan> timeout = null, bool pullMode = False) { }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
            public bool PullMode { get; }
            public System.Net.EndPoint RemoteAddress { get; }
            public System.Nullable<System.TimeSpan> Timeout { get; }
            public override string ToString() { }
        }
        public sealed class Connected : Akka.IO.Tcp.Event
        {
            public Connected(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress) { }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Net.EndPoint RemoteAddress { get; }
            public override string ToString() { }
        }
        public class ConnectionClosed : Akka.IO.Tcp.Event, Akka.Event.IDeadLetterSuppression
        {
            public ConnectionClosed() { }
            public virtual string Cause { get; }
            public virtual bool IsAborted { get; }
            public virtual bool IsConfirmed { get; }
            public virtual bool IsErrorClosed { get; }
            public virtual bool IsPeerClosed { get; }
        }
        public sealed class ErrorClosed : Akka.IO.Tcp.ConnectionClosed
        {
            public ErrorClosed(string cause) { }
            public override string Cause { get; }
            public override bool IsErrorClosed { get; }
            public override string ToString() { }
        }
        public class Event : Akka.IO.Tcp.Message
        {
            public Event() { }
        }
        public class Message : Akka.Actor.INoSerializationVerificationNeeded
        {
            public Message() { }
        }
        public class NoAck : Akka.IO.Tcp.Event
        {
            public static readonly Akka.IO.Tcp.NoAck Instance;
            public NoAck(object token) { }
            public object Token { get; }
            public override string ToString() { }
        }
        public class PeerClosed : Akka.IO.Tcp.ConnectionClosed
        {
            public static readonly Akka.IO.Tcp.PeerClosed Instance;
            public override bool IsPeerClosed { get; }
        }
        public sealed class Received : Akka.IO.Tcp.Event
        {
            public Received(Akka.IO.ByteString data) { }
            public Akka.IO.ByteString Data { get; }
            public override string ToString() { }
        }
        public class Register : Akka.IO.Tcp.Command
        {
            public Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }
            public Akka.Actor.IActorRef Handler { get; }
            public bool KeepOpenOnPeerClosed { get; }
            public bool UseResumeWriting { get; }
            public override string ToString() { }
        }
        public class ResumeAccepting : Akka.IO.Tcp.Command
        {
            public ResumeAccepting(int batchSize) { }
            public int BatchSize { get; }
            public override string ToString() { }
        }
        public class ResumeReading : Akka.IO.Tcp.Command
        {
            public static Akka.IO.Tcp.ResumeReading Instance;
        }
        public class ResumeWriting : Akka.IO.Tcp.Command
        {
            public static readonly Akka.IO.Tcp.ResumeWriting Instance;
            public ResumeWriting() { }
        }
        public abstract class SimpleWriteCommand : Akka.IO.Tcp.WriteCommand
        {
            protected SimpleWriteCommand() { }
            public abstract Akka.IO.Tcp.Event Ack { get; }
            public bool WantsAck { get; }
            public Akka.IO.Tcp.CompoundWrite Append(Akka.IO.Tcp.WriteCommand that) { }
        }
        public class SuspendReading : Akka.IO.Tcp.Command
        {
            public static Akka.IO.Tcp.SuspendReading Instance;
        }
        public class Unbind : Akka.IO.Tcp.Command
        {
            public static readonly Akka.IO.Tcp.Unbind Instance;
        }
        public class Unbound : Akka.IO.Tcp.Event
        {
            public static Akka.IO.Tcp.Unbound Instance;
            public Unbound() { }
        }
        public class Write : Akka.IO.Tcp.SimpleWriteCommand
        {
            public static readonly Akka.IO.Tcp.Write Empty;
            public override Akka.IO.Tcp.Event Ack { get; }
            public Akka.IO.ByteString Data { get; }
            public static Akka.IO.Tcp.Write Create(Akka.IO.ByteString data) { }
            public static Akka.IO.Tcp.Write Create(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack) { }
            public override string ToString() { }
        }
        public abstract class WriteCommand : Akka.IO.Tcp.Command
        {
            protected WriteCommand() { }
            public static Akka.IO.Tcp.WriteCommand Create(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }
            public static Akka.IO.Tcp.WriteCommand Create(params WriteCommand[] writes) { }
            public Akka.IO.Tcp.CompoundWrite Prepend(Akka.IO.Tcp.SimpleWriteCommand other) { }
            public Akka.IO.Tcp.WriteCommand Prepend(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }
        }
        public class WritingResumed : Akka.IO.Tcp.Event
        {
            public static Akka.IO.Tcp.WritingResumed Instance;
            public WritingResumed() { }
        }
    }
    public sealed class TcpExt : Akka.IO.IOExtension
    {
        public TcpExt(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.IO.Buffers.IBufferPool BufferPool { get; }
        public override Akka.Actor.IActorRef Manager { get; }
        public Akka.IO.TcpSettings Settings { get; }
    }
    public class static TcpExtensions
    {
        public static Akka.Actor.IActorRef Tcp(this Akka.Actor.ActorSystem system) { }
    }
    public class TcpMessage
    {
        public TcpMessage() { }
        public static Akka.IO.Tcp.Command Abort() { }
        public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, bool pullMode) { }
        public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog) { }
        public static Akka.IO.Tcp.Command Close() { }
        public static Akka.IO.Tcp.Command ConfirmedClose() { }
        public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, System.Nullable<System.TimeSpan> timeout, bool pullMode) { }
        public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress) { }
        public static Akka.IO.Tcp.NoAck NoAck(object token = null) { }
        public static Akka.IO.Tcp.Command Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }
        public static Akka.IO.Tcp.Command ResumeAccepting(int batchSize) { }
        public static Akka.IO.Tcp.Command ResumeReading() { }
        public static Akka.IO.Tcp.Command ResumeWriting() { }
        public static Akka.IO.Tcp.Command SuspendReading() { }
        public static Akka.IO.Tcp.Command Unbind() { }
        public static Akka.IO.Tcp.Command Write(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack = null) { }
    }
    public class TcpSettings
    {
        public TcpSettings(string bufferPoolConfigPath, int initialSocketAsyncEventArgs, bool traceLogging, int batchAcceptLimit, System.Nullable<System.TimeSpan> registerTimeout, int receivedMessageSizeLimit, string managementDispatcher, string fileIoDispatcher, int transferToLimit, int finishConnectRetries, bool outgoingSocketForceIpv4, int writeCommandsQueueMaxSize) { }
        public int BatchAcceptLimit { get; }
        public string BufferPoolConfigPath { get; }
        public string FileIODispatcher { get; }
        public int FinishConnectRetries { get; }
        public int InitialSocketAsyncEventArgs { get; }
        public string ManagementDispatcher { get; }
        public bool OutgoingSocketForceIpv4 { get; }
        public int ReceivedMessageSizeLimit { get; }
        public System.Nullable<System.TimeSpan> RegisterTimeout { get; }
        public bool TraceLogging { get; }
        public int TransferToLimit { get; set; }
        public int WriteCommandsQueueMaxSize { get; }
        public static Akka.IO.TcpSettings Create(Akka.Actor.ActorSystem system) { }
        public static Akka.IO.TcpSettings Create(Akka.Configuration.Config config) { }
    }
    public class Udp : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpExt>
    {
        public static readonly Akka.IO.Udp Instance;
        public Udp() { }
        public override Akka.IO.UdpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }
        public sealed class Bind : Akka.IO.Udp.Command
        {
            public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }
            public Akka.Actor.IActorRef Handler { get; }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
            public override string ToString() { }
        }
        public sealed class Bound : Akka.IO.Udp.Event
        {
            public Bound(System.Net.EndPoint localAddress) { }
            public System.Net.EndPoint LocalAddress { get; }
            public override string ToString() { }
        }
        public abstract class Command : Akka.IO.Udp.Message
        {
            protected Command() { }
            public object FailureMessage { get; }
        }
        public sealed class CommandFailed : Akka.IO.Udp.Event
        {
            public CommandFailed(Akka.IO.Udp.Command cmd) { }
            public Akka.IO.Udp.Command Cmd { get; }
            public override string ToString() { }
        }
        public abstract class Event : Akka.IO.Udp.Message
        {
            protected Event() { }
        }
        public abstract class Message
        {
            protected Message() { }
        }
        public sealed class NoAck : Akka.IO.Udp.Event
        {
            public static readonly Akka.IO.Udp.NoAck Instance;
            public NoAck(object token) { }
            public object Token { get; }
            public override string ToString() { }
        }
        public sealed class Received : Akka.IO.Udp.Event
        {
            public Received(Akka.IO.ByteString data, System.Net.EndPoint sender) { }
            public Akka.IO.ByteString Data { get; }
            public System.Net.EndPoint Sender { get; }
            public override string ToString() { }
        }
        public sealed class ResumeReading : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.ResumeReading Instance;
        }
        public sealed class SO : Akka.IO.Inet.SoForwarders
        {
            public SO() { }
            public sealed class Broadcast : Akka.IO.Inet.SocketOption
            {
                public Broadcast(bool on) { }
                public bool On { get; }
                public override void BeforeDatagramBind(System.Net.Sockets.Socket s) { }
            }
        }
        public sealed class Send : Akka.IO.Udp.Command
        {
            [System.ObsoleteAttribute("Akka.IO.Udp.Send public constructors are obsolete. Use `Send.Create` or `Send(Byt" +
                "eString, EndPoint, Event)` instead.")]
            public Send(System.Collections.Generic.IEnumerator<System.ArraySegment<byte>> payload, System.Net.EndPoint target, Akka.IO.Udp.Event ack) { }
            public Send(Akka.IO.ByteString payload, System.Net.EndPoint target, Akka.IO.Udp.Event ack) { }
            public Akka.IO.Udp.Event Ack { get; }
            public Akka.IO.ByteString Payload { get; }
            public System.Net.EndPoint Target { get; }
            public bool WantsAck { get; }
            public static Akka.IO.Udp.Send Create(Akka.IO.ByteString data, System.Net.EndPoint target) { }
            public override string ToString() { }
        }
        public sealed class SimpleSender : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.SimpleSender Instance;
            public SimpleSender(System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
        }
        public sealed class SimpleSenderReady : Akka.IO.Udp.Event
        {
            public static readonly Akka.IO.Udp.SimpleSenderReady Instance;
        }
        public sealed class SuspendReading : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.SuspendReading Instance;
        }
        public sealed class Unbind : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.Unbind Instance;
        }
        public sealed class Unbound
        {
            public static readonly Akka.IO.Udp.Unbound Instance;
        }
    }
    public class UdpConnected : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpConnectedExt>
    {
        public static readonly Akka.IO.UdpConnected Instance;
        public UdpConnected() { }
        public override Akka.IO.UdpConnectedExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public abstract class Command : Akka.IO.UdpConnected.Message
        {
            protected Command() { }
            public object FailureMessage { get; }
        }
        public sealed class CommandFailed : Akka.IO.UdpConnected.Event
        {
            public CommandFailed(Akka.IO.UdpConnected.Command cmd) { }
            public Akka.IO.UdpConnected.Command Cmd { get; }
        }
        public sealed class Connect : Akka.IO.UdpConnected.Command
        {
            public Connect(Akka.Actor.IActorRef handler, System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }
            public Akka.Actor.IActorRef Handler { get; }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
            public System.Net.EndPoint RemoteAddress { get; }
        }
        public class Connected : Akka.IO.UdpConnected.Event
        {
            public static readonly Akka.IO.UdpConnected.Connected Instance;
        }
        public class Disconnect : Akka.IO.UdpConnected.Command
        {
            public static readonly Akka.IO.UdpConnected.Disconnect Instance;
        }
        public class Disconnected : Akka.IO.UdpConnected.Event
        {
            public static readonly Akka.IO.UdpConnected.Disconnected Instance;
        }
        public abstract class Event : Akka.IO.UdpConnected.Message
        {
            protected Event() { }
        }
        public abstract class Message
        {
            protected Message() { }
        }
        public class NoAck : Akka.IO.UdpConnected.Event
        {
            public static readonly Akka.IO.UdpConnected.NoAck Instance;
            public NoAck(object token) { }
            public object Token { get; }
        }
        public sealed class Received : Akka.IO.UdpConnected.Event
        {
            public Received(Akka.IO.ByteString data) { }
            public Akka.IO.ByteString Data { get; }
        }
        public class ResumeReading : Akka.IO.UdpConnected.Command
        {
            public static readonly Akka.IO.UdpConnected.ResumeReading Instance;
        }
        public sealed class Send : Akka.IO.UdpConnected.Command
        {
            [System.ObsoleteAttribute("Akka.IO.Udp.Send public constructors are obsolete. Use `Send.Create` or `Send(Byt" +
                "eString, EndPoint, Event)` instead.")]
            public Send(System.Collections.Generic.IEnumerator<System.ArraySegment<byte>> payload, Akka.IO.UdpConnected.Event ack) { }
            public Send(Akka.IO.ByteString payload, object ack) { }
            public object Ack { get; }
            public Akka.IO.ByteString Payload { get; }
            public bool WantsAck { get; }
            public static Akka.IO.UdpConnected.Send Create(Akka.IO.ByteString payload) { }
        }
        public class SuspendReading : Akka.IO.UdpConnected.Command
        {
            public static readonly Akka.IO.UdpConnected.SuspendReading Instance;
        }
    }
    public class UdpConnectedExt : Akka.IO.IOExtension
    {
        public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system) { }
        public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }
        public Akka.IO.Buffers.IBufferPool BufferPool { get; }
        public override Akka.Actor.IActorRef Manager { get; }
    }
    public class UdpExt : Akka.IO.IOExtension
    {
        public UdpExt(Akka.Actor.ExtendedActorSystem system) { }
        public UdpExt(Akka.Actor.ExtendedActorSystem system, Akka.IO.UdpSettings settings) { }
        public Akka.IO.Buffers.IBufferPool BufferPool { get; }
        public override Akka.Actor.IActorRef Manager { get; }
    }
    public class static UdpExtensions
    {
        public static Akka.Actor.IActorRef Udp(this Akka.Actor.ActorSystem system) { }
    }
    public class UdpSettings
    {
        public UdpSettings(string bufferPoolConfigPath, bool traceLogging, int initialSocketAsyncEventArgs, int directBufferSize, int maxDirectBufferPoolSize, int batchReceiveLimit, string managementDispatcher, string fileIoDispatcher) { }
        public int BatchReceiveLimit { get; }
        public string BufferPoolConfigPath { get; }
        public int DirectBufferSize { get; }
        public string FileIODispatcher { get; }
        public int InitialSocketAsyncEventArgs { get; }
        public string ManagementDispatcher { get; }
        public int MaxDirectBufferPoolSize { get; }
        public bool TraceLogging { get; }
        public static Akka.IO.UdpSettings Create(Akka.Actor.ActorSystem system) { }
        public static Akka.IO.UdpSettings Create(Akka.Configuration.Config config) { }
    }
}
namespace Akka.Pattern
{
    public class static Backoff
    {
        [System.ObsoleteAttribute("Use the overloaded one which accepts maxNrOfRetries instead.")]
        public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Pattern.BackoffOptions OnFailure(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }
        [System.ObsoleteAttribute("Use the overloaded one which accepts maxNrOfRetries instead.")]
        public static Akka.Pattern.BackoffOptions OnStop(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Pattern.BackoffOptions OnStop(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }
    }
    public abstract class BackoffOptions
    {
        protected BackoffOptions() { }
        public abstract Akka.Pattern.BackoffOptions WithAutoReset(System.TimeSpan resetBackoff);
        public abstract Akka.Pattern.BackoffOptions WithDefaultStoppingStrategy();
        public abstract Akka.Pattern.BackoffOptions WithFinalStopMessage(System.Func<object, bool> isFinalStopMessage);
        public abstract Akka.Pattern.BackoffOptions WithManualReset();
        public abstract Akka.Pattern.BackoffOptions WithMaxNrOfRetries(int maxNrOfRetries);
        public abstract Akka.Pattern.BackoffOptions WithReplyWhileStopped(object replyWhileStopped);
        public abstract Akka.Pattern.BackoffOptions WithSupervisorStrategy(Akka.Actor.OneForOneStrategy supervisorStrategy);
    }
    public sealed class BackoffSupervisor : Akka.Pattern.BackoffSupervisorBase
    {
        public BackoffSupervisor(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public BackoffSupervisor(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, Akka.Pattern.IBackoffReset reset, double randomFactor, Akka.Actor.SupervisorStrategy strategy, object replyWhileStopped = null, System.Func<object, bool> finalStopMessage = null) { }
        public static Akka.Actor.Props Props(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Actor.Props Props(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries) { }
        public static Akka.Actor.Props Props(Akka.Pattern.BackoffOptions options) { }
        public static Akka.Actor.Props PropsWithSupervisorStrategy(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, Akka.Actor.SupervisorStrategy strategy) { }
        protected override bool Receive(object message) { }
        protected override Akka.Actor.SupervisorStrategy SupervisorStrategy() { }
        public sealed class CurrentChild
        {
            public CurrentChild(Akka.Actor.IActorRef @ref) { }
            public Akka.Actor.IActorRef Ref { get; }
        }
        public sealed class GetCurrentChild
        {
            public static readonly Akka.Pattern.BackoffSupervisor.GetCurrentChild Instance;
        }
        public sealed class GetRestartCount
        {
            public static readonly Akka.Pattern.BackoffSupervisor.GetRestartCount Instance;
        }
        public sealed class Reset
        {
            public static readonly Akka.Pattern.BackoffSupervisor.Reset Instance;
        }
        public sealed class ResetRestartCount : Akka.Event.IDeadLetterSuppression
        {
            public ResetRestartCount(int current) { }
            public int Current { get; }
        }
        public sealed class RestartCount
        {
            public RestartCount(int count) { }
            public int Count { get; }
        }
        public sealed class StartChild : Akka.Event.IDeadLetterSuppression
        {
            public static readonly Akka.Pattern.BackoffSupervisor.StartChild Instance;
        }
    }
    public abstract class BackoffSupervisorBase : Akka.Actor.ActorBase
    {
        protected Akka.Actor.IActorRef Child { get; set; }
        protected string ChildName { get; }
        protected Akka.Actor.Props ChildProps { get; }
        protected System.Func<object, bool> FinalStopMessage { get; }
        protected bool FinalStopMessageReceived { get; set; }
        protected object ReplyWhileStopped { get; }
        protected Akka.Pattern.IBackoffReset Reset { get; }
        protected int RestartCountN { get; set; }
        protected bool HandleBackoff(object message) { }
        protected override void PreStart() { }
    }
    public class CircuitBreaker
    {
        public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }
        public CircuitBreaker(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout, System.TimeSpan maxResetTimeout, double exponentialBackoffFactor) { }
        public System.TimeSpan CallTimeout { get; }
        public long CurrentFailureCount { get; }
        public double ExponentialBackoffFactor { get; }
        public bool IsClosed { get; }
        public bool IsHalfOpen { get; }
        public bool IsOpen { get; }
        public System.Exception LastCaughtException { get; }
        public int MaxFailures { get; }
        public System.TimeSpan MaxResetTimeout { get; }
        public System.TimeSpan ResetTimeout { get; }
        public Akka.Actor.IScheduler Scheduler { get; }
        public static Akka.Pattern.CircuitBreaker Create(Akka.Actor.IScheduler scheduler, int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }
        public void Fail() { }
        public Akka.Pattern.CircuitBreaker OnClose(System.Action callback) { }
        public Akka.Pattern.CircuitBreaker OnHalfOpen(System.Action callback) { }
        public Akka.Pattern.CircuitBreaker OnOpen(System.Action callback) { }
        public void Succeed() { }
        public System.Threading.Tasks.Task<T> WithCircuitBreaker<T>(System.Func<System.Threading.Tasks.Task<T>> body) { }
        public System.Threading.Tasks.Task WithCircuitBreaker(System.Func<System.Threading.Tasks.Task> body) { }
        public Akka.Pattern.CircuitBreaker WithExponentialBackoff(System.TimeSpan maxResetTimeout) { }
        public void WithSyncCircuitBreaker(System.Action body) { }
        public T WithSyncCircuitBreaker<T>(System.Func<T> body) { }
    }
    public class static FutureTimeoutSupport
    {
        public static System.Threading.Tasks.Task<T> After<T>(System.TimeSpan duration, Akka.Actor.IScheduler scheduler, System.Func<System.Threading.Tasks.Task<T>> value) { }
    }
    public interface IBackoffReset { }
    public class IllegalStateException : Akka.Actor.AkkaException
    {
        public IllegalStateException(string message) { }
        public IllegalStateException(string message, System.Exception innerEx) { }
    }
    public class OpenCircuitException : Akka.Actor.AkkaException
    {
        public OpenCircuitException() { }
        public OpenCircuitException(string message) { }
        public OpenCircuitException(string message, System.TimeSpan remainingDuration) { }
        public OpenCircuitException(string message, System.Exception cause) { }
        public OpenCircuitException(string message, System.Exception cause, System.TimeSpan remainingDuration) { }
        public OpenCircuitException(System.Exception cause) { }
        public OpenCircuitException(System.Exception cause, System.TimeSpan remainingDuration) { }
        public System.TimeSpan RemainingDuration { get; }
    }
    public class UserCalledFailException : Akka.Actor.AkkaException
    {
        public UserCalledFailException() { }
    }
}
namespace Akka.Routing
{
    public class ActorRefRoutee : Akka.Routing.Routee
    {
        public ActorRefRoutee(Akka.Actor.IActorRef actor) { }
        public Akka.Actor.IActorRef Actor { get; }
        public override System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Routing.ActorRefRoutee other) { }
        public override int GetHashCode() { }
        public override void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public class ActorSelectionRoutee : Akka.Routing.Routee
    {
        public ActorSelectionRoutee(Akka.Actor.ActorSelection actor) { }
        public Akka.Actor.ActorSelection Selection { get; }
        public override System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Routing.ActorSelectionRoutee other) { }
        public override int GetHashCode() { }
        public override void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class AddRoutee : Akka.Routing.RouterManagementMessage
    {
        public AddRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Routee Routee { get; }
    }
    public sealed class AdjustPoolSize : Akka.Routing.RouterManagementMessage
    {
        public AdjustPoolSize(int change) { }
        public int Change { get; }
    }
    public class Broadcast : Akka.Routing.RouterEnvelope
    {
        public Broadcast(object message) { }
    }
    public sealed class BroadcastGroup : Akka.Routing.Group
    {
        public BroadcastGroup(Akka.Configuration.Config config) { }
        public BroadcastGroup(params string[] paths) { }
        public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        [System.ObsoleteAttribute("Use new BroadcastGroup(actorRefs.Select(c => c.Path.ToString())) instead [1.1.0]")]
        public BroadcastGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees) { }
        public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.Group WithDispatcher(string dispatcher) { }
        public class BroadcastGroupSurrogate : Akka.Util.ISurrogate
        {
            public BroadcastGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class BroadcastPool : Akka.Routing.Pool
    {
        public BroadcastPool(int nrOfInstances) { }
        public BroadcastPool(Akka.Configuration.Config config) { }
        public BroadcastPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.BroadcastPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.BroadcastPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.BroadcastPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class BroadcastPoolSurrogate : Akka.Util.ISurrogate
        {
            public BroadcastPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class BroadcastRoutingLogic : Akka.Routing.RoutingLogic
    {
        public BroadcastRoutingLogic() { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public class static ConsistentHash
    {
        public static Akka.Routing.ConsistentHash<T> Create<T>(System.Collections.Generic.IEnumerable<T> nodes, int virtualNodesFactor) { }
        public class ConsistentHashingPoolSurrogate : Akka.Util.ISurrogate
        {
            public ConsistentHashingPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public delegate object ConsistentHashMapping(object msg);
    public class ConsistentHash<T>
    {
        public ConsistentHash(System.Collections.Generic.SortedDictionary<int, T> nodes, int virtualNodesFactor) { }
        public bool IsEmpty { get; }
        public Akka.Routing.ConsistentHash<T> Add(T node) { }
        public T NodeFor(byte[] key) { }
        public T NodeFor(string key) { }
        public Akka.Routing.ConsistentHash<T> Remove(T node) { }
        public static Akka.Routing.ConsistentHash<T> +(Akka.Routing.ConsistentHash<T> hash, T node) { }
        public static Akka.Routing.ConsistentHash<T> -(Akka.Routing.ConsistentHash<T> hash, T node) { }
        public class ConsistentHashingGroupSurrogate<T> : Akka.Util.ISurrogate
        {
            public ConsistentHashingGroupSurrogate() { }
            public string[] Paths { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ConsistentHashableEnvelope : Akka.Routing.RouterEnvelope, Akka.Routing.IConsistentHashable
    {
        public ConsistentHashableEnvelope(object message, object hashKey) { }
        public object ConsistentHashKey { get; }
        public object HashKey { get; }
    }
    public sealed class ConsistentHashingGroup : Akka.Routing.Group
    {
        public ConsistentHashingGroup(Akka.Configuration.Config config) { }
        public ConsistentHashingGroup(params string[] paths) { }
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        [System.ObsoleteAttribute("Use new ConsistentHashingGroup(actorRefs.Select(c => c.Path.ToString())) instead " +
            "[1.1.0]")]
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees) { }
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<string> paths, Akka.Routing.ConsistentHashMapping hashMapping) { }
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<string> paths, int virtualNodesFactor, Akka.Routing.ConsistentHashMapping hashMapping, string routerDispatcher) { }
        public int VirtualNodesFactor { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ConsistentHashingGroup WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.ConsistentHashingGroup WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }
        public Akka.Routing.ConsistentHashingGroup WithVirtualNodesFactor(int vnodes) { }
        public class ConsistentHashingGroupSurrogate : Akka.Util.ISurrogate
        {
            public ConsistentHashingGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ConsistentHashingPool : Akka.Routing.Pool
    {
        public ConsistentHashingPool(int nrOfInstances) { }
        public ConsistentHashingPool(Akka.Configuration.Config config) { }
        public ConsistentHashingPool(int nrOfInstances, Akka.Routing.ConsistentHashMapping hashMapping) { }
        public ConsistentHashingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False, int virtualNodesFactor = 0, Akka.Routing.ConsistentHashMapping hashMapping = null) { }
        public int VirtualNodesFactor { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ConsistentHashingPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.ConsistentHashingPool WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }
        public Akka.Routing.ConsistentHashingPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.ConsistentHashingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public Akka.Routing.ConsistentHashingPool WithVirtualNodesFactor(int vnodes) { }
        public class ConsistentHashingPoolSurrogate : Akka.Util.ISurrogate
        {
            public ConsistentHashingPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ConsistentHashingRoutingLogic : Akka.Routing.RoutingLogic
    {
        public ConsistentHashingRoutingLogic(Akka.Actor.ActorSystem system) { }
        public ConsistentHashingRoutingLogic(Akka.Actor.ActorSystem system, int virtualNodesFactor, Akka.Routing.ConsistentHashMapping hashMapping) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
        public Akka.Routing.ConsistentHashingRoutingLogic WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }
    }
    public abstract class CustomRouterConfig : Akka.Routing.RouterConfig
    {
        protected CustomRouterConfig() { }
        protected CustomRouterConfig(string routerDispatcher) { }
    }
    public sealed class Deafen : Akka.Routing.ListenerMessage
    {
        public Deafen(Akka.Actor.IActorRef listener) { }
        public Akka.Actor.IActorRef Listener { get; }
    }
    public class DefaultResizer : Akka.Routing.Resizer, System.IEquatable<Akka.Routing.DefaultResizer>
    {
        public DefaultResizer(int lower, int upper, int pressureThreshold = 1, double rampupRate = 0.2, double backoffThreshold = 0.3, double backoffRate = 0.1, int messagesPerResize = 10) { }
        public double BackoffRate { get; }
        public double BackoffThreshold { get; }
        public int LowerBound { get; set; }
        public int MessagesPerResize { get; }
        public int PressureThreshold { get; }
        public double RampupRate { get; }
        public int UpperBound { get; set; }
        public int Backoff(int pressure, int capacity) { }
        public int Capacity(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }
        public bool Equals(Akka.Routing.DefaultResizer other) { }
        public override bool Equals(object obj) { }
        public int Filter(int pressure, int capacity) { }
        public static Akka.Routing.DefaultResizer FromConfig(Akka.Configuration.Config resizerConfig) { }
        public override int GetHashCode() { }
        public override bool IsTimeForResize(long messageCounter) { }
        public int Pressure(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }
        public int Rampup(int pressure, int capacity) { }
        public override int Resize(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }
    }
    public class FromConfig : Akka.Routing.Pool
    {
        public FromConfig() { }
        public FromConfig(Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher) { }
        public static Akka.Routing.FromConfig Instance { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem sys) { }
        public Akka.Actor.Props Props() { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override void VerifyConfig(Akka.Actor.ActorPath path) { }
        public Akka.Routing.FromConfig WithDispatcher(string dispatcherId) { }
        public Akka.Routing.FromConfig WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.FromConfig WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class FromConfigSurrogate : Akka.Util.ISurrogate
        {
            public FromConfigSurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class GetRoutees : Akka.Routing.RouterManagementMessage
    {
        public GetRoutees() { }
        public static Akka.Routing.GetRoutees Instance { get; }
    }
    public abstract class Group : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Group>
    {
        protected readonly string[] InternalPaths;
        protected Group(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        [System.ObsoleteAttribute("Deprecated since Akka.NET v1.1. Use Paths(ActorSystem) instead.")]
        public System.Collections.Generic.IEnumerable<string> Paths { get; }
        public bool Equals(Akka.Routing.Group other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public abstract System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system);
        public Akka.Actor.Props Props() { }
    }
    public interface IConsistentHashable
    {
        object ConsistentHashKey { get; }
    }
    public interface IListeners
    {
        Akka.Routing.ListenerSupport Listeners { get; }
    }
    public sealed class Listen : Akka.Routing.ListenerMessage
    {
        public Listen(Akka.Actor.IActorRef listener) { }
        public Akka.Actor.IActorRef Listener { get; }
    }
    public abstract class ListenerMessage
    {
        protected ListenerMessage() { }
    }
    public class ListenerSupport
    {
        protected readonly System.Collections.Generic.HashSet<Akka.Actor.IActorRef> Listeners;
        public ListenerSupport() { }
        public Akka.Actor.Receive ListenerReceive { get; }
        public void Add(Akka.Actor.IActorRef actor) { }
        public void Gossip(object message) { }
        public void Gossip(object message, Akka.Actor.IActorRef sender) { }
        public void Remove(Akka.Actor.IActorRef actor) { }
    }
    public class NoRouter : Akka.Routing.RouterConfig
    {
        protected NoRouter() { }
        public static Akka.Routing.NoRouter Instance { get; }
        public override string RouterDispatcher { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public class NoRouterSurrogate : Akka.Util.ISurrogate
        {
            public NoRouterSurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public abstract class Pool : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Pool>
    {
        protected Pool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher) { }
        public static Akka.Actor.SupervisorStrategy DefaultSupervisorStrategy { get; }
        public int NrOfInstances { get; }
        public virtual Akka.Routing.Resizer Resizer { get; }
        public override bool StopRouterWhenAllRouteesRemoved { get; }
        public virtual Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }
        public virtual bool UsePoolDispatcher { get; }
        public bool Equals(Akka.Routing.Pool other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public abstract int GetNrOfInstances(Akka.Actor.ActorSystem system);
        public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }
    }
    public sealed class RandomGroup : Akka.Routing.Group
    {
        public RandomGroup(Akka.Configuration.Config config) { }
        public RandomGroup(params string[] paths) { }
        public RandomGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        public RandomGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.RandomGroup WithDispatcher(string dispatcher) { }
        public class RandomGroupSurrogate : Akka.Util.ISurrogate
        {
            public RandomGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RandomLogic : Akka.Routing.RoutingLogic
    {
        public RandomLogic() { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public sealed class RandomPool : Akka.Routing.Pool
    {
        public RandomPool(Akka.Configuration.Config config) { }
        public RandomPool(int nrOfInstances) { }
        public RandomPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.RandomPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.RandomPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.RandomPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class RandomPoolSurrogate : Akka.Util.ISurrogate
        {
            public RandomPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RemoveRoutee : Akka.Routing.RouterManagementMessage
    {
        public RemoveRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Routee Routee { get; }
    }
    public class Resize : Akka.Routing.RouterManagementMessage
    {
        public Resize() { }
    }
    public abstract class Resizer
    {
        protected Resizer() { }
        public static Akka.Routing.Resizer FromConfig(Akka.Configuration.Config parentConfig) { }
        public abstract bool IsTimeForResize(long messageCounter);
        public abstract int Resize(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees);
    }
    public sealed class RoundRobinGroup : Akka.Routing.Group
    {
        public RoundRobinGroup(Akka.Configuration.Config config) { }
        public RoundRobinGroup(params string[] paths) { }
        public RoundRobinGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        [System.ObsoleteAttribute("Use RoundRobinGroup constructor with IEnumerable<string> parameter [1.1.0]")]
        public RoundRobinGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees) { }
        public RoundRobinGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.Group WithDispatcher(string dispatcherId) { }
        public class RoundRobinGroupSurrogate : Akka.Util.ISurrogate
        {
            public RoundRobinGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RoundRobinPool : Akka.Routing.Pool
    {
        public RoundRobinPool(Akka.Configuration.Config config) { }
        public RoundRobinPool(int nrOfInstances) { }
        public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer) { }
        public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem sys) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.RoundRobinPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.RoundRobinPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.RoundRobinPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class RoundRobinPoolSurrogate : Akka.Util.ISurrogate
        {
            public RoundRobinPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RoundRobinRoutingLogic : Akka.Routing.RoutingLogic
    {
        public RoundRobinRoutingLogic() { }
        public RoundRobinRoutingLogic(int next) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public class Routee
    {
        public static readonly Akka.Routing.Routee NoRoutee;
        public Routee() { }
        public virtual System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }
        public static Akka.Routing.Routee FromActorRef(Akka.Actor.IActorRef actorRef) { }
        public virtual void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class Routees
    {
        public Routees(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> routees) { }
        public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Members { get; }
    }
    public class Router
    {
        public Router(Akka.Routing.RoutingLogic logic, Akka.Actor.IActorRef routee, params Akka.Actor.IActorRef[] routees) { }
        public Router(Akka.Routing.RoutingLogic logic, params Akka.Routing.Routee[] routees) { }
        public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Routees { get; }
        public Akka.Routing.RoutingLogic RoutingLogic { get; }
        public Akka.Routing.Router AddRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Router AddRoutee(Akka.Actor.IActorRef routee) { }
        public Akka.Routing.Router AddRoutee(Akka.Actor.ActorSelection routee) { }
        public Akka.Routing.Router RemoveRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Router RemoveRoutee(Akka.Actor.IActorRef routee) { }
        public Akka.Routing.Router RemoveRoutee(Akka.Actor.ActorSelection routee) { }
        public void Route(object message, Akka.Actor.IActorRef sender) { }
        protected virtual void Send(Akka.Routing.Routee routee, object message, Akka.Actor.IActorRef sender) { }
        public Akka.Routing.Router WithRoutees(params Akka.Routing.Routee[] routees) { }
    }
    public abstract class RouterConfig : Akka.Util.ISurrogated, System.IEquatable<Akka.Routing.RouterConfig>
    {
        protected RouterConfig() { }
        protected RouterConfig(string routerDispatcher) { }
        [System.ObsoleteAttribute("Use NoRouter.Instance instead [1.1.0]")]
        public static Akka.Routing.RouterConfig NoRouter { get; }
        public virtual string RouterDispatcher { get; }
        public virtual bool StopRouterWhenAllRouteesRemoved { get; }
        public abstract Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system);
        public bool Equals(Akka.Routing.RouterConfig other) { }
        public override bool Equals(object obj) { }
        public virtual bool IsManagementMessage(object message) { }
        public virtual Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }
        public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);
        public virtual void VerifyConfig(Akka.Actor.ActorPath path) { }
        public virtual Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
    }
    public class RouterEnvelope
    {
        public RouterEnvelope(object message) { }
        public object Message { get; }
    }
    public abstract class RouterManagementMessage
    {
        protected RouterManagementMessage() { }
    }
    public class static RouterMessage
    {
        public static readonly Akka.Routing.GetRoutees GetRoutees;
    }
    public abstract class RoutingLogic : Akka.Actor.INoSerializationVerificationNeeded
    {
        protected RoutingLogic() { }
        public abstract Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees);
    }
    public sealed class ScatterGatherFirstCompletedGroup : Akka.Routing.Group
    {
        public ScatterGatherFirstCompletedGroup(Akka.Configuration.Config config) { }
        public ScatterGatherFirstCompletedGroup(System.TimeSpan within, params string[] paths) { }
        public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within) { }
        [System.ObsoleteAttribute("Use new ScatterGatherFirstCompletedGroup(actorRefs.Select(c => c.Path.ToString())" +
            ", within) instead [1.1.0]")]
        public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees, System.TimeSpan within) { }
        public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within, string routerDispatcher) { }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ScatterGatherFirstCompletedGroup WithDispatcher(string dispatcher) { }
        public class ScatterGatherFirstCompletedGroupSurrogate : Akka.Util.ISurrogate
        {
            public ScatterGatherFirstCompletedGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ScatterGatherFirstCompletedPool : Akka.Routing.Pool
    {
        public ScatterGatherFirstCompletedPool(Akka.Configuration.Config config) { }
        public ScatterGatherFirstCompletedPool(int nrOfInstances) { }
        public ScatterGatherFirstCompletedPool(int nrOfInstances, System.TimeSpan within) { }
        public ScatterGatherFirstCompletedPool(int nrOfInstances, Akka.Routing.Resizer resizer, System.TimeSpan within, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ScatterGatherFirstCompletedPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.ScatterGatherFirstCompletedPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.ScatterGatherFirstCompletedPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class ScatterGatherFirstCompletedPoolSurrogate : Akka.Util.ISurrogate
        {
            public ScatterGatherFirstCompletedPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ScatterGatherFirstCompletedRoutingLogic : Akka.Routing.RoutingLogic
    {
        public ScatterGatherFirstCompletedRoutingLogic(System.TimeSpan within) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public class SeveralRoutees : Akka.Routing.Routee
    {
        public SeveralRoutees(Akka.Routing.Routee[] routees) { }
        public override void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class SmallestMailboxPool : Akka.Routing.Pool
    {
        public SmallestMailboxPool(Akka.Configuration.Config config) { }
        public SmallestMailboxPool(int nrOfInstances) { }
        public SmallestMailboxPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.SmallestMailboxPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.SmallestMailboxPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.SmallestMailboxPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class SmallestMailboxPoolSurrogate : Akka.Util.ISurrogate
        {
            public SmallestMailboxPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class SmallestMailboxRoutingLogic : Akka.Routing.RoutingLogic
    {
        public SmallestMailboxRoutingLogic() { }
        public SmallestMailboxRoutingLogic(int next) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public sealed class TailChopping : Akka.Routing.RoutingLogic
    {
        public TailChopping(Akka.Actor.IScheduler scheduler, System.TimeSpan within, System.TimeSpan interval) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public sealed class TailChoppingGroup : Akka.Routing.Group
    {
        public TailChoppingGroup(Akka.Configuration.Config config) { }
        public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval) { }
        public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval, string routerDispatcher) { }
        public System.TimeSpan Interval { get; }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.TailChoppingGroup WithDispatcher(string dispatcher) { }
        public class TailChoppingGroupSurrogate : Akka.Util.ISurrogate
        {
            public TailChoppingGroupSurrogate() { }
            public System.TimeSpan Interval { get; set; }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class TailChoppingPool : Akka.Routing.Pool
    {
        public TailChoppingPool(Akka.Configuration.Config config) { }
        public TailChoppingPool(int nrOfInstances, System.TimeSpan within, System.TimeSpan interval) { }
        public TailChoppingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, System.TimeSpan within, System.TimeSpan interval, bool usePoolDispatcher = False) { }
        public System.TimeSpan Interval { get; }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.TailChoppingPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.TailChoppingPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.TailChoppingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class TailChoppingPoolSurrogate : Akka.Util.ISurrogate
        {
            public TailChoppingPoolSurrogate() { }
            public System.TimeSpan Interval { get; set; }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class WithListeners : Akka.Routing.ListenerMessage
    {
        public WithListeners(System.Action<Akka.Actor.IActorRef> listenerFunction) { }
        public System.Action<Akka.Actor.IActorRef> ListenerFunction { get; }
    }
}
namespace Akka.Serialization
{
    public class ByteArraySerializer : Akka.Serialization.Serializer
    {
        public ByteArraySerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Information : System.IEquatable<Akka.Serialization.Information>
    {
        public Information(Akka.Actor.Address address, Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Address Address { get; }
        public Akka.Actor.ActorSystem System { get; }
        public bool Equals(Akka.Serialization.Information other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public static bool ==(Akka.Serialization.Information left, Akka.Serialization.Information right) { }
        public static bool !=(Akka.Serialization.Information left, Akka.Serialization.Information right) { }
    }
    public class NewtonSoftJsonSerializer : Akka.Serialization.Serializer
    {
        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }
        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Serialization.NewtonSoftJsonSerializerSettings settings) { }
        public override bool IncludeManifest { get; }
        public object Serializer { get; }
        public Newtonsoft.Json.JsonSerializerSettings Settings { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public sealed class NewtonSoftJsonSerializerSettings
    {
        public static readonly Akka.Serialization.NewtonSoftJsonSerializerSettings Default;
        public NewtonSoftJsonSerializerSettings(bool encodeTypeNames, bool preserveObjectReferences, System.Collections.Generic.IEnumerable<System.Type> converters) { }
        public System.Collections.Generic.IEnumerable<System.Type> Converters { get; }
        public bool EncodeTypeNames { get; }
        public bool PreserveObjectReferences { get; }
        public static Akka.Serialization.NewtonSoftJsonSerializerSettings Create(Akka.Configuration.Config config) { }
    }
    public class NullSerializer : Akka.Serialization.Serializer
    {
        public NullSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override int Identifier { get; }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public class Serialization
    {
        public Serialization(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.Actor.ExtendedActorSystem System { get; }
        public void AddSerializationMap(System.Type type, Akka.Serialization.Serializer serializer) { }
        [System.ObsoleteAttribute("No longer supported. Use the AddSerializer(name, serializer) overload instead.", true)]
        public void AddSerializer(Akka.Serialization.Serializer serializer) { }
        public void AddSerializer(string name, Akka.Serialization.Serializer serializer) { }
        public object Deserialize(byte[] bytes, int serializerId, System.Type type) { }
        public object Deserialize(byte[] bytes, int serializerId, string manifest) { }
        public Akka.Serialization.Serializer FindSerializerFor(object obj, string defaultSerializerName = null) { }
        public Akka.Serialization.Serializer FindSerializerForType(System.Type objectType, string defaultSerializerName = null) { }
        public static Akka.Serialization.Information GetCurrentTransportInformation() { }
        public static string ManifestFor(Akka.Serialization.Serializer s, object msg) { }
        public byte[] Serialize(object o) { }
        public static string SerializedActorPath(Akka.Actor.IActorRef actorRef) { }
        [System.ObsoleteAttribute("Obsolete. Use the SerializeWithTransport<T>(ExtendedActorSystem) method instead.")]
        public static T WithTransport<T>(Akka.Actor.ActorSystem system, Akka.Actor.Address address, System.Func<T> action) { }
        public static T WithTransport<T>(Akka.Actor.ExtendedActorSystem system, System.Func<T> action) { }
    }
    public sealed class SerializationSetup : Akka.Actor.Setup.Setup
    {
        public System.Func<Akka.Actor.ExtendedActorSystem, System.Collections.Immutable.ImmutableHashSet<Akka.Serialization.SerializerDetails>> CreateSerializers { get; }
        public static Akka.Serialization.SerializationSetup Create(System.Func<Akka.Actor.ExtendedActorSystem, System.Collections.Immutable.ImmutableHashSet<Akka.Serialization.SerializerDetails>> createSerializers) { }
    }
    public abstract class Serializer
    {
        protected readonly Akka.Actor.ExtendedActorSystem system;
        protected Serializer(Akka.Actor.ExtendedActorSystem system) { }
        public virtual int Identifier { get; }
        public abstract bool IncludeManifest { get; }
        public abstract object FromBinary(byte[] bytes, System.Type type);
        public T FromBinary<T>(byte[] bytes) { }
        public abstract byte[] ToBinary(object obj);
        public byte[] ToBinaryWithAddress(Akka.Actor.Address address, object obj) { }
    }
    public sealed class SerializerDetails
    {
        public string Alias { get; }
        public Akka.Serialization.Serializer Serializer { get; }
        public System.Collections.Immutable.ImmutableHashSet<System.Type> UseFor { get; }
        public static Akka.Serialization.SerializerDetails Create(string alias, Akka.Serialization.Serializer serializer, System.Collections.Immutable.ImmutableHashSet<System.Type> useFor) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class static SerializerIdentifierHelper
    {
        public static int GetSerializerIdentifierFromConfig(System.Type type, Akka.Actor.ExtendedActorSystem system) { }
    }
    public abstract class SerializerWithStringManifest : Akka.Serialization.Serializer
    {
        protected SerializerWithStringManifest(Akka.Actor.ExtendedActorSystem system) { }
        public virtual bool IncludeManifest { get; }
        public virtual object FromBinary(byte[] bytes, System.Type type) { }
        public abstract object FromBinary(byte[] bytes, string manifest);
        public abstract string Manifest(object o);
    }
}
namespace Akka.Util
{
    public class AtomicBoolean
    {
        public AtomicBoolean(bool initialValue = False) { }
        public bool Value { get; set; }
        public bool CompareAndSet(bool expected, bool newValue) { }
        public bool GetAndSet(bool newValue) { }
        public static bool op_Implicit(Akka.Util.AtomicBoolean atomicBoolean) { }
        public static Akka.Util.AtomicBoolean op_Implicit(bool value) { }
    }
    public class AtomicReference<T>
        where T :  class
    {
        protected T atomicValue;
        public AtomicReference(T originalValue) { }
        public AtomicReference() { }
        public T Value { get; set; }
        public bool CompareAndSet(T expected, T newValue) { }
        public T GetAndSet(T newValue) { }
        public static T op_Implicit(Akka.Util.AtomicReference<T> atomicReference) { }
        public static Akka.Util.AtomicReference<T> op_Implicit(T value) { }
    }
    public class static Base64Encoding
    {
        public const string Base64Chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+~";
        public static string Base64Encode(this long value) { }
        public static System.Text.StringBuilder Base64Encode(this long value, System.Text.StringBuilder sb) { }
        public static string Base64Encode(this string s) { }
    }
    public class static BitArrayHelpers
    {
        public static byte[] ToBytes(this System.Collections.BitArray arr) { }
    }
    public class static ByteHelpers
    {
        public static byte[] PutInt(this byte[] target, int x, int offset = 0, Akka.IO.ByteOrder order = 0) { }
    }
    public class ConcurrentSet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        public ConcurrentSet() { }
        public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection) { }
        public ConcurrentSet(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public ConcurrentSet(int concurrencyLevel, int capacity) { }
        public ConcurrentSet(int concurrencyLevel, System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public ConcurrentSet(int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public int Count { get; }
        public bool IsEmpty { get; }
        public void Clear() { }
        public bool Contains(T item) { }
        public bool TryAdd(T item) { }
        public bool TryRemove(T item) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class static DynamicAccess
    {
        [Akka.Annotations.InternalApiAttribute()]
        public static Akka.Util.Try<TResult> CreateInstanceFor<TResult>(string typeName, params object[] args)
            where TResult :  class { }
    }
    public class static Either
    {
        public static Akka.Util.Left<T> Left<T>(T value) { }
        public static Akka.Util.Right<T> Right<T>(T value) { }
    }
    public abstract class Either<TA, TB>
    {
        protected Either(TA left, TB right) { }
        public abstract bool IsLeft { get; }
        public abstract bool IsRight { get; }
        protected TA Left { get; }
        protected TB Right { get; }
        public object Value { get; }
        public TRes Fold<TRes>(System.Func<TA, TRes> left, System.Func<TB, TRes> right) { }
        public Akka.Util.Either<TRes1, TRes2> Map<TRes1, TRes2>(System.Func<TA, TRes1> map1, System.Func<TB, TRes2> map2) { }
        public Akka.Util.Either<TRes, TB> MapLeft<TRes>(System.Func<TA, TRes> map) { }
        public Akka.Util.Either<TA, TRes> MapRight<TRes>(System.Func<TB, TRes> map) { }
        public Akka.Util.Left<TA, TB> ToLeft() { }
        public Akka.Util.Right<TA, TB> ToRight() { }
        public static Akka.Util.Either<TA, TB> op_Implicit(Akka.Util.Left<TA> left) { }
        public static Akka.Util.Either<TA, TB> op_Implicit(Akka.Util.Right<TB> right) { }
    }
    public sealed class FastLazy<T>
    {
        public FastLazy(System.Func<T> producer) { }
        public bool IsValueCreated { get; }
        public T Value { get; }
    }
    public sealed class FastLazy<S, T>
    {
        public FastLazy(System.Func<S, T> producer, S state) { }
        public bool IsValueCreated { get; }
        public T Value { get; }
    }
    public interface IResolver
    {
        T Resolve<T>(object[] args);
    }
    public interface ISurrogate
    {
        Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system);
    }
    public interface ISurrogated
    {
        Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);
    }
    public class Index<TKey, TValue>
        where TValue : System.IComparable<TValue>
    {
        public Index() { }
        public bool IsEmpty { get; }
        public System.Collections.Generic.IEnumerable<TValue> this[TKey index] { get; }
        public System.Collections.Generic.ICollection<TKey> Keys { get; }
        public System.Collections.Generic.HashSet<TValue> Values { get; }
        public void Clear() { }
        public TValue FindValue(TKey key, System.Func<TValue, bool> predicate) { }
        public void ForEach(System.Action<TKey, TValue> fun) { }
        public bool Put(TKey key, TValue value) { }
        public bool Remove(TKey key, TValue value) { }
        public System.Collections.Generic.IEnumerable<TValue> Remove(TKey key) { }
        public void RemoveValue(TValue value) { }
    }
    public class Left<T>
    {
        public Left(T value) { }
        public bool IsLeft { get; }
        public bool IsRight { get; }
        public T Value { get; }
    }
    public class Left<TA, TB> : Akka.Util.Either<TA, TB>
    {
        public Left(TA a) { }
        public override bool IsLeft { get; }
        public override bool IsRight { get; }
        public TA Value { get; }
    }
    public sealed class ListPriorityQueue
    {
        public ListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }
        public int Count() { }
        public Akka.Actor.Envelope Dequeue() { }
        public void Enqueue(Akka.Actor.Envelope item) { }
        public bool IsConsistent() { }
        public Akka.Actor.Envelope Peek() { }
        public override string ToString() { }
    }
    public class static MurmurHash
    {
        public const uint StartMagicA = 2505324423u;
        public const uint StartMagicB = 718793509u;
        public static int ArrayHash<T>(T[] a) { }
        public static int ByteHash(byte[] b) { }
        public static uint ExtendHash(uint hash, uint value, uint magicA, uint magicB) { }
        public static uint FinalizeHash(uint hash) { }
        public static uint NextMagicA(uint magicA) { }
        public static uint NextMagicB(uint magicB) { }
        public static uint StartHash(uint seed) { }
        public static int StringHash(string s) { }
        public static int SymmetricHash<T>(System.Collections.Generic.IEnumerable<T> xs, uint seed) { }
    }
    public struct Option<T>
    {
        public static readonly Akka.Util.Option<T> None;
        public Option(T value) { }
        public bool HasValue { get; }
        public T Value { get; }
        public bool Equals(Akka.Util.Option<T> other) { }
        public override bool Equals(object obj) { }
        public Akka.Util.Option<TNew> FlatSelect<TNew>(System.Func<T, Akka.Util.Option<TNew>> mapper) { }
        public override int GetHashCode() { }
        public T GetOrElse(T fallbackValue) { }
        public void OnSuccess(System.Action<T> action) { }
        public Akka.Util.Option<TNew> Select<TNew>(System.Func<T, TNew> selector) { }
        public override string ToString() { }
        public static bool ==(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }
        public static Akka.Util.Option<T> op_Implicit(T value) { }
        public static bool !=(Akka.Util.Option<T> left, Akka.Util.Option<T> right) { }
    }
    public abstract class Resolve : Akka.Actor.IIndirectActorProducer
    {
        protected Resolve() { }
        public abstract System.Type ActorType { get; }
        protected static Akka.Util.IResolver Resolver { get; }
        public abstract Akka.Actor.ActorBase Produce();
        public void Release(Akka.Actor.ActorBase actor) { }
        public static void SetResolver(Akka.Util.IResolver resolver) { }
    }
    public class Resolve<TActor> : Akka.Util.Resolve
        where TActor : Akka.Actor.ActorBase
    {
        public Resolve(params object[] args) { }
        public override System.Type ActorType { get; }
        public object[] Arguments { get; }
        public override Akka.Actor.ActorBase Produce() { }
    }
    public class static Result
    {
        public static Akka.Util.Result<T> Failure<T>(System.Exception exception) { }
        public static Akka.Util.Result<T> From<T>(System.Func<T> func) { }
        public static Akka.Util.Result<T> FromTask<T>(System.Threading.Tasks.Task<T> task) { }
        public static Akka.Util.Result<T> Success<T>(T value) { }
    }
    public struct Result<T> : System.IEquatable<Akka.Util.Result<T>>
    {
        public readonly System.Exception Exception;
        public readonly bool IsSuccess;
        public readonly T Value;
        public Result(T value) { }
        public Result(System.Exception exception) { }
        public bool Equals(Akka.Util.Result<T> other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static bool ==(Akka.Util.Result<T> left, Akka.Util.Result<T> right) { }
        public static bool !=(Akka.Util.Result<T> left, Akka.Util.Result<T> right) { }
    }
    public class Right<T>
    {
        public Right(T value) { }
        public bool IsLeft { get; }
        public bool IsRight { get; }
        public T Value { get; }
    }
    public class Right<TA, TB> : Akka.Util.Either<TA, TB>
    {
        public Right(TB b) { }
        public override bool IsLeft { get; }
        public override bool IsRight { get; }
        public TB Value { get; }
    }
    public class static RuntimeDetector
    {
        public static readonly bool IsMono;
        public static readonly bool IsWindows;
    }
    public sealed class StableListPriorityQueue
    {
        public StableListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }
        public int Count() { }
        public Akka.Actor.Envelope Dequeue() { }
        public void Enqueue(Akka.Actor.Envelope item) { }
        public bool IsConsistent() { }
        public Akka.Actor.Envelope Peek() { }
        public override string ToString() { }
    }
    public class static StandardOutWriter
    {
        public static void Write(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }
        public static void WriteLine(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }
    }
    public class static StringFormat
    {
        public static string SafeJoin(string separator, params object[] args) { }
    }
    public class Switch
    {
        public Switch(bool startAsOn = False) { }
        public bool IsOff { get; }
        public bool IsOn { get; }
        public bool IfOff(System.Action action) { }
        public bool IfOn(System.Action action) { }
        public void Locked(System.Action action) { }
        public bool SwitchOff(System.Action action) { }
        public bool SwitchOff() { }
        public bool SwitchOn(System.Action action) { }
        public bool SwitchOn() { }
        protected bool TranscendFrom(bool from, System.Action action) { }
        public bool WhileOff(System.Action action) { }
        public bool WhileOn(System.Action action) { }
    }
    public class static ThreadLocalRandom
    {
        public static System.Random Current { get; }
    }
    public sealed class TickTimeTokenBucket : Akka.Util.TokenBucket
    {
        public TickTimeTokenBucket(long capacity, long period) { }
        public override long CurrentTime { get; }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class TokenBucket
    {
        protected TokenBucket(long capacity, long ticksBetweenTokens) { }
        public abstract long CurrentTime { get; }
        public void Init() { }
        public long Offer(long cost) { }
    }
    public class Try<T>
    {
        public Try(T success) { }
        public Try(System.Exception failure) { }
        public Akka.Util.Option<System.Exception> Failure { get; }
        public bool IsSuccess { get; }
        public Akka.Util.Option<T> Success { get; }
        public static Akka.Util.Try<T> From(System.Func<T> func) { }
        public T Get() { }
        public Akka.Util.Try<T> GetOrElse(System.Func<T> fallback) { }
        public Akka.Util.Try<T> OrElse(Akka.Util.Try<T> @default) { }
        public Akka.Util.Try<T> Recover(System.Action<System.Exception> failureHandler) { }
        public static Akka.Util.Try<T> op_Implicit(T value) { }
    }
    public class static TypeExtensions
    {
        public static bool Implements<T>(this System.Type type) { }
        public static bool Implements(this System.Type type, System.Type moreGeneralType) { }
        [Akka.Annotations.InternalApiAttribute()]
        public static string TypeQualifiedName(this System.Type type) { }
    }
    public class static Vector
    {
        public static System.Func<System.Func<T>, System.Collections.Generic.IList<T>> Fill<T>(int number) { }
    }
    public class static WildcardMatch
    {
        public static bool Like(this string text, string pattern, bool caseSensitive = False) { }
    }
}
namespace Akka.Util.Extensions
{
    public class static DateTimeExtensions
    {
        public static long ToTimestamp(this System.DateTime dateTime) { }
    }
    public class static ObjectExtensions
    {
        public static Akka.Util.Option<T> AsOption<T>(this T obj) { }
    }
    public class static TimeSpanExtensions
    {
        public static System.TimeSpan Multiply(this System.TimeSpan multiplicand, int multiplier) { }
        public static System.TimeSpan Multiply(this System.TimeSpan multiplicand, double multiplier) { }
    }
}
namespace Akka.Util.Internal
{
    public class AtomicCounter : Akka.Util.Internal.IAtomicCounter<int>
    {
        public AtomicCounter(int initialValue) { }
        public AtomicCounter() { }
        public int Current { get; }
        public int AddAndGet(int amount) { }
        public bool CompareAndSet(int expected, int newValue) { }
        public int Decrement() { }
        public int DecrementAndGet() { }
        public int GetAndAdd(int amount) { }
        public int GetAndDecrement() { }
        public int GetAndIncrement() { }
        public int GetAndSet(int value) { }
        public int IncrementAndGet() { }
        public int Next() { }
        public void Reset() { }
    }
    public class AtomicCounterLong : Akka.Util.Internal.IAtomicCounter<long>
    {
        public AtomicCounterLong(long value) { }
        public AtomicCounterLong() { }
        public long Current { get; }
        public long AddAndGet(long amount) { }
        public bool CompareAndSet(long expected, long newValue) { }
        public long DecrementAndGet() { }
        public long GetAndAdd(long amount) { }
        public long GetAndIncrement() { }
        public long GetAndSet(long value) { }
        public long IncrementAndGet() { }
        public long Next() { }
        public void Reset() { }
        public override string ToString() { }
    }
    public class static Extensions
    {
        public static System.Collections.Generic.IDictionary<TKey, TValue> AddAndReturn<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }
        public static void AddOrSet<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }
        public static T AsInstanceOf<T>(this object self) { }
        public static string BetweenDoubleQuotes(this string self) { }
        public static System.Collections.Generic.IEnumerable<T> Concat<T>(this System.Collections.Generic.IEnumerable<T> enumerable, T item) { }
        public static System.Collections.Generic.IEnumerable<T> Drop<T>(this System.Collections.Generic.IEnumerable<T> self, int count) { }
        public static void ForEach<T>(this System.Collections.Generic.IEnumerable<T> source, System.Action<T> action) { }
        public static TValue GetOrElse<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue elseValue) { }
        public static T Head<T>(this System.Collections.Generic.IEnumerable<T> self) { }
        public static string Join(this System.Collections.Generic.IEnumerable<string> self, string separator) { }
        public static System.TimeSpan Max(this System.TimeSpan @this, System.TimeSpan other) { }
        public static System.TimeSpan Min(this System.TimeSpan @this, System.TimeSpan other) { }
        public static System.Collections.Generic.IEnumerable<string> SplitDottedPathHonouringQuotes(this string path) { }
        public static System.Collections.Generic.IEnumerable<T> TakeRight<T>(this System.Collections.Generic.IEnumerable<T> self, int n) { }
    }
    public interface IAtomicCounter<T>
    {
        T Current { get; }
        T AddAndGet(T amount);
        T GetAndAdd(T amount);
        T GetAndIncrement();
        T IncrementAndGet();
        T Next();
        void Reset();
    }
    public interface IAtomicState
    {
        bool HasListeners { get; }
        void AddListener(System.Action listener);
        void Enter();
        System.Threading.Tasks.Task<T> Invoke<T>(System.Func<System.Threading.Tasks.Task<T>> body);
    }
    public class static InterlockedSpin
    {
        public static TReturn ConditionallySwap<T, TReturn>(ref T reference, System.Func<T, System.ValueTuple<bool, T, TReturn>> updateIfTrue)
            where T :  class { }
        public static T Swap<T>(ref T reference, System.Func<T, T> updater)
            where T :  class { }
    }
}
namespace Akka.Util.Reflection
{
    public class static ExpressionExtensions
    {
        public static System.Collections.Generic.IEnumerable<object> GetArguments(this System.Linq.Expressions.NewExpression newExpression) { }
    }
    public class static TypeCache
    {
        public static System.Type GetType(string typeName) { }
    }
}