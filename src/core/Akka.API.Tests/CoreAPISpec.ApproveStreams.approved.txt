[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Benchmarks")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Persistence.Query.Sql")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Persistence.TCK")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Streams.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Streams.Tests")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.InteropServices.GuidAttribute("123b83e9-21f8-49a8-888a-3b1212ff21dc")]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName="")]
namespace Akka.Streams
{
    public sealed class AbruptStageTerminationException : System.Exception
    {
        public AbruptStageTerminationException(Akka.Streams.Stage.GraphStageLogic logic) { }
    }
    public class AbruptTerminationException : System.Exception
    {
        public readonly Akka.Actor.IActorRef Actor;
        public AbruptTerminationException(Akka.Actor.IActorRef actor) { }
    }
    public class static ActorAttributes
    {
        public static Akka.Streams.Attributes CreateDebugLogging(bool enabled) { }
        public static Akka.Streams.Attributes CreateDispatcher(string dispatcherName) { }
        public static Akka.Streams.Attributes CreateFuzzingMode(bool enabled) { }
        public static Akka.Streams.Attributes CreateMaxFixedBufferSize(int size) { }
        public static Akka.Streams.Attributes CreateOutputBurstLimit(int limit) { }
        public static Akka.Streams.Attributes CreateStreamSubscriptionTimeout(System.TimeSpan timeout, Akka.Streams.StreamSubscriptionTimeoutTerminationMode mode) { }
        public static Akka.Streams.Attributes CreateSupervisionStrategy(Akka.Streams.Supervision.Decider strategy) { }
        public static Akka.Streams.Attributes CreateSyncProcessingLimit(int limit) { }
        public sealed class DebugLogging : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.DebugLogging>
        {
            public DebugLogging(bool enabled) { }
            public bool Enabled { get; }
            public bool Equals(Akka.Streams.ActorAttributes.DebugLogging other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class Dispatcher : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.Dispatcher>
        {
            public readonly string Name;
            public Dispatcher(string name) { }
            public bool Equals(Akka.Streams.ActorAttributes.Dispatcher other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class FuzzingMode : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.FuzzingMode>
        {
            public FuzzingMode(bool enabled) { }
            public bool Enabled { get; }
            public bool Equals(Akka.Streams.ActorAttributes.FuzzingMode other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class MaxFixedBufferSize : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.MaxFixedBufferSize>
        {
            public MaxFixedBufferSize(int size) { }
            public int Size { get; }
            public bool Equals(Akka.Streams.ActorAttributes.MaxFixedBufferSize other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class OutputBurstLimit : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.OutputBurstLimit>
        {
            public OutputBurstLimit(int limit) { }
            public int Limit { get; }
            public bool Equals(Akka.Streams.ActorAttributes.OutputBurstLimit other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class StreamSubscriptionTimeout : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.StreamSubscriptionTimeout>
        {
            public StreamSubscriptionTimeout(System.TimeSpan timeout, Akka.Streams.StreamSubscriptionTimeoutTerminationMode mode) { }
            public Akka.Streams.StreamSubscriptionTimeoutTerminationMode Mode { get; }
            public System.TimeSpan Timeout { get; }
            public bool Equals(Akka.Streams.ActorAttributes.StreamSubscriptionTimeout other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class SupervisionStrategy : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute
        {
            public readonly Akka.Streams.Supervision.Decider Decider;
            public SupervisionStrategy(Akka.Streams.Supervision.Decider decider) { }
            public override string ToString() { }
        }
        public sealed class SyncProcessingLimit : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.ActorAttributes.SyncProcessingLimit>
        {
            public SyncProcessingLimit(int limit) { }
            public int Limit { get; }
            public bool Equals(Akka.Streams.ActorAttributes.SyncProcessingLimit other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
    }
    public abstract class ActorMaterializer : Akka.Streams.IMaterializer, Akka.Streams.IMaterializerLoggingProvider, System.IDisposable
    {
        protected ActorMaterializer() { }
        public abstract Akka.Dispatch.MessageDispatcher ExecutionContext { get; }
        public abstract bool IsShutdown { get; }
        public abstract Akka.Event.ILoggingAdapter Logger { get; }
        public abstract Akka.Streams.ActorMaterializerSettings Settings { get; }
        public abstract Akka.Actor.IActorRef Supervisor { get; }
        public abstract Akka.Actor.ActorSystem System { get; }
        public abstract Akka.Actor.IActorRef ActorOf(Akka.Streams.MaterializationContext context, Akka.Actor.Props props);
        public static Akka.Streams.ActorMaterializer Create(Akka.Actor.IActorRefFactory context, Akka.Streams.ActorMaterializerSettings settings = null, string namePrefix = null) { }
        public static Akka.Configuration.Config DefaultConfig() { }
        public void Dispose() { }
        public abstract Akka.Streams.ActorMaterializerSettings EffectiveSettings(Akka.Streams.Attributes attributes);
        public abstract Akka.Event.ILoggingAdapter MakeLogger(object logSource);
        public abstract TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable);
        public abstract TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, Akka.Streams.Attributes initialAttributes);
        public abstract Akka.Actor.ICancelable ScheduleOnce(System.TimeSpan delay, System.Action action);
        public abstract Akka.Actor.ICancelable ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action);
        public abstract void Shutdown();
        public abstract Akka.Streams.IMaterializer WithNamePrefix(string namePrefix);
    }
    public class static ActorMaterializerExtensions
    {
        public static Akka.Streams.ActorMaterializer Materializer(this Akka.Actor.IActorRefFactory context, Akka.Streams.ActorMaterializerSettings settings = null, string namePrefix = null) { }
    }
    public sealed class ActorMaterializerSettings
    {
        public readonly string Dispatcher;
        public readonly int InitialInputBufferSize;
        public readonly bool IsAutoFusing;
        public readonly bool IsDebugLogging;
        public readonly bool IsFuzzingMode;
        public readonly int MaxFixedBufferSize;
        public readonly int MaxInputBufferSize;
        public readonly int OutputBurstLimit;
        public readonly Akka.Streams.Dsl.StreamRefSettings StreamRefSettings;
        public readonly Akka.Streams.StreamSubscriptionTimeoutSettings SubscriptionTimeoutSettings;
        public readonly Akka.Streams.Supervision.Decider SupervisionDecider;
        public readonly int SyncProcessingLimit;
        public ActorMaterializerSettings(int initialInputBufferSize, int maxInputBufferSize, string dispatcher, Akka.Streams.Supervision.Decider supervisionDecider, Akka.Streams.StreamSubscriptionTimeoutSettings subscriptionTimeoutSettings, Akka.Streams.Dsl.StreamRefSettings streamRefSettings, bool isDebugLogging, int outputBurstLimit, bool isFuzzingMode, bool isAutoFusing, int maxFixedBufferSize, int syncProcessingLimit = 1000) { }
        public static Akka.Streams.ActorMaterializerSettings Create(Akka.Actor.ActorSystem system) { }
        public Akka.Streams.ActorMaterializerSettings WithAutoFusing(bool isAutoFusing) { }
        public Akka.Streams.ActorMaterializerSettings WithDebugLogging(bool isEnabled) { }
        public Akka.Streams.ActorMaterializerSettings WithDispatcher(string dispatcher) { }
        public Akka.Streams.ActorMaterializerSettings WithFuzzingMode(bool isFuzzingMode) { }
        public Akka.Streams.ActorMaterializerSettings WithInputBuffer(int initialSize, int maxSize) { }
        public Akka.Streams.ActorMaterializerSettings WithMaxFixedBufferSize(int maxFixedBufferSize) { }
        public Akka.Streams.ActorMaterializerSettings WithStreamRefSettings(Akka.Streams.Dsl.StreamRefSettings settings) { }
        public Akka.Streams.ActorMaterializerSettings WithSubscriptionTimeoutSettings(Akka.Streams.StreamSubscriptionTimeoutSettings settings) { }
        public Akka.Streams.ActorMaterializerSettings WithSupervisionStrategy(Akka.Streams.Supervision.Decider decider) { }
        public Akka.Streams.ActorMaterializerSettings WithSyncProcessingLimit(int limit) { }
    }
    public class AmorphousShape : Akka.Streams.Shape
    {
        public AmorphousShape(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public override Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
    }
    public sealed class Attributes
    {
        public static readonly Akka.Streams.Attributes None;
        public Attributes(params IAttribute[] attributes) { }
        public System.Collections.Generic.IEnumerable<Akka.Streams.Attributes.IAttribute> AttributeList { get; }
        public Akka.Streams.Attributes And(Akka.Streams.Attributes other) { }
        public Akka.Streams.Attributes And(Akka.Streams.Attributes.IAttribute other) { }
        public bool Contains<TAttr>(TAttr attribute)
            where TAttr : Akka.Streams.Attributes.IAttribute { }
        public static Akka.Streams.Attributes CreateAsyncBoundary() { }
        public static Akka.Streams.Attributes CreateInputBuffer(int initial, int max) { }
        public static Akka.Streams.Attributes CreateLogLevels(Akka.Event.LogLevel onElement = 0, Akka.Event.LogLevel onFinish = 0, Akka.Event.LogLevel onError = 3) { }
        public static Akka.Streams.Attributes CreateName(string name) { }
        public static string ExtractName(Akka.Streams.Implementation.IModule module, string defaultIfNotFound) { }
        public TAttr GetAttribute<TAttr>(TAttr defaultIfNotFound)
            where TAttr :  class, Akka.Streams.Attributes.IAttribute { }
        public TAttr GetAttribute<TAttr>()
            where TAttr :  class, Akka.Streams.Attributes.IAttribute { }
        public System.Collections.Generic.IEnumerable<TAttr> GetAttributeList<TAttr>()
            where TAttr : Akka.Streams.Attributes.IAttribute { }
        [System.ObsoleteAttribute("Attributes should always be most specific, use GetAttribute<TAttr>()")]
        public TAttr GetFirstAttribute<TAttr>(TAttr defaultIfNotFound)
            where TAttr :  class, Akka.Streams.Attributes.IAttribute { }
        [System.ObsoleteAttribute("Attributes should always be most specific, use GetAttribute<TAttr>()")]
        public TAttr GetFirstAttribute<TAttr>()
            where TAttr :  class, Akka.Streams.Attributes.IAttribute { }
        public TAttr GetMandatoryAttribute<TAttr>()
            where TAttr :  class, Akka.Streams.Attributes.IMandatoryAttribute { }
        public string GetNameLifted() { }
        public string GetNameOrDefault(string defaultIfNotFound = "unknown-operation") { }
        public override string ToString() { }
        public sealed class AsyncBoundary : Akka.Streams.Attributes.IAttribute, System.IEquatable<Akka.Streams.Attributes.AsyncBoundary>
        {
            public static readonly Akka.Streams.Attributes.AsyncBoundary Instance;
            public bool Equals(Akka.Streams.Attributes.AsyncBoundary other) { }
            public override bool Equals(object obj) { }
            public override string ToString() { }
        }
        public sealed class CancellationStrategy : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute
        {
            public CancellationStrategy(Akka.Streams.Attributes.CancellationStrategy.IStrategy strategy) { }
            public Akka.Streams.Attributes.CancellationStrategy.IStrategy Strategy { get; }
            public class AfterDelay : Akka.Streams.Attributes.CancellationStrategy.IStrategy
            {
                public AfterDelay(System.TimeSpan delay, Akka.Streams.Attributes.CancellationStrategy.IStrategy strategy) { }
                public System.TimeSpan Delay { get; }
                public Akka.Streams.Attributes.CancellationStrategy.IStrategy Strategy { get; }
            }
            public class CompleteStage : Akka.Streams.Attributes.CancellationStrategy.IStrategy
            {
                public CompleteStage() { }
            }
            public class FailStage : Akka.Streams.Attributes.CancellationStrategy.IStrategy
            {
                public FailStage() { }
            }
            public interface IStrategy { }
            public class PropagateFailure : Akka.Streams.Attributes.CancellationStrategy.IStrategy
            {
                public PropagateFailure() { }
            }
        }
        public interface IAttribute { }
        public interface IMandatoryAttribute : Akka.Streams.Attributes.IAttribute { }
        public sealed class InputBuffer : Akka.Streams.Attributes.IAttribute, Akka.Streams.Attributes.IMandatoryAttribute, System.IEquatable<Akka.Streams.Attributes.InputBuffer>
        {
            public readonly int Initial;
            public readonly int Max;
            public InputBuffer(int initial, int max) { }
            public bool Equals(Akka.Streams.Attributes.InputBuffer other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class LogLevels : Akka.Streams.Attributes.IAttribute, System.IEquatable<Akka.Streams.Attributes.LogLevels>
        {
            public static readonly Akka.Event.LogLevel Off;
            public readonly Akka.Event.LogLevel OnElement;
            public readonly Akka.Event.LogLevel OnFailure;
            public readonly Akka.Event.LogLevel OnFinish;
            public LogLevels(Akka.Event.LogLevel onElement, Akka.Event.LogLevel onFinish, Akka.Event.LogLevel onFailure) { }
            public bool Equals(Akka.Streams.Attributes.LogLevels other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class Name : Akka.Streams.Attributes.IAttribute, System.IEquatable<Akka.Streams.Attributes.Name>
        {
            public readonly string Value;
            public Name(string value) { }
            public bool Equals(Akka.Streams.Attributes.Name other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
    }
    public class static BidiShape
    {
        public static Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2> FromFlows<TIn1, TOut1, TIn2, TOut2>(Akka.Streams.FlowShape<TIn1, TOut1> top, Akka.Streams.FlowShape<TIn2, TOut2> bottom) { }
    }
    public sealed class BidiShape<TIn1, TOut1, TIn2, TOut2> : Akka.Streams.Shape
    {
        public readonly Akka.Streams.Inlet<TIn1> Inlet1;
        public readonly Akka.Streams.Inlet<TIn2> Inlet2;
        public readonly Akka.Streams.Outlet<TOut1> Outlet1;
        public readonly Akka.Streams.Outlet<TOut2> Outlet2;
        public BidiShape(Akka.Streams.Inlet<TIn1> in1, Akka.Streams.Outlet<TOut1> out1, Akka.Streams.Inlet<TIn2> in2, Akka.Streams.Outlet<TOut2> out2) { }
        public BidiShape(Akka.Streams.FlowShape<TIn1, TOut1> top, Akka.Streams.FlowShape<TIn2, TOut2> bottom) { }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public override Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
        public Akka.Streams.Shape Reversed() { }
    }
    public class BindFailedException : Akka.Streams.StreamTcpException
    {
        public static readonly Akka.Streams.BindFailedException Instance;
    }
    public class BufferOverflowException : System.Exception
    {
        public BufferOverflowException(string message) { }
        public BufferOverflowException(string message, System.Exception innerException) { }
    }
    public class ClosedShape : Akka.Streams.Shape
    {
        public static readonly Akka.Streams.ClosedShape Instance;
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public override Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
    }
    public class ConnectionException : Akka.Streams.StreamTcpException
    {
        public ConnectionException(string message) { }
        public ConnectionException(string message, System.Exception innerException) { }
    }
    public class static Construct
    {
        public static object Instantiate(this System.Type genericType, System.Type genericParam, params object[] constructorArgs) { }
        public static object Instantiate(this System.Type genericType, System.Type[] genericParams, params object[] constructorArgs) { }
    }
    public enum DelayOverflowStrategy
    {
        EmitEarly = 1,
        DropHead = 2,
        DropTail = 3,
        DropBuffer = 4,
        DropNew = 5,
        Backpressure = 6,
        Fail = 7,
    }
    public class FanInShapeN<T0, T1, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet<T1>> In1s;
        public readonly int N;
        public FanInShapeN(int n, Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShapeN(int n) { }
        public FanInShapeN(int n, string name) { }
        public FanInShapeN(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, params Akka.Streams.Inlet<>[] inlets) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public Akka.Streams.Inlet<T1> In(int n) { }
    }
    public abstract class FanInShape<TOut> : Akka.Streams.Shape
    {
        protected FanInShape(Akka.Streams.Outlet<TOut> outlet, System.Collections.Generic.IEnumerable<Akka.Streams.Inlet> registered, string name) { }
        protected FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        protected abstract Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init);
        public virtual Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
        protected Akka.Streams.Inlet<T> NewInlet<T>(string name) { }
        public interface IInit<TOut>
        {
            System.Collections.Generic.IEnumerable<Akka.Streams.Inlet> Inlets { get; }
            string Name { get; }
            Akka.Streams.Outlet<TOut> Outlet { get; }
        }
        public sealed class InitName<TOut> : Akka.Streams.FanInShape<TOut>.IInit
        {
            public InitName(string name) { }
            public System.Collections.Generic.IEnumerable<Akka.Streams.Inlet> Inlets { get; }
            public string Name { get; }
            public Akka.Streams.Outlet<TOut> Outlet { get; }
        }
        public sealed class InitPorts<TOut> : Akka.Streams.FanInShape<TOut>.IInit
        {
            public InitPorts(Akka.Streams.Outlet<TOut> outlet, System.Collections.Generic.IEnumerable<Akka.Streams.Inlet> inlets) { }
            public System.Collections.Generic.IEnumerable<Akka.Streams.Inlet> Inlets { get; }
            public string Name { get; }
            public Akka.Streams.Outlet<TOut> Outlet { get; }
        }
    }
    public class FanInShape<T0, T1, T2, T3, T4, T5, T6, T7, T8, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public readonly Akka.Streams.Inlet<T3> In3;
        public readonly Akka.Streams.Inlet<T4> In4;
        public readonly Akka.Streams.Inlet<T5> In5;
        public readonly Akka.Streams.Inlet<T6> In6;
        public readonly Akka.Streams.Inlet<T7> In7;
        public readonly Akka.Streams.Inlet<T8> In8;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2, Akka.Streams.Inlet<T3> in3, Akka.Streams.Inlet<T4> in4, Akka.Streams.Inlet<T5> in5, Akka.Streams.Inlet<T6> in6, Akka.Streams.Inlet<T7> in7, Akka.Streams.Inlet<T8> in8) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, T2, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, T2, T3, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public readonly Akka.Streams.Inlet<T3> In3;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2, Akka.Streams.Inlet<T3> in3) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, T2, T3, T4, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public readonly Akka.Streams.Inlet<T3> In3;
        public readonly Akka.Streams.Inlet<T4> In4;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2, Akka.Streams.Inlet<T3> in3, Akka.Streams.Inlet<T4> in4) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, T2, T3, T4, T5, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public readonly Akka.Streams.Inlet<T3> In3;
        public readonly Akka.Streams.Inlet<T4> In4;
        public readonly Akka.Streams.Inlet<T5> In5;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2, Akka.Streams.Inlet<T3> in3, Akka.Streams.Inlet<T4> in4, Akka.Streams.Inlet<T5> in5) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, T2, T3, T4, T5, T6, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public readonly Akka.Streams.Inlet<T3> In3;
        public readonly Akka.Streams.Inlet<T4> In4;
        public readonly Akka.Streams.Inlet<T5> In5;
        public readonly Akka.Streams.Inlet<T6> In6;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2, Akka.Streams.Inlet<T3> in3, Akka.Streams.Inlet<T4> in4, Akka.Streams.Inlet<T5> in5, Akka.Streams.Inlet<T6> in6) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public class FanInShape<T0, T1, T2, T3, T4, T5, T6, T7, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly Akka.Streams.Inlet<T0> In0;
        public readonly Akka.Streams.Inlet<T1> In1;
        public readonly Akka.Streams.Inlet<T2> In2;
        public readonly Akka.Streams.Inlet<T3> In3;
        public readonly Akka.Streams.Inlet<T4> In4;
        public readonly Akka.Streams.Inlet<T5> In5;
        public readonly Akka.Streams.Inlet<T6> In6;
        public readonly Akka.Streams.Inlet<T7> In7;
        public FanInShape(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public FanInShape(string name) { }
        public FanInShape(Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Inlet<T0> in0, Akka.Streams.Inlet<T1> in1, Akka.Streams.Inlet<T2> in2, Akka.Streams.Inlet<T3> in3, Akka.Streams.Inlet<T4> in4, Akka.Streams.Inlet<T5> in5, Akka.Streams.Inlet<T6> in6, Akka.Streams.Inlet<T7> in7) { }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
    }
    public abstract class FanOutShape<TIn> : Akka.Streams.Shape
    {
        protected FanOutShape(Akka.Streams.Inlet<TIn> inlet, System.Collections.Generic.IEnumerable<Akka.Streams.Outlet> registered, string name) { }
        protected FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        protected abstract Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init);
        public virtual Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
        protected Akka.Streams.Outlet<T> NewOutlet<T>(string name) { }
        public interface IInit<TIn>
        {
            Akka.Streams.Inlet<TIn> Inlet { get; }
            string Name { get; }
            System.Collections.Generic.IEnumerable<Akka.Streams.Outlet> Outlets { get; }
        }
        public sealed class InitName<TIn> : Akka.Streams.FanOutShape<TIn>.IInit
        {
            public InitName(string name) { }
            public Akka.Streams.Inlet<TIn> Inlet { get; }
            public string Name { get; }
            public System.Collections.Generic.IEnumerable<Akka.Streams.Outlet> Outlets { get; }
        }
        public sealed class InitPorts<TIn> : Akka.Streams.FanOutShape<TIn>.IInit
        {
            public InitPorts(Akka.Streams.Inlet<TIn> inlet, System.Collections.Generic.IEnumerable<Akka.Streams.Outlet> outlets) { }
            public Akka.Streams.Inlet<TIn> Inlet { get; }
            public string Name { get; }
            public System.Collections.Generic.IEnumerable<Akka.Streams.Outlet> Outlets { get; }
        }
    }
    public class FanOutShape<TIn, T0, T1, T2, T3, T4, T5, T6, T7, T8> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public readonly Akka.Streams.Outlet<T3> Out3;
        public readonly Akka.Streams.Outlet<T4> Out4;
        public readonly Akka.Streams.Outlet<T5> Out5;
        public readonly Akka.Streams.Outlet<T6> Out6;
        public readonly Akka.Streams.Outlet<T7> Out7;
        public readonly Akka.Streams.Outlet<T8> Out8;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2, Akka.Streams.Outlet<T3> out3, Akka.Streams.Outlet<T4> out4, Akka.Streams.Outlet<T5> out5, Akka.Streams.Outlet<T6> out6, Akka.Streams.Outlet<T7> out7, Akka.Streams.Outlet<T8> out8) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1, T2> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1, T2, T3> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public readonly Akka.Streams.Outlet<T3> Out3;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2, Akka.Streams.Outlet<T3> out3) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1, T2, T3, T4> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public readonly Akka.Streams.Outlet<T3> Out3;
        public readonly Akka.Streams.Outlet<T4> Out4;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2, Akka.Streams.Outlet<T3> out3, Akka.Streams.Outlet<T4> out4) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1, T2, T3, T4, T5> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public readonly Akka.Streams.Outlet<T3> Out3;
        public readonly Akka.Streams.Outlet<T4> Out4;
        public readonly Akka.Streams.Outlet<T5> Out5;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2, Akka.Streams.Outlet<T3> out3, Akka.Streams.Outlet<T4> out4, Akka.Streams.Outlet<T5> out5) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1, T2, T3, T4, T5, T6> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public readonly Akka.Streams.Outlet<T3> Out3;
        public readonly Akka.Streams.Outlet<T4> Out4;
        public readonly Akka.Streams.Outlet<T5> Out5;
        public readonly Akka.Streams.Outlet<T6> Out6;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2, Akka.Streams.Outlet<T3> out3, Akka.Streams.Outlet<T4> out4, Akka.Streams.Outlet<T5> out5, Akka.Streams.Outlet<T6> out6) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class FanOutShape<TIn, T0, T1, T2, T3, T4, T5, T6, T7> : Akka.Streams.FanOutShape<TIn>
    {
        public readonly Akka.Streams.Outlet<T0> Out0;
        public readonly Akka.Streams.Outlet<T1> Out1;
        public readonly Akka.Streams.Outlet<T2> Out2;
        public readonly Akka.Streams.Outlet<T3> Out3;
        public readonly Akka.Streams.Outlet<T4> Out4;
        public readonly Akka.Streams.Outlet<T5> Out5;
        public readonly Akka.Streams.Outlet<T6> Out6;
        public readonly Akka.Streams.Outlet<T7> Out7;
        public FanOutShape(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public FanOutShape(string name) { }
        public FanOutShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<T0> out0, Akka.Streams.Outlet<T1> out1, Akka.Streams.Outlet<T2> out2, Akka.Streams.Outlet<T3> out3, Akka.Streams.Outlet<T4> out4, Akka.Streams.Outlet<T5> out5, Akka.Streams.Outlet<T6> out6, Akka.Streams.Outlet<T7> out7) { }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
    }
    public class static FlowMonitor
    {
        public sealed class Failed : Akka.Streams.FlowMonitor.IStreamState
        {
            public Failed(System.Exception cause) { }
            public System.Exception Cause { get; }
        }
        public class Finished : Akka.Streams.FlowMonitor.IStreamState
        {
            public static Akka.Streams.FlowMonitor.Finished Instance { get; }
        }
        public interface IStreamState { }
        public class Initialized : Akka.Streams.FlowMonitor.IStreamState
        {
            public static Akka.Streams.FlowMonitor.Initialized Instance { get; }
        }
        public sealed class Received<T> : Akka.Streams.FlowMonitor.IStreamState
        {
            public Received(T message) { }
            public T Message { get; }
        }
    }
    public sealed class FlowShape<TIn, TOut> : Akka.Streams.Shape, Akka.Streams.IFlowShape
    {
        public FlowShape(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<TOut> outlet) { }
        public Akka.Streams.Inlet<TIn> Inlet { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public Akka.Streams.Outlet<TOut> Outlet { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public override Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
    }
    public class static Fusing
    {
        public static Akka.Streams.Fusing.FusedGraph<TShape, TMat> Aggressive<TShape, TMat>(Akka.Streams.IGraph<TShape, TMat> graph)
            where TShape : Akka.Streams.Shape { }
        public static Akka.Streams.Implementation.StructuralInfoModule StructuralInfo<TShape, TMat>(Akka.Streams.IGraph<TShape, TMat> graph, Akka.Streams.Attributes attributes)
            where TShape : Akka.Streams.Shape { }
        public sealed class FusedGraph<TShape, TMat> : Akka.Streams.IGraph<TShape>, Akka.Streams.IGraph<TShape, TMat>
            where TShape : Akka.Streams.Shape
        {
            public FusedGraph(Akka.Streams.Implementation.FusedModule module, TShape shape) { }
            public Akka.Streams.Implementation.IModule Module { get; }
            public TShape Shape { get; }
            public Akka.Streams.IGraph<TShape, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
            public Akka.Streams.IGraph<TShape, TMat> Async() { }
            public Akka.Streams.IGraph<TShape, TMat> Named(string name) { }
            public Akka.Streams.IGraph<TShape, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
        }
    }
    public abstract class GraphDelegate<TShape, TMat> : Akka.Streams.IGraph<TShape>, Akka.Streams.IGraph<TShape, TMat>
        where TShape : Akka.Streams.Shape
    {
        protected readonly Akka.Streams.IGraph<TShape, TMat> Inner;
        protected GraphDelegate(Akka.Streams.IGraph<TShape, TMat> inner) { }
        public Akka.Streams.Implementation.IModule Module { get; }
        public TShape Shape { get; }
        public Akka.Streams.IGraph<TShape, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.IGraph<TShape, TMat> Async() { }
        public Akka.Streams.IGraph<TShape, TMat> Named(string name) { }
        public Akka.Streams.IGraph<TShape, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public interface IFlowMonitor
    {
        Akka.Streams.FlowMonitor.IStreamState State { get; }
    }
    public interface IFlowShape
    {
        Akka.Streams.Inlet Inlet { get; }
        Akka.Streams.Outlet Outlet { get; }
    }
    public interface IGraph<out TShape>
        where out TShape : Akka.Streams.Shape
    {
        [Akka.Annotations.InternalApiAttribute()]
        Akka.Streams.Implementation.IModule Module { get; }
        TShape Shape { get; }
    }
    public interface IGraph<out TShape, out TMaterialized> : Akka.Streams.IGraph<TShape>
        where out TShape : Akka.Streams.Shape
    {
        Akka.Streams.IGraph<TShape, TMaterialized> AddAttributes(Akka.Streams.Attributes attributes);
        Akka.Streams.IGraph<TShape, TMaterialized> Async();
        Akka.Streams.IGraph<TShape, TMaterialized> Named(string name);
        Akka.Streams.IGraph<TShape, TMaterialized> WithAttributes(Akka.Streams.Attributes attributes);
    }
    public interface IKillSwitch
    {
        void Abort(System.Exception cause);
        void Shutdown();
    }
    public interface IMaterializer
    {
        Akka.Dispatch.MessageDispatcher ExecutionContext { get; }
        TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable);
        TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, Akka.Streams.Attributes initialAttributes);
        Akka.Actor.ICancelable ScheduleOnce(System.TimeSpan delay, System.Action action);
        Akka.Actor.ICancelable ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action);
        Akka.Streams.IMaterializer WithNamePrefix(string namePrefix);
    }
    public interface IMaterializerLoggingProvider
    {
        Akka.Event.ILoggingAdapter MakeLogger(object logSource);
    }
    public interface IQueueOfferResult { }
    public interface ISinkQueue<T>
    {
        System.Threading.Tasks.Task<Akka.Util.Option<T>> PullAsync();
    }
    public interface ISinkRef<TIn>
    {
        Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> Sink { get; }
    }
    public interface ISourceQueueWithComplete<in T> : Akka.Streams.ISourceQueue<T>
    {
        void Complete();
        void Fail(System.Exception ex);
        new System.Threading.Tasks.Task WatchCompletionAsync();
    }
    public interface ISourceQueue<in T>
    {
        System.Threading.Tasks.Task<Akka.Streams.IQueueOfferResult> OfferAsync(T element);
        System.Threading.Tasks.Task WatchCompletionAsync();
    }
    public interface ISourceRef<TOut> : Akka.Util.ISurrogated
    {
        Akka.Streams.Dsl.Source<TOut, Akka.NotUsed> Source { get; }
    }
    public interface ITransformerLike<in TIn, out TOut>
    {
        bool IsComplete { get; }
        void Cleanup();
        void OnError(System.Exception cause);
        System.Collections.Generic.IEnumerable<TOut> OnNext(TIn element);
        System.Collections.Generic.IEnumerable<TOut> OnTermination(System.Exception cause);
    }
    public interface IUntypedPublisher
    {
        void Subscribe(Akka.Streams.IUntypedSubscriber subscriber);
    }
    public interface IUntypedSubscriber
    {
        void OnComplete();
        void OnError(System.Exception cause);
        void OnNext(object element);
        void OnSubscribe(Reactive.Streams.ISubscription subscription);
    }
    public abstract class InPort
    {
        protected InPort() { }
    }
    public abstract class Inlet : Akka.Streams.InPort
    {
        public readonly string Name;
        protected Inlet(string name) { }
        public abstract Akka.Streams.Inlet CarbonCopy();
        public static Akka.Streams.Inlet<T> Create<T>(Akka.Streams.Inlet inlet) { }
        public virtual string ToString() { }
    }
    public sealed class Inlet<T> : Akka.Streams.Inlet
    {
        public Inlet(string name) { }
        public override Akka.Streams.Inlet CarbonCopy() { }
    }
    public sealed class InvalidPartnerActorException : Akka.Pattern.IllegalStateException
    {
        public InvalidPartnerActorException(Akka.Actor.IActorRef expectedRef, Akka.Actor.IActorRef gotRef, string message) { }
        public Akka.Actor.IActorRef ExpectedRef { get; }
        public Akka.Actor.IActorRef GotRef { get; }
    }
    public sealed class InvalidSequenceNumberException : Akka.Pattern.IllegalStateException
    {
        public InvalidSequenceNumberException(long expectedSeqNr, long gotSeqNr, string message) { }
        public long ExpectedSeqNr { get; }
        public long GotSeqNr { get; }
    }
    public class static KillSwitches
    {
        public static Akka.Streams.IGraph<Akka.Streams.FlowShape<T, T>, Akka.NotUsed> AsFlow<T>(this System.Threading.CancellationToken cancellationToken, bool cancelGracefully = False) { }
        public static Akka.Streams.SharedKillSwitch Shared(string name) { }
        public static Akka.Streams.IGraph<Akka.Streams.FlowShape<T, T>, Akka.Streams.UniqueKillSwitch> Single<T>() { }
        public static Akka.Streams.IGraph<Akka.Streams.BidiShape<T1, T1, T2, T2>, Akka.Streams.UniqueKillSwitch> SingleBidi<T1, T2>() { }
    }
    public struct MaterializationContext
    {
        public readonly Akka.Streams.Attributes EffectiveAttributes;
        public readonly Akka.Streams.IMaterializer Materializer;
        public readonly string StageName;
        public MaterializationContext(Akka.Streams.IMaterializer materializer, Akka.Streams.Attributes effectiveAttributes, string stageName) { }
    }
    public class MaterializationException : System.Exception
    {
        public MaterializationException(string message, System.Exception innerException) { }
    }
    public sealed class NoMaterializer : Akka.Streams.IMaterializer
    {
        public static readonly Akka.Streams.IMaterializer Instance;
        public Akka.Dispatch.MessageDispatcher ExecutionContext { get; }
        public TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable) { }
        public TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, Akka.Streams.Attributes initialAttributes) { }
        public Akka.Actor.ICancelable ScheduleOnce(System.TimeSpan delay, System.Action action) { }
        public Akka.Actor.ICancelable ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }
        public Akka.Streams.IMaterializer WithNamePrefix(string name) { }
    }
    public class NoSuchElementException : System.Exception
    {
        public NoSuchElementException(string message) { }
    }
    public abstract class OutPort
    {
        protected OutPort() { }
    }
    public abstract class Outlet : Akka.Streams.OutPort
    {
        public readonly string Name;
        protected Outlet(string name) { }
        public abstract Akka.Streams.Outlet CarbonCopy();
        public static Akka.Streams.Outlet<T> Create<T>(Akka.Streams.Outlet outlet) { }
        public virtual string ToString() { }
    }
    public sealed class Outlet<T> : Akka.Streams.Outlet
    {
        public Outlet(string name) { }
        public override Akka.Streams.Outlet CarbonCopy() { }
    }
    public enum OverflowStrategy
    {
        DropHead = 2,
        DropTail = 3,
        DropBuffer = 4,
        DropNew = 5,
        Backpressure = 6,
        Fail = 7,
    }
    public sealed class QueueOfferResult
    {
        public QueueOfferResult() { }
        public sealed class Dropped : Akka.Streams.IQueueOfferResult
        {
            public static readonly Akka.Streams.QueueOfferResult.Dropped Instance;
        }
        public sealed class Enqueued : Akka.Streams.IQueueOfferResult
        {
            public static readonly Akka.Streams.QueueOfferResult.Enqueued Instance;
        }
        public sealed class Failure : Akka.Streams.IQueueOfferResult
        {
            public Failure(System.Exception cause) { }
            public System.Exception Cause { get; }
        }
        public sealed class QueueClosed : Akka.Streams.IQueueOfferResult
        {
            public static readonly Akka.Streams.QueueOfferResult.QueueClosed Instance;
        }
    }
    public sealed class RemoteStreamRefActorTerminatedException : System.Exception
    {
        public RemoteStreamRefActorTerminatedException(string message) { }
    }
    public abstract class Shape
    {
        protected Shape() { }
        public abstract System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public object Clone() { }
        public abstract Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets);
        public abstract Akka.Streams.Shape DeepCopy();
        public bool HasSamePortsAndShapeAs(Akka.Streams.Shape shape) { }
        public bool HasSamePortsAs(Akka.Streams.Shape shape) { }
        public virtual string ToString() { }
    }
    public sealed class SharedKillSwitch : Akka.Streams.IKillSwitch
    {
        public void Abort(System.Exception cause) { }
        public Akka.Streams.IGraph<Akka.Streams.FlowShape<T, T>, Akka.Streams.SharedKillSwitch> Flow<T>() { }
        public void Shutdown() { }
        public override string ToString() { }
    }
    public sealed class SinkShape<TIn> : Akka.Streams.Shape
    {
        public readonly Akka.Streams.Inlet<TIn> Inlet;
        public SinkShape(Akka.Streams.Inlet<TIn> inlet) { }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public override Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public sealed class SourceShape<TOut> : Akka.Streams.Shape
    {
        public readonly Akka.Streams.Outlet<TOut> Outlet;
        public SourceShape(Akka.Streams.Outlet<TOut> outlet) { }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> Inlets { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> Outlets { get; }
        public override Akka.Streams.Shape CopyFromPorts(System.Collections.Immutable.ImmutableArray<Akka.Streams.Inlet> inlets, System.Collections.Immutable.ImmutableArray<Akka.Streams.Outlet> outlets) { }
        public override Akka.Streams.Shape DeepCopy() { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public class StreamLimitReachedException : System.Exception
    {
        public StreamLimitReachedException(long max) { }
    }
    public class static StreamRefAttributes
    {
        public static Akka.Streams.Attributes CreateBufferCapacity(int capacity) { }
        public static Akka.Streams.Attributes CreateDemandRedeliveryInterval(System.TimeSpan timeout) { }
        public static Akka.Streams.Attributes CreateFinalTerminationSignalDeadline(System.TimeSpan timeout) { }
        public static Akka.Streams.Attributes CreateSubscriptionTimeout(System.TimeSpan timeout) { }
        public sealed class BufferCapacity : Akka.Streams.Attributes.IAttribute, Akka.Streams.StreamRefAttributes.IStreamRefAttribute, System.IEquatable<Akka.Streams.StreamRefAttributes.BufferCapacity>
        {
            public BufferCapacity(int capacity) { }
            public int Capacity { get; }
            public bool Equals(Akka.Streams.StreamRefAttributes.BufferCapacity other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class DemandRedeliveryInterval : Akka.Streams.Attributes.IAttribute, Akka.Streams.StreamRefAttributes.IStreamRefAttribute, System.IEquatable<Akka.Streams.StreamRefAttributes.DemandRedeliveryInterval>
        {
            public DemandRedeliveryInterval(System.TimeSpan timeout) { }
            public System.TimeSpan Timeout { get; }
            public bool Equals(Akka.Streams.StreamRefAttributes.DemandRedeliveryInterval other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class FinalTerminationSignalDeadline : Akka.Streams.Attributes.IAttribute, Akka.Streams.StreamRefAttributes.IStreamRefAttribute, System.IEquatable<Akka.Streams.StreamRefAttributes.FinalTerminationSignalDeadline>
        {
            public FinalTerminationSignalDeadline(System.TimeSpan timeout) { }
            public System.TimeSpan Timeout { get; }
            public bool Equals(Akka.Streams.StreamRefAttributes.FinalTerminationSignalDeadline other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public interface IStreamRefAttribute : Akka.Streams.Attributes.IAttribute { }
        public sealed class SubscriptionTimeout : Akka.Streams.Attributes.IAttribute, Akka.Streams.StreamRefAttributes.IStreamRefAttribute, System.IEquatable<Akka.Streams.StreamRefAttributes.SubscriptionTimeout>
        {
            public SubscriptionTimeout(System.TimeSpan timeout) { }
            public System.TimeSpan Timeout { get; }
            public bool Equals(Akka.Streams.StreamRefAttributes.SubscriptionTimeout other) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
    }
    public sealed class StreamRefSubscriptionTimeoutException : Akka.Pattern.IllegalStateException
    {
        public StreamRefSubscriptionTimeoutException(string message) { }
    }
    public sealed class StreamSubscriptionTimeoutSettings : System.IEquatable<Akka.Streams.StreamSubscriptionTimeoutSettings>
    {
        public readonly Akka.Streams.StreamSubscriptionTimeoutTerminationMode Mode;
        public readonly System.TimeSpan Timeout;
        public StreamSubscriptionTimeoutSettings(Akka.Streams.StreamSubscriptionTimeoutTerminationMode mode, System.TimeSpan timeout) { }
        public static Akka.Streams.StreamSubscriptionTimeoutSettings Create(Akka.Configuration.Config config) { }
        public override bool Equals(object obj) { }
        public bool Equals(Akka.Streams.StreamSubscriptionTimeoutSettings other) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public enum StreamSubscriptionTimeoutTerminationMode
    {
        NoopTermination = 0,
        WarnTermination = 1,
        CancelTermination = 2,
    }
    public class StreamTcpException : System.Exception
    {
        public StreamTcpException(string message) { }
        public StreamTcpException(string message, System.Exception innerException) { }
    }
    public enum SubstreamCancelStrategy
    {
        Propagate = 0,
        Drain = 1,
    }
    public sealed class TargetRefNotInitializedYetException : Akka.Pattern.IllegalStateException
    {
        public TargetRefNotInitializedYetException() { }
    }
    public enum ThrottleMode
    {
        Shaping = 0,
        Enforcing = 1,
    }
    public abstract class TransformerLikeBase<TIn, TOut> : Akka.Streams.ITransformerLike<TIn, TOut>
    {
        protected TransformerLikeBase() { }
        public virtual bool IsComplete { get; }
        public virtual void Cleanup() { }
        public virtual void OnError(System.Exception cause) { }
        public abstract System.Collections.Generic.IEnumerable<TOut> OnNext(TIn element);
        public virtual System.Collections.Generic.IEnumerable<TOut> OnTermination(System.Exception cause) { }
    }
    public class UniformFanInShape<TIn, TOut> : Akka.Streams.FanInShape<TOut>
    {
        public readonly int N;
        public UniformFanInShape(int n, Akka.Streams.FanInShape<TOut>.IInit init) { }
        public UniformFanInShape(int n) { }
        public UniformFanInShape(int n, string name) { }
        public UniformFanInShape(Akka.Streams.Outlet<TOut> outlet, params Akka.Streams.Inlet<>[] inlets) { }
        public System.Collections.Immutable.IImmutableList<Akka.Streams.Inlet<TIn>> Ins { get; }
        protected override Akka.Streams.FanInShape<TOut> Construct(Akka.Streams.FanInShape<TOut>.IInit init) { }
        public Akka.Streams.Inlet<TIn> In(int n) { }
    }
    public class UniformFanOutShape<TIn, TOut> : Akka.Streams.FanOutShape<TIn>
    {
        public UniformFanOutShape(int n, Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public UniformFanOutShape(int n) { }
        public UniformFanOutShape(int n, string name) { }
        public UniformFanOutShape(Akka.Streams.Inlet<TIn> inlet, params Akka.Streams.Outlet<>[] outlets) { }
        public System.Collections.Immutable.IImmutableList<Akka.Streams.Outlet<TOut>> Outs { get; }
        protected override Akka.Streams.FanOutShape<TIn> Construct(Akka.Streams.FanOutShape<TIn>.IInit init) { }
        public Akka.Streams.Outlet<TOut> Out(int n) { }
    }
    public sealed class UniqueKillSwitch : Akka.Streams.IKillSwitch
    {
        public void Abort(System.Exception cause) { }
        public void Shutdown() { }
        public override string ToString() { }
    }
    public class WatchedActorTerminatedException : Akka.Actor.AkkaException
    {
        public WatchedActorTerminatedException(string stageName, Akka.Actor.IActorRef actorRef) { }
    }
}
namespace Akka.Streams.Actors
{
    public class static ActorPublisher
    {
        public static Reactive.Streams.IPublisher<T> Create<T>(Akka.Actor.IActorRef @ref) { }
    }
    public sealed class ActorPublisherImpl<T> : Reactive.Streams.IPublisher<T>
    {
        public ActorPublisherImpl(Akka.Actor.IActorRef @ref) { }
        public void Subscribe(Reactive.Streams.ISubscriber<T> subscriber) { }
    }
    public sealed class ActorPublisherSubscription : Reactive.Streams.ISubscription
    {
        public ActorPublisherSubscription(Akka.Actor.IActorRef @ref) { }
        public void Cancel() { }
        public void Request(long n) { }
    }
    public abstract class ActorPublisher<T> : Akka.Actor.ActorBase
    {
        protected ActorPublisher() { }
        public bool IsActive { get; }
        public bool IsCanceled { get; }
        public bool IsCompleted { get; }
        public bool IsErrorEmitted { get; }
        public System.TimeSpan SubscriptionTimeout { get; set; }
        public long TotalDemand { get; }
        public override void AroundPostRestart(System.Exception cause, object message) { }
        public override void AroundPostStop() { }
        public override void AroundPreRestart(System.Exception cause, object message) { }
        public override void AroundPreStart() { }
        protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }
        public void OnComplete() { }
        public void OnCompleteThenStop() { }
        public void OnError(System.Exception cause) { }
        public void OnErrorThenStop(System.Exception cause) { }
        public void OnNext(T element) { }
    }
    public abstract class ActorSubscriber : Akka.Actor.ActorBase
    {
        protected ActorSubscriber() { }
        public bool IsCanceled { get; }
        protected int RemainingRequested { get; }
        public abstract Akka.Streams.Actors.IRequestStrategy RequestStrategy { get; }
        public override void AroundPostRestart(System.Exception cause, object message) { }
        public override void AroundPostStop() { }
        public override void AroundPreRestart(System.Exception cause, object message) { }
        public override void AroundPreStart() { }
        protected override bool AroundReceive(Akka.Actor.Receive receive, object message) { }
        protected void Cancel() { }
        public static Reactive.Streams.ISubscriber<T> Create<T>(Akka.Actor.IActorRef @ref) { }
        protected void Request(long n) { }
    }
    public sealed class ActorSubscriberImpl<T> : Reactive.Streams.ISubscriber<T>
    {
        public ActorSubscriberImpl(Akka.Actor.IActorRef impl) { }
        public void OnComplete() { }
        public void OnError(System.Exception cause) { }
        public void OnNext(T element) { }
        public void OnNext(object element) { }
        public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
    }
    public sealed class ActorSubscriberState : Akka.Actor.ExtensionIdProvider<Akka.Streams.Actors.ActorSubscriberState>, Akka.Actor.IExtension
    {
        public static readonly Akka.Streams.Actors.ActorSubscriberState Instance;
        public override Akka.Streams.Actors.ActorSubscriberState CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.Streams.Actors.ActorSubscriberState.State Get(Akka.Actor.IActorRef actorRef) { }
        public Akka.Streams.Actors.ActorSubscriberState.State Remove(Akka.Actor.IActorRef actorRef) { }
        public void Set(Akka.Actor.IActorRef actorRef, Akka.Streams.Actors.ActorSubscriberState.State s) { }
        public sealed class State
        {
            public readonly bool IsCanceled;
            public readonly long Requested;
            public readonly Reactive.Streams.ISubscription Subscription;
            public State(Reactive.Streams.ISubscription subscription, long requested, bool isCanceled) { }
        }
    }
    public sealed class Cancel : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Actors.IActorPublisherMessage
    {
        public static readonly Akka.Streams.Actors.Cancel Instance;
    }
    public interface IActorPublisherMessage : Akka.Event.IDeadLetterSuppression { }
    public interface IActorSubscriberMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression { }
    public interface IRequestStrategy
    {
        int RequestDemand(int remainingRequested);
    }
    public enum LifecycleState
    {
        PreSubscriber = 0,
        Active = 1,
        Canceled = 2,
        Completed = 3,
        CompleteThenStop = 4,
        ErrorEmitted = 5,
    }
    public abstract class MaxInFlightRequestStrategy : Akka.Streams.Actors.IRequestStrategy
    {
        public readonly int Max;
        protected MaxInFlightRequestStrategy(int max) { }
        public virtual int BatchSize { get; }
        public abstract int InFlight { get; }
        public int RequestDemand(int remainingRequested) { }
    }
    public sealed class OnComplete : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Actors.IActorSubscriberMessage
    {
        public static readonly Akka.Streams.Actors.OnComplete Instance;
    }
    public sealed class OnError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Actors.IActorSubscriberMessage
    {
        public readonly System.Exception Cause;
        public OnError(System.Exception cause) { }
    }
    public sealed class OnErrorBlock
    {
        public readonly System.Exception Cause;
        public readonly bool Stop;
        public OnErrorBlock(System.Exception cause, bool stop) { }
    }
    public sealed class OnNext : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Actors.IActorSubscriberMessage
    {
        public readonly object Element;
        public OnNext(object element) { }
    }
    public sealed class OnSubscribe : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
    {
        public readonly Reactive.Streams.ISubscription Subscription;
        public OnSubscribe(Reactive.Streams.ISubscription subscription) { }
    }
    public sealed class OneByOneRequestStrategy : Akka.Streams.Actors.IRequestStrategy
    {
        public static readonly Akka.Streams.Actors.OneByOneRequestStrategy Instance;
        public int RequestDemand(int remainingRequested) { }
    }
    public sealed class Request : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Actors.IActorPublisherMessage
    {
        public readonly long Count;
        public Request(long count) { }
    }
    public sealed class Subscribe<T> : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
    {
        public readonly Reactive.Streams.ISubscriber<T> Subscriber;
        public Subscribe(Reactive.Streams.ISubscriber<T> subscriber) { }
    }
    public sealed class SubscriptionTimeoutExceeded : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Actors.IActorPublisherMessage
    {
        public static readonly Akka.Streams.Actors.SubscriptionTimeoutExceeded Instance;
    }
    public sealed class WatermarkRequestStrategy : Akka.Streams.Actors.IRequestStrategy
    {
        public readonly int HighWatermark;
        public readonly int LowWatermark;
        public WatermarkRequestStrategy(int highWatermark) { }
        public WatermarkRequestStrategy(int highWatermark, int lowWatermark) { }
        public int RequestDemand(int remainingRequested) { }
    }
    public sealed class ZeroRequestStrategy : Akka.Streams.Actors.IRequestStrategy
    {
        public static readonly Akka.Streams.Actors.ZeroRequestStrategy Instance;
        public int RequestDemand(int remainingRequested) { }
    }
}
namespace Akka.Streams.Dsl
{
    public class AccumulateWhileUnchanged<TElement, TProperty> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TElement, System.Collections.Generic.IEnumerable<TElement>>>
    {
        public AccumulateWhileUnchanged(System.Func<TElement, TProperty> propertyExtractor) { }
        public Akka.Streams.Inlet<TElement> In { get; }
        public Akka.Streams.Outlet<System.Collections.Generic.IEnumerable<TElement>> Out { get; }
        public override Akka.Streams.FlowShape<TElement, System.Collections.Generic.IEnumerable<TElement>> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public sealed class Balance<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanOutShape<T, T>>
    {
        public Balance(int outputPorts, bool waitForAllDownstreams = False) { }
        public Akka.Streams.Inlet<T> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.UniformFanOutShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Outlet<T> Out(int id) { }
        public override string ToString() { }
    }
    public class static BidiFlow
    {
        public static Akka.Streams.Dsl.BidiFlow<TIn, TIn, TOut, TOut, Akka.NotUsed> BidirectionalIdleTimeout<TIn, TOut>(System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.BidiFlow<TIn1, TOut1, TIn2, TOut2, Akka.NotUsed> FromFlows<TIn1, TOut1, TIn2, TOut2, TMat1, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn1, TOut1>, TMat1> flow1, Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn2, TOut2>, TMat2> flow2) { }
        public static Akka.Streams.Dsl.BidiFlow<TIn1, TOut1, TIn2, TOut2, TMat> FromFlowsMat<TIn1, TOut1, TIn2, TOut2, TMat1, TMat2, TMat>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn1, TOut1>, TMat1> flow1, Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn2, TOut2>, TMat2> flow2, System.Func<TMat1, TMat2, TMat> combine) { }
        public static Akka.Streams.Dsl.BidiFlow<TIn1, TOut1, TIn2, TOut2, Akka.NotUsed> FromFunction<TIn1, TOut1, TIn2, TOut2>(System.Func<TIn1, TOut1> outbound, System.Func<TIn2, TOut2> inbound) { }
        public static Akka.Streams.Dsl.BidiFlow<TIn1, TOut1, TIn2, TOut2, TMat> FromGraph<TIn1, TOut1, TIn2, TOut2, TMat>(Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>, TMat> graph) { }
    }
    public class BidiFlow<TIn1, TOut1, TIn2, TOut2, TMat> : Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>>, Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>, TMat>
    {
        public BidiFlow(Akka.Streams.Implementation.IModule module) { }
        public Akka.Streams.Implementation.IModule Module { get; }
        public Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2> Shape { get; }
        public Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>, TMat> Async() { }
        public Akka.Streams.Dsl.BidiFlow<TIn1, TOut12, TIn21, TOut2, TMat> Atop<TOut12, TIn21, TMat2>(Akka.Streams.Dsl.BidiFlow<TOut1, TOut12, TIn21, TIn2, TMat2> bidi) { }
        public Akka.Streams.Dsl.BidiFlow<TIn1, TOut12, TIn21, TOut2, TMat3> AtopMat<TOut12, TIn21, TMat2, TMat3>(Akka.Streams.Dsl.BidiFlow<TOut1, TOut12, TIn21, TIn2, TMat2> bidi, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.Dsl.Flow<TIn1, TOut2, TMat> Join<TMat2>(Akka.Streams.Dsl.Flow<TOut1, TIn2, TMat2> flow) { }
        public Akka.Streams.Dsl.Flow<TIn1, TOut2, TMat3> JoinMat<TMat2, TMat3>(Akka.Streams.Dsl.Flow<TOut1, TIn2, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>, TMat> Named(string name) { }
        public Akka.Streams.Dsl.BidiFlow<TIn2, TOut2, TIn1, TOut1, TMat> Reversed() { }
        public Akka.Streams.IGraph<Akka.Streams.BidiShape<TIn1, TOut1, TIn2, TOut2>, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class BroadcastHub
    {
        public BroadcastHub() { }
        public static Akka.Streams.Dsl.Sink<T, Akka.Streams.Dsl.Source<T, Akka.NotUsed>> Sink<T>(int bufferSize) { }
        public static Akka.Streams.Dsl.Sink<T, Akka.Streams.Dsl.Source<T, Akka.NotUsed>> Sink<T>() { }
    }
    public sealed class Broadcast<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanOutShape<T, T>>
    {
        public readonly Akka.Streams.Inlet<T> In;
        public Broadcast(int outputPorts, bool eagerCancel = False) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.UniformFanOutShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Outlet<T> Out(int id) { }
        public override string ToString() { }
    }
    public class static Concat
    {
        public static Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, T>, Akka.NotUsed> Create<T>(int inputPorts = 2) { }
    }
    public class Concat<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanInShape<TIn, TOut>>
        where TIn : TOut
    {
        public Concat(int inputPorts = 2) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.UniformFanInShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Inlet<TIn> In(int id) { }
    }
    public class DelayFlow<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public DelayFlow(System.Func<Akka.Streams.Dsl.IDelayStrategy<T>> strategySupplier) { }
        public DelayFlow(System.TimeSpan fixedDelay) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class static FileIO
    {
        public static Akka.Streams.Dsl.Source<Akka.IO.ByteString, System.Threading.Tasks.Task<Akka.Streams.IO.IOResult>> FromFile(System.IO.FileInfo f, int chunkSize = 8192, long startPosition = 0) { }
        public static Akka.Streams.Dsl.Sink<Akka.IO.ByteString, System.Threading.Tasks.Task<Akka.Streams.IO.IOResult>> ToFile(System.IO.FileInfo f, System.Nullable<System.IO.FileMode> fileMode = null, long startPosition = 0) { }
    }
    public class FixedDelay<T> : Akka.Streams.Dsl.IDelayStrategy<T>
    {
        public FixedDelay(System.TimeSpan delay) { }
        public System.TimeSpan NextDelay(T element) { }
    }
    public class static Flow
    {
        public static Akka.Streams.Dsl.Flow<T, T, Akka.NotUsed> Create<T>() { }
        public static Akka.Streams.Dsl.Flow<T, T, TMat> Create<T, TMat>() { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> FromFunction<TIn, TOut>(System.Func<TIn, TOut> function) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> FromGraph<TIn, TOut, TMat>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn, TOut>, TMat> graph) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> FromProcessor<TIn, TOut>(System.Func<Reactive.Streams.IProcessor<TIn, TOut>> factory) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> FromProcessorMaterialized<TIn, TOut, TMat>(System.Func<System.ValueTuple<Reactive.Streams.IProcessor<TIn, TOut>, TMat>> factory) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> FromSinkAndSource<TIn, TOut, TMat>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat> sink, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> source) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> FromSinkAndSource<TIn, TOut, TMat1, TMat2, TMat>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat1> sink, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat2> source, System.Func<TMat1, TMat2, TMat> combine) { }
        public static Akka.Streams.Dsl.Flow<T, T, Akka.NotUsed> Identity<T>() { }
        public static Akka.Streams.Dsl.Flow<T, T, TMat> Identity<T, TMat>() { }
    }
    public class static FlowOperations
    {
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Aggregate<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, TOut2> fold) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> AggregateAsync<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, System.Threading.Tasks.Task<TOut2>> fold) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> AlsoTo<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat> that) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat3> AlsoToMaterialized<TIn, TOut, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> that, System.Func<TMat, TMat2, TMat3> materializerFunction) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtxIn, TIn, TCtxOut, TOut, TMat> AsFlowWithContext<TCtxIn, TIn, TCtxOut, TOut, TMat, TIn2>(this Akka.Streams.Dsl.Flow<TIn2, TOut, TMat> flow, System.Func<TIn, TCtxIn, TIn2> collapseContext, System.Func<TOut, TCtxOut> extractContext) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> BackpressureTimeout<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Batch<TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, long max, System.Func<TOut, TOut2> seed, System.Func<TOut2, TOut, TOut2> aggregate) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> BatchWeighted<TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, long max, System.Func<TOut, long> costFunction, System.Func<TOut, TOut2> seed, System.Func<TOut2, TOut, TOut2> aggregate) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Buffer<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int size, Akka.Streams.OverflowStrategy strategy) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Collect<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, System.Func<TOut1, TOut2> collector) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> CompletionTimeout<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Concat<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> ConcatMany<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, System.Func<TOut1, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat>> flatten) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Conflate<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TOut, TOut, TOut> aggregate) { }
        public static Akka.Streams.Dsl.Flow<TIn, TSeed, TMat> ConflateWithSeed<TIn, TOut, TMat, TSeed>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TOut, TSeed> seed, System.Func<TSeed, TOut, TSeed> aggregate) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Delay<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan of, System.Nullable<Akka.Streams.DelayOverflowStrategy> strategy = null) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Detach<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Expand<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, System.Func<TOut1, System.Collections.Generic.IEnumerator<TOut2>> extrapolate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.Sink<TIn, TMat>> GroupBy<TIn, TOut, TMat, TKey>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int maxSubstreams, System.Func<TOut, TKey> groupingFunc) { }
        public static Akka.Streams.Dsl.Flow<TIn, System.Collections.Generic.IEnumerable<TOut>, TMat> Grouped<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int n) { }
        public static Akka.Streams.Dsl.Flow<TIn, System.Collections.Generic.IEnumerable<TOut>, TMat> GroupedWithin<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int n, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> IdleTimeout<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> InitialDelay<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan delay) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> InitialTimeout<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Flow<TIn, T2, TMat> Interleave<TIn, T1, T2, TMat>(this Akka.Streams.Dsl.Flow<TIn, T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other, int segmentSize)
            where T1 : T2 { }
        public static Akka.Streams.Dsl.Flow<TIn, T2, TMat3> InterleaveMaterialized<TIn, T1, T2, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Flow<TIn, T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat2> graph, int segmentSize, System.Func<TMat, TMat2, TMat3> combine)
            where T1 : T2 { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Intersperse<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, TOut start, TOut inject, TOut end) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Intersperse<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, TOut inject) { }
        public static Akka.Streams.Dsl.Flow<TIn, TInjected, TMat> KeepAlive<TIn, TOut, TInjected, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan timeout, System.Func<TInjected> injectElement)
            where TOut : TInjected { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Limit<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, long max) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> LimitWeighted<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, long max, System.Func<TOut, long> costFunc) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Log<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, string name, System.Func<TOut, object> extract = null, Akka.Event.ILoggingAdapter log = null) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Merge<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat> other, bool eagerComplete = False)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> MergeMany<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, int breadth, System.Func<TOut1, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat>> flatten) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat3> MergeMaterialized<TIn, TOut1, TOut2, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat2> that, System.Func<TMat, TMat2, TMat3> combine)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> MergeSorted<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other, System.Func<TOut, TOut, int> orderFunc) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> MergeSorted<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other)
            where TOut : System.IComparable<TOut> { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> MergeSorted<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other, System.Collections.Generic.IComparer<TOut> comparer) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat2> Monitor<TIn, TOut, TMat, TMat2>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TMat, Akka.Streams.IFlowMonitor, TMat2> combine) { }
        public static Akka.Streams.Dsl.Flow<T, T, TMat> OrElse<T, TMat>(this Akka.Streams.Dsl.Flow<T, T, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, TMat> secondary) { }
        public static Akka.Streams.Dsl.Flow<T, T, TMat3> OrElseMaterialized<T, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Flow<T, T, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, TMat2> secondary, System.Func<TMat, TMat2, TMat3> materializedFunction) { }
        public static Akka.Streams.Dsl.Flow<TIn, System.ValueTuple<System.Collections.Immutable.IImmutableList<TOut>, Akka.Streams.Dsl.Source<TOut, Akka.NotUsed>>, TMat> PrefixAndTail<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int n) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Prepend<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat> that)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Recover<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<System.Exception, Akka.Util.Option<TOut>> partialFunc) { }
        [System.ObsoleteAttribute("Use RecoverWithRetries instead. [1.1.2]")]
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> RecoverWith<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunc) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> RecoverWithRetries<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunc, int attempts) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Scan<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, TOut2> scan) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> ScanAsync<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, System.Threading.Tasks.Task<TOut2>> scan) { }
        public static Akka.Streams.Dsl.Flow<T, TOut, TMat> Select<T, TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<T, TIn, TMat> flow, System.Func<TIn, TOut> mapper) { }
        public static Akka.Streams.Dsl.Flow<T, TOut, TMat> SelectAsync<T, TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<T, TIn, TMat> flow, int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> asyncMapper) { }
        public static Akka.Streams.Dsl.Flow<T, TOut, TMat> SelectAsyncUnordered<T, TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<T, TIn, TMat> flow, int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> asyncMapper) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> SelectError<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<System.Exception, System.Exception> selector) { }
        public static Akka.Streams.Dsl.Flow<T, TOut, TMat> SelectMany<T, TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<T, TIn, TMat> flow, System.Func<TIn, System.Collections.Generic.IEnumerable<TOut>> mapConcater) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Skip<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, long n) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> SkipWhile<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> SkipWithin<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan duration) { }
        public static Akka.Streams.Dsl.Flow<TIn, System.Collections.Generic.IEnumerable<TOut>, TMat> Sliding<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int n, int step = 1) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.Sink<TIn, TMat>> SplitAfter<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.SubstreamCancelStrategy substreamCancelStrategy, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.Sink<TIn, TMat>> SplitAfter<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.Sink<TIn, TMat>> SplitWhen<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.SubstreamCancelStrategy substreamCancelStrategy, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.Sink<TIn, TMat>> SplitWhen<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.Flow<T, TOut, TMat> StatefulSelectMany<T, TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<T, TIn, TMat> flow, System.Func<System.Func<TIn, System.Collections.Generic.IEnumerable<TOut>>> mapConcaterFactory) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Sum<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TOut, TOut, TOut> reduce) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Take<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, long n) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> TakeWhile<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Predicate<TOut> predicate, bool inclusive = False) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> TakeWithin<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.TimeSpan duration) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Throttle<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int elements, System.TimeSpan per, int maximumBurst, Akka.Streams.ThrottleMode mode) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Throttle<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int cost, System.TimeSpan per, int maximumBurst, System.Func<TOut, int> calculateCost, Akka.Streams.ThrottleMode mode) { }
        [System.ObsoleteAttribute("Use Via(GraphStage) instead. [1.1.2]")]
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Transform<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut1, TMat> flow, System.Func<Akka.Streams.Stage.IStage<TOut1, TOut2>> stageFactory) { }
        public static Akka.Streams.Dsl.Flow<T, T, TMat> Watch<T, TMat>(this Akka.Streams.Dsl.Flow<T, T, TMat> flow, Akka.Actor.IActorRef actorRef) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat2> WatchTermination<TIn, TOut, TMat, TMat2>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TMat, System.Threading.Tasks.Task, TMat2> materializerFunction)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Where<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> WhereNot<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.Flow<TIn, System.ValueTuple<T1, T2>, TMat> Zip<TIn, T1, T2, TMat>(this Akka.Streams.Dsl.Flow<TIn, T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other) { }
        public static Akka.Streams.Dsl.Flow<TIn, T3, TMat> ZipWith<TIn, T1, T2, T3, TMat>(this Akka.Streams.Dsl.Flow<TIn, T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other, System.Func<T1, T2, T3> combine) { }
        public static Akka.Streams.Dsl.Flow<TIn, System.ValueTuple<TOut, long>, TMat> ZipWithIndex<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow) { }
    }
    public class static FlowWithContext
    {
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TIn, Akka.NotUsed> Create<TCtx, TIn>() { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtxIn, TIn, TCtxOut, TOut, TMat> From<TCtxIn, TIn, TCtxOut, TOut, TMat>(Akka.Streams.Dsl.Flow<System.ValueTuple<TIn, TCtxIn>, System.ValueTuple<TOut, TCtxOut>, TMat> flow) { }
    }
    public class static FlowWithContextOperations
    {
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut2, TMat> Collect<TCtx, TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<TOut, TOut2> fn)
            where TOut2 :  class { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, System.Collections.Generic.IReadOnlyList<TCtx>, System.Collections.Generic.IReadOnlyList<TOut>, TMat> Grouped<TCtx, TIn, TOut, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, int n) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut2, TMat> Select<TCtx, TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<TOut, TOut2> fn) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut2, TMat> SelectAsync<TCtx, TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, int parallelism, System.Func<TOut, System.Threading.Tasks.Task<TOut2>> fn) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut2, TMat> SelectConcat<TCtx, TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<TOut, System.Collections.Generic.IEnumerable<TOut2>> fn) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx2, TOut, TMat> SelectContext<TCtx, TIn, TCtx2, TOut, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<TCtx, TCtx2> mapContext) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, System.Collections.Generic.IReadOnlyList<TCtx>, System.Collections.Generic.IReadOnlyList<TOut>, TMat> Sliding<TCtx, TIn, TOut, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, int n, int step = 1) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut2, TMat> StatefulSelectConcat<TCtx, TIn, TOut, TOut2, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<System.Func<TOut, System.Collections.Generic.IEnumerable<TOut2>>> fn) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut, TMat> Where<TCtx, TIn, TOut, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.FlowWithContext<TCtx, TIn, TCtx, TOut, TMat> WhereNot<TCtx, TIn, TOut, TMat>(this Akka.Streams.Dsl.FlowWithContext<TCtx flow, System.Func<TOut, bool> predicate) { }
    }
    public sealed class FlowWithContext<TCtxIn, TIn, TCtxOut, TOut, TMat> : Akka.Streams.GraphDelegate<Akka.Streams.FlowShape<System.ValueTuple<TIn, TCtxIn>, System.ValueTuple<TOut, TCtxOut>>, TMat>
    {
        public Akka.Streams.Dsl.Flow<System.ValueTuple<TIn, TCtxIn>, System.ValueTuple<TOut, TCtxOut>, TMat> AsFlow() { }
        public Akka.Streams.Dsl.FlowWithContext<TCtxIn, TIn, TCtx2, TOut2, TMat> Via<TCtx2, TOut2, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TOut, TCtxOut>, System.ValueTuple<TOut2, TCtx2>>, TMat2> viaFlow) { }
        public Akka.Streams.Dsl.FlowWithContext<TCtxIn, TIn, TCtx2, TOut2, TMat3> ViaMaterialized<TCtx2, TOut2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TOut, TCtxOut>, System.ValueTuple<TOut2, TCtx2>>, TMat2> viaFlow, System.Func<TMat, TMat2, TMat3> combine) { }
    }
    public sealed class Flow<TIn, TOut, TMat> : Akka.Streams.Dsl.IFlow<TOut, TMat>, Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn, TOut>>, Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn, TOut>, TMat>
    {
        public Akka.Streams.Implementation.IModule Module { get; }
        public Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut2, TMat> Ask<TOut2>(Akka.Actor.IActorRef actorRef, System.TimeSpan timeout, int parallelism = 2) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Async() { }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat3> ConcatMaterialized<TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat2> that, System.Func<TMat, TMat2, TMat3> materializedFunction) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat> Join<TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, TIn>, TMat2> flow) { }
        public Akka.Streams.Dsl.Flow<TIn2, TOut2, TMat> Join<TIn2, TOut2, TMat2>(Akka.Streams.IGraph<Akka.Streams.BidiShape<TOut, TOut2, TIn2, TIn>, TMat2> bidi) { }
        public Akka.Streams.Dsl.Flow<TIn2, TOut2, TMatRes> JoinMaterialized<TIn2, TOut2, TMat2, TMatRes>(Akka.Streams.IGraph<Akka.Streams.BidiShape<TOut, TOut2, TIn2, TIn>, TMat2> bidi, System.Func<TMat, TMat2, TMatRes> combine) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat3> JoinMaterialized<TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, TIn>, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> mapFunc) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Named(string name) { }
        public System.ValueTuple<TMat1, TMat2> RunWith<TMat1, TMat2>(Akka.Streams.IGraph<Akka.Streams.SourceShape<TIn>, TMat1> source, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink, Akka.Streams.IMaterializer materializer) { }
        public Akka.Streams.Dsl.Sink<TIn, TMat> To<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink) { }
        public Akka.Streams.Dsl.Sink<TIn, TMat3> ToMaterialized<TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.Dsl.IRunnableGraph<Reactive.Streams.IProcessor<TIn, TOut>> ToProcessor() { }
        public override string ToString() { }
        public Akka.Streams.Dsl.Flow<TIn, T2, TMat> Via<T2, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut2, TMat3> ViaMaterialized<TOut2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, TOut2>, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class static ForwardOps
    {
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> To<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, TMat> ops, Akka.Streams.Inlet<TIn> inlet)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> To<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, TMat> ops, Akka.Streams.SinkShape<TIn> sink)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> To<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, TMat> ops, Akka.Streams.FlowShape<TIn, TOut> flow)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> To<TIn, TOut, TMat, TMat2>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, TMat> ops, Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat2> sink)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> To<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut1, TMat> ops, Akka.Streams.UniformFanInShape<TIn, TOut2> junction)
            where TIn : TOut1 { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> To<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut1, TMat> ops, Akka.Streams.UniformFanOutShape<TIn, TOut2> junction)
            where TIn : TOut1 { }
        public static Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut2, TMat> Via<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut1, TMat> ops, Akka.Streams.FlowShape<TIn, TOut2> flow)
            where TIn : TOut1 { }
        public static Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut2, TMat> Via<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut1, TMat> ops, Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn, TOut2>, Akka.NotUsed> flow)
            where TIn : TOut1 { }
        public static Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut2, TMat> Via<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut1, TMat> ops, Akka.Streams.UniformFanInShape<TIn, TOut2> junction)
            where TIn : TOut1 { }
        public static Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut2, TMat> Via<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut1, TMat> ops, Akka.Streams.UniformFanOutShape<TIn, TOut2> junction)
            where TIn : TOut1 { }
    }
    public class static Framing
    {
        public static Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> Delimiter(Akka.IO.ByteString delimiter, int maximumFrameLength, bool allowTruncation = False) { }
        public static Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> LengthField(int fieldLength, int maximumFramelength, int fieldOffset = 0, Akka.IO.ByteOrder byteOrder = 1) { }
        public static Akka.Streams.Dsl.BidiFlow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> SimpleFramingProtocol(int maximumMessageLength) { }
        public static Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> SimpleFramingProtocolDecoder(int maximumMessageLength) { }
        public static Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> SimpleFramingProtocolEncoder(int maximumMessageLength) { }
        public class FramingException : System.Exception
        {
            public FramingException(string message) { }
        }
    }
    public class static GraphDsl
    {
        public static Akka.Streams.IGraph<TShape, Akka.NotUsed> Create<TShape>(System.Func<Akka.Streams.Dsl.GraphDsl.Builder<Akka.NotUsed>, TShape> buildBlock)
            where TShape : Akka.Streams.Shape { }
        public static Akka.Streams.IGraph<TShapeOut, TMat> Create<TShapeOut, TMat, TShape1>(Akka.Streams.IGraph<TShape1, TMat> g1, System.Func<Akka.Streams.Dsl.GraphDsl.Builder<TMat>, TShape1, TShapeOut> buildBlock)
            where TShapeOut : Akka.Streams.Shape
            where TShape1 : Akka.Streams.Shape { }
        public static Akka.Streams.IGraph<TShapeOut, TMatOut> Create<TShapeOut, TMatOut, TMat0, TMat1, TShape0, TShape1>(Akka.Streams.IGraph<TShape0, TMat0> g0, Akka.Streams.IGraph<TShape1, TMat1> g1, System.Func<TMat0, TMat1, TMatOut> combineMaterializers, System.Func<Akka.Streams.Dsl.GraphDsl.Builder<TMatOut>, TShape0, TShape1, TShapeOut> buildBlock)
            where TShapeOut : Akka.Streams.Shape
            where TShape0 : Akka.Streams.Shape
            where TShape1 : Akka.Streams.Shape { }
        public static Akka.Streams.IGraph<TShapeOut, TMatOut> Create<TShapeOut, TMatOut, TMat0, TMat1, TMat2, TShape0, TShape1, TShape2>(Akka.Streams.IGraph<TShape0, TMat0> g0, Akka.Streams.IGraph<TShape1, TMat1> g1, Akka.Streams.IGraph<TShape2, TMat2> g2, System.Func<TMat0, TMat1, TMat2, TMatOut> combineMaterializers, System.Func<Akka.Streams.Dsl.GraphDsl.Builder<TMatOut>, TShape0, TShape1, TShape2, TShapeOut> buildBlock)
            where TShapeOut : Akka.Streams.Shape
            where TShape0 : Akka.Streams.Shape
            where TShape1 : Akka.Streams.Shape
            where TShape2 : Akka.Streams.Shape { }
        public static Akka.Streams.IGraph<TShapeOut, TMatOut> Create<TShapeOut, TMatOut, TMat0, TMat1, TMat2, TMat3, TShape0, TShape1, TShape2, TShape3>(Akka.Streams.IGraph<TShape0, TMat0> g0, Akka.Streams.IGraph<TShape1, TMat1> g1, Akka.Streams.IGraph<TShape2, TMat2> g2, Akka.Streams.IGraph<TShape3, TMat3> g3, System.Func<TMat0, TMat1, TMat2, TMat3, TMatOut> combineMaterializers, System.Func<Akka.Streams.Dsl.GraphDsl.Builder<TMatOut>, TShape0, TShape1, TShape2, TShape3, TShapeOut> buildBlock)
            where TShapeOut : Akka.Streams.Shape
            where TShape0 : Akka.Streams.Shape
            where TShape1 : Akka.Streams.Shape
            where TShape2 : Akka.Streams.Shape
            where TShape3 : Akka.Streams.Shape { }
        public static Akka.Streams.IGraph<TShapeOut, TMatOut> Create<TShapeOut, TMatOut, TMat0, TMat1, TMat2, TMat3, TMat4, TShape0, TShape1, TShape2, TShape3, TShape4>(Akka.Streams.IGraph<TShape0, TMat0> g0, Akka.Streams.IGraph<TShape1, TMat1> g1, Akka.Streams.IGraph<TShape2, TMat2> g2, Akka.Streams.IGraph<TShape3, TMat3> g3, Akka.Streams.IGraph<TShape4, TMat4> g4, System.Func<TMat0, TMat1, TMat2, TMat3, TMat4, TMatOut> combineMaterializers, System.Func<Akka.Streams.Dsl.GraphDsl.Builder<TMatOut>, TShape0, TShape1, TShape2, TShape3, TShape4, TShapeOut> buildBlock)
            where TShapeOut : Akka.Streams.Shape
            where TShape0 : Akka.Streams.Shape
            where TShape1 : Akka.Streams.Shape
            where TShape2 : Akka.Streams.Shape
            where TShape3 : Akka.Streams.Shape
            where TShape4 : Akka.Streams.Shape { }
        public static Akka.Streams.IGraph<TShape, TMat> CreateMaterialized<TShape, TMat>(System.Func<Akka.Streams.Dsl.GraphDsl.Builder<TMat>, TShape> buildBlock)
            where TShape : Akka.Streams.Shape { }
        public sealed class Builder<T>
        {
            public Akka.Streams.Outlet<T> MaterializedValue { get; }
            public Akka.Streams.Implementation.IModule Module { get; }
            public TShape Add<TShape, TMat>(Akka.Streams.IGraph<TShape, TMat> graph)
                where TShape : Akka.Streams.Shape { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TOut>(Akka.Streams.Outlet<TOut> outlet) { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TOut>(Akka.Streams.SourceShape<TOut> source) { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TOut>(Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, T> source) { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TIn, TOut>(Akka.Streams.FlowShape<TIn, TOut> flow) { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TIn, TOut>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn, TOut>, T> flow) { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TIn, TOut>(Akka.Streams.UniformFanInShape<TIn, TOut> fanIn) { }
            public Akka.Streams.Dsl.GraphDsl.ForwardOps<TOut, T> From<TIn, TOut>(Akka.Streams.UniformFanOutShape<TIn, TOut> fanOut) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn>(Akka.Streams.Inlet<TIn> inlet) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn>(Akka.Streams.SinkShape<TIn> sink) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn, TMat>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat> sink) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn, TOut, TMat>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TIn, TOut>, TMat> flow) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn, TOut>(Akka.Streams.FlowShape<TIn, TOut> flow) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn, TOut>(Akka.Streams.UniformFanOutShape<TIn, TOut> fanOut) { }
            public Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, T> To<TIn, TOut>(Akka.Streams.UniformFanInShape<TIn, TOut> fanOut) { }
        }
        public sealed class ForwardOps<TOut, TMat>
        {
            public ForwardOps(Akka.Streams.Dsl.GraphDsl.Builder<TMat> builder, Akka.Streams.Outlet<TOut> outlet) { }
            public Akka.Streams.Outlet<TOut> Out { get; }
        }
        public sealed class ReverseOps<TIn, TMat>
        {
            public ReverseOps(Akka.Streams.Dsl.GraphDsl.Builder<TMat> builder, Akka.Streams.Inlet<TIn> inlet) { }
            public Akka.Streams.Inlet<TIn> In { get; }
        }
    }
    public interface IDelayStrategy<T>
    {
        System.TimeSpan NextDelay(T element);
    }
    public interface IFlow<TOut, out TMat>
    {
        Akka.Streams.Dsl.IFlow<TOut, TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> mapFunc);
        Akka.Streams.Dsl.IFlow<T, TMat> Via<T, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T>, TMat2> flow);
        Akka.Streams.Dsl.IFlow<T2, TMat3> ViaMaterialized<T2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine);
    }
    public interface IRunnableGraph<out TMat> : Akka.Streams.IGraph<Akka.Streams.ClosedShape>, Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat>
    {
        Akka.Streams.Dsl.IRunnableGraph<TMat> AddAttributes(Akka.Streams.Attributes attributes);
        Akka.Streams.Dsl.IRunnableGraph<TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> func);
        Akka.Streams.Dsl.IRunnableGraph<TMat> Named(string name);
        TMat Run(Akka.Streams.IMaterializer materializer);
        Akka.Streams.Dsl.IRunnableGraph<TMat> WithAttributes(Akka.Streams.Attributes attributes);
    }
    public interface IUnzipWithCreator<out TIn, in TOut, out T>
    {
        T Create(System.Func<TIn, TOut> unzipper);
    }
    public interface IValveSwitch
    {
        System.Threading.Tasks.Task<bool> Flip(Akka.Streams.Dsl.SwitchMode mode);
        System.Threading.Tasks.Task<Akka.Streams.Dsl.SwitchMode> GetMode();
    }
    public class static Interleave
    {
        public static Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, T>, Akka.NotUsed> Create<T>(int inputPorts, int segmentSize, bool eagerClose = False) { }
    }
    public sealed class Interleave<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanInShape<TIn, TOut>>
        where TIn : TOut
    {
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.UniformFanInShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Inlet<TIn> In(int id) { }
        public override string ToString() { }
    }
    public class static IntervalBasedRateLimiter
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.IGraph<Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>>, Akka.NotUsed> Create<T>(System.TimeSpan minInterval, int maxBatchSize) { }
    }
    public class static JsonFraming
    {
        public static Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> ObjectScanner(int maximumObjectLength) { }
    }
    public class static Keep
    {
        public static System.ValueTuple<TLeft, TRight> Both<TLeft, TRight>(TLeft left, TRight right) { }
        public static bool IsLeft<T1, T2, T3>(System.Func<T1, T2, T3> fn) { }
        public static bool IsRight<T1, T2, T3>(System.Func<T1, T2, T3> fn) { }
        public static TLeft Left<TLeft, TRight>(TLeft left, TRight right) { }
        public static Akka.NotUsed None<TLeft, TRight>(TLeft left, TRight right) { }
        public static TRight Right<TLeft, TRight>(TLeft left, TRight right) { }
    }
    public class KeepAliveConcat<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, T>>
    {
        public KeepAliveConcat(int keepAliveFailoverSize, System.TimeSpan interval, System.Func<T, System.Collections.Generic.IEnumerable<T>> extrapolate) { }
        public Akka.Streams.Inlet<T> In { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public override Akka.Streams.FlowShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class LastElement<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.FlowShape<T, T>, System.Threading.Tasks.Task<Akka.Util.Option<T>>>
    {
        public LastElement() { }
        public Akka.Streams.Inlet<T> In { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public override Akka.Streams.FlowShape<T, T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<Akka.Util.Option<T>>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class LinearIncreasingDelay<T> : Akka.Streams.Dsl.IDelayStrategy<T>
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public LinearIncreasingDelay(System.TimeSpan increaseStep, System.Func<T, bool> needsIncrease, System.TimeSpan initialDelay, System.TimeSpan maxDelay) { }
        public System.TimeSpan NextDelay(T element) { }
    }
    public class static MergeHub
    {
        public static Akka.Streams.Dsl.Source<T, Akka.Streams.Dsl.Sink<T, Akka.NotUsed>> Source<T>(int perProducerBufferSize) { }
        public static Akka.Streams.Dsl.Source<T, Akka.Streams.Dsl.Sink<T, Akka.NotUsed>> Source<T>() { }
        public sealed class ProducerFailed : System.Exception
        {
            public ProducerFailed(string message, System.Exception cause) { }
        }
    }
    public sealed class MergePreferred<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.Dsl.MergePreferred<T>.MergePreferredShape>
    {
        public MergePreferred(int secondaryPorts, bool eagerClose = False) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public Akka.Streams.Inlet<T> Preferred { get; }
        public override Akka.Streams.Dsl.MergePreferred<T>.MergePreferredShape Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Inlet<T> In(int id) { }
        public sealed class MergePreferredShape<T> : Akka.Streams.UniformFanInShape<T, T>
        {
            public MergePreferredShape(int secondaryPorts, Akka.Streams.FanInShape<T>.IInit init) { }
            public MergePreferredShape(int secondaryPorts, string name) { }
            public Akka.Streams.Inlet<T> Preferred { get; }
            protected override Akka.Streams.FanInShape<T> Construct(Akka.Streams.FanInShape<T>.IInit init) { }
        }
    }
    public sealed class MergePrioritized<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanInShape<T, T>>
    {
        public MergePrioritized(System.Collections.Generic.IEnumerable<int> priorities, bool eagerComplete = False) { }
        public System.Collections.Generic.IReadOnlyList<Akka.Streams.Inlet<T>> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public override Akka.Streams.UniformFanInShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public sealed class MergeSorted<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<T, T, T>>
    {
        public readonly Akka.Streams.Inlet<T> Left;
        public readonly Akka.Streams.Outlet<T> Out;
        public readonly Akka.Streams.Inlet<T> Right;
        public MergeSorted(System.Func<T, T, int> compare) { }
        public override Akka.Streams.FanInShape<T, T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public sealed class Merge<T> : Akka.Streams.Dsl.Merge<T, T>
    {
        public Merge(int inputPorts, bool eagerComplete = False) { }
    }
    public class Merge<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanInShape<TIn, TOut>>
        where TIn : TOut
    {
        public Merge(int inputPorts, bool eagerComplete = False) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.UniformFanInShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Inlet<TIn> In(int id) { }
        public override string ToString() { }
    }
    public class static One2OneBidiFlow
    {
        public static Akka.Streams.Dsl.BidiFlow<TIn, TIn, TOut, TOut, Akka.NotUsed> Apply<TIn, TOut>(int maxPending) { }
    }
    public class One2OneBidi<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.BidiShape<TIn, TIn, TOut, TOut>>
    {
        public One2OneBidi(int maxPending) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.BidiShape<TIn, TIn, TOut, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public class static OrElse
    {
        public static Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, T>, Akka.NotUsed> Create<T>() { }
    }
    public sealed class OrElse<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanInShape<T, T>>
    {
        public OrElse() { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public Akka.Streams.Inlet<T> Primary { get; }
        public Akka.Streams.Inlet<T> Secondary { get; }
        public override Akka.Streams.UniformFanInShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public class OutputTruncationException : System.Exception
    {
        public OutputTruncationException() { }
    }
    public class static PagedSource
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> Create<T, TKey>(TKey firstKey, System.Func<TKey, System.Threading.Tasks.Task<Akka.Streams.Dsl.PagedSource.Page<T, TKey>>> pageFactory) { }
        public class Page<T, TKey>
        {
            public Page(System.Collections.Generic.IEnumerable<T> items, Akka.Util.Option<TKey> nextKey) { }
            public System.Collections.Generic.IEnumerable<T> Items { get; }
            public Akka.Util.Option<TKey> NextKey { get; }
        }
    }
    public class static PartitionHub
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Sink<T, Akka.Streams.Dsl.Source<T, Akka.NotUsed>> Sink<T>(System.Func<int, T, int> partitioner, int startAfterNrOfConsumers, int bufferSize = 256) { }
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Sink<T, Akka.Streams.Dsl.Source<T, Akka.NotUsed>> StatefulSink<T>(System.Func<System.Func<Akka.Streams.Dsl.PartitionHub.IConsumerInfo, T, long>> partitioner, int startAfterNrOfConsumers, int bufferSize = 256) { }
        [Akka.Annotations.ApiMayChangeAttribute()]
        public interface IConsumerInfo
        {
            System.Collections.Immutable.ImmutableArray<long> ConsumerIds { get; }
            int Size { get; }
            long ConsumerByIndex(int index);
            int QueueSize(long consumerId);
        }
    }
    public sealed class PartitionOutOfBoundsException : System.Exception
    {
        public PartitionOutOfBoundsException(string message) { }
    }
    public class PartitionWith<TIn, TOut0, TOut1> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, TOut0, TOut1>>
    {
        public PartitionWith(System.Func<TIn, Akka.Util.Either<TOut0, TOut1>> partitionWith) { }
        public override Akka.Streams.FanOutShape<TIn, TOut0, TOut1> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public sealed class Partition<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanOutShape<T, T>>
    {
        public readonly Akka.Streams.Inlet<T> In;
        public Partition(int outputPorts, System.Func<T, int> partitioner) { }
        public override Akka.Streams.UniformFanOutShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Outlet<T> Out(int id) { }
        public override string ToString() { }
    }
    public class Pulse<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Pulse(System.TimeSpan interval, bool initiallyOpen = False) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class static RestartFlow
    {
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> OnFailuresWithBackoff<TIn, TOut, TMat>(System.Func<Akka.Streams.Dsl.Flow<TIn, TOut, TMat>> flowFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> OnFailuresWithBackoff<TIn, TOut, TMat>(System.Func<Akka.Streams.Dsl.Flow<TIn, TOut, TMat>> flowFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxRestarts) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> WithBackoff<TIn, TOut, TMat>(System.Func<Akka.Streams.Dsl.Flow<TIn, TOut, TMat>> flowFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, Akka.NotUsed> WithBackoff<TIn, TOut, TMat>(System.Func<Akka.Streams.Dsl.Flow<TIn, TOut, TMat>> flowFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxRestarts) { }
    }
    public class static RestartSink
    {
        public static Akka.Streams.Dsl.Sink<T, Akka.NotUsed> WithBackoff<T, TMat>(System.Func<Akka.Streams.Dsl.Sink<T, TMat>> sinkFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Streams.Dsl.Sink<T, Akka.NotUsed> WithBackoff<T, TMat>(System.Func<Akka.Streams.Dsl.Sink<T, TMat>> sinkFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxRestarts) { }
    }
    public class static RestartSource
    {
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> OnFailuresWithBackoff<T, TMat>(System.Func<Akka.Streams.Dsl.Source<T, TMat>> sourceFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> OnFailuresWithBackoff<T, TMat>(System.Func<Akka.Streams.Dsl.Source<T, TMat>> sourceFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxRestarts) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> WithBackoff<T, TMat>(System.Func<Akka.Streams.Dsl.Source<T, TMat>> sourceFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> WithBackoff<T, TMat>(System.Func<Akka.Streams.Dsl.Source<T, TMat>> sourceFactory, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor, int maxRestarts) { }
    }
    public class static Retry
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TIn, TState>, System.ValueTuple<Akka.Util.Result<TOut>, TState>>, TMat> Concat<TIn, TState, TOut, TMat>(long limit, Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TIn, TState>, System.ValueTuple<Akka.Util.Result<TOut>, TState>>, TMat> flow, System.Func<TState, System.Collections.Generic.IEnumerable<System.ValueTuple<TIn, TState>>> retryWith) { }
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TIn, TState>, System.ValueTuple<Akka.Util.Result<TOut>, TState>>, TMat> Create<TIn, TState, TOut, TMat>(Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TIn, TState>, System.ValueTuple<Akka.Util.Result<TOut>, TState>>, TMat> flow, System.Func<TState, Akka.Util.Option<System.ValueTuple<TIn, TState>>> retryWith) { }
    }
    public class static ReverseOps
    {
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> From<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.Outlet<TOut> outlet)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> From<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.SourceShape<TOut> source)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> From<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> source)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> From<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.FlowShape<TIn, TOut> flow)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> From<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.UniformFanInShape<TIn, TOut> junction)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.Builder<TMat> From<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.UniformFanOutShape<TOut1, TOut2> junction)
            where TIn : TOut2 { }
        public static Akka.Streams.Dsl.GraphDsl.ReverseOps<TOut1, TMat> Via<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.FlowShape<TOut1, TOut2> flow)
            where TIn : TOut2 { }
        public static Akka.Streams.Dsl.GraphDsl.ReverseOps<TOut1, TMat> Via<TIn, TOut1, TOut2, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut1, TOut2>, TMat> flow)
            where TIn : TOut2 { }
        public static Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> Via<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.UniformFanInShape<TIn, TOut> junction)
            where TIn : TOut { }
        public static Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> Via<TIn, TOut, TMat>(this Akka.Streams.Dsl.GraphDsl.ReverseOps<TIn, TMat> ops, Akka.Streams.UniformFanOutShape<TIn, TOut> junction)
            where TIn : TOut { }
    }
    public class static RunnableGraph
    {
        public static Akka.Streams.Dsl.RunnableGraph<TMat> FromGraph<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> g) { }
    }
    public sealed class RunnableGraph<TMat> : Akka.Streams.Dsl.IRunnableGraph<TMat>, Akka.Streams.IGraph<Akka.Streams.ClosedShape>, Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat>
    {
        public RunnableGraph(Akka.Streams.Implementation.IModule module) { }
        public Akka.Streams.Implementation.IModule Module { get; }
        public Akka.Streams.ClosedShape Shape { get; }
        public Akka.Streams.Dsl.IRunnableGraph<TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat> Async() { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> func) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat> Named(string name) { }
        public TMat Run(Akka.Streams.IMaterializer materializer) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class Sample<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, T>>
    {
        public Sample(int nth) { }
        public Sample(System.Func<int> next) { }
        public Akka.Streams.Inlet<T> In { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public override Akka.Streams.FlowShape<T, T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public static Akka.Streams.Dsl.Sample<T> Random(int maxStep = 1000) { }
    }
    public class static Sink
    {
        public static Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> ActorRef<TIn>(Akka.Actor.IActorRef actorRef, object onCompleteMessage) { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> ActorRefWithAck<TIn>(Akka.Actor.IActorRef actorRef, object onInitMessage, object ackMessage, object onCompleteMessage, System.Func<System.Exception, object> onFailureMessage = null) { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.Actor.IActorRef> ActorSubscriber<TIn>(Akka.Actor.Props props) { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TOut>> Aggregate<TIn, TOut>(TOut zero, System.Func<TOut, TIn, TOut> aggregate) { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TOut>> AggregateAsync<TIn, TOut>(TOut zero, System.Func<TOut, TIn, System.Threading.Tasks.Task<TOut>> aggregate) { }
        public static Akka.Streams.Dsl.Sink<T, System.IObservable<T>> AsObservable<T>() { }
        public static Akka.Streams.Dsl.Sink<TIn, Reactive.Streams.IPublisher<TIn>> AsPublisher<TIn>(bool fanout) { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> Cancelled<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> Combine<TIn, TOut, TMat>(System.Func<int, Akka.Streams.IGraph<Akka.Streams.UniformFanOutShape<TIn, TOut>, TMat>> strategy, Akka.Streams.Dsl.Sink<TOut, Akka.NotUsed> first, Akka.Streams.Dsl.Sink<TOut, Akka.NotUsed> second, params Akka.Streams.Dsl.Sink<, >[] rest) { }
        public static Akka.Streams.Dsl.Sink<TIn, object> Create<TIn>(Reactive.Streams.ISubscriber<TIn> subscriber) { }
        public static Akka.Streams.Dsl.Sink<TIn, Reactive.Streams.IPublisher<TIn>> FanoutPublisher<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TIn>> First<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TIn>> FirstOrDefault<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task> ForEach<TIn>(System.Action<TIn> action) { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task> ForEachParallel<TIn>(int parallelism, System.Action<TIn> action) { }
        public static Akka.Streams.Dsl.Sink<TIn, TMat> FromGraph<TIn, TMat>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat> graph) { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> FromSubscriber<TIn>(Reactive.Streams.ISubscriber<TIn> subscriber) { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task> Ignore<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TIn>> Last<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TIn>> LastOrDefault<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TMat>> LazySink<TIn, TMat>(System.Func<TIn, System.Threading.Tasks.Task<Akka.Streams.Dsl.Sink<TIn, TMat>>> sinkFactory, System.Func<TMat> fallback) { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed> OnComplete<TIn>(System.Action success, System.Action<System.Exception> failure) { }
        public static Akka.Streams.Dsl.Sink<TIn, Reactive.Streams.IPublisher<TIn>> Publisher<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, Akka.Streams.ISinkQueue<TIn>> Queue<TIn>() { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<TIn>>> Seq<TIn>() { }
        public static Akka.Streams.SinkShape<T> Shape<T>(string name) { }
        public static Akka.Streams.Dsl.Sink<TIn, System.Threading.Tasks.Task<TIn>> Sum<TIn>(System.Func<TIn, TIn, TIn> reduce) { }
        public static Akka.Streams.Dsl.Sink<TIn, TMat> Wrap<TIn, TMat>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat> graph) { }
    }
    public sealed class Sink<TIn, TMat> : Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>>, Akka.Streams.IGraph<Akka.Streams.SinkShape<TIn>, TMat>
    {
        public Sink(Akka.Streams.Implementation.IModule module) { }
        public Akka.Streams.Implementation.IModule Module { get; }
        public Akka.Streams.SinkShape<TIn> Shape { get; }
        public Akka.Streams.Dsl.Sink<TIn, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.Dsl.Sink<TIn, TMat> Async() { }
        public Akka.Streams.Dsl.Sink<TIn2, TMat> ContraMap<TIn2>(System.Func<TIn2, TIn> function) { }
        public Akka.Streams.Dsl.Sink<TIn, TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> fn) { }
        public Akka.Streams.Dsl.Sink<TIn, TMat> Named(string name) { }
        public System.ValueTuple<TMat, Akka.Streams.Dsl.Sink<TIn, Akka.NotUsed>> PreMaterialize(Akka.Streams.IMaterializer materializer) { }
        public TMat2 RunWith<TMat2>(Akka.Streams.IGraph<Akka.Streams.SourceShape<TIn>, TMat2> source, Akka.Streams.IMaterializer materializer) { }
        public override string ToString() { }
        public Akka.Streams.Dsl.Sink<TIn, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class static Source
    {
        public static Akka.Streams.Dsl.Source<T, Akka.Actor.IActorRef> ActorPublisher<T>(Akka.Actor.Props props) { }
        public static Akka.Streams.Dsl.Source<T, Akka.Actor.IActorRef> ActorRef<T>(int bufferSize, Akka.Streams.OverflowStrategy overflowStrategy) { }
        public static Akka.Streams.Dsl.Source<T, Reactive.Streams.ISubscriber<T>> AsSubscriber<T>() { }
        public static Akka.Streams.Dsl.Source<TOut2, Akka.NotUsed> Combine<T, TOut2>(Akka.Streams.Dsl.Source<T, Akka.NotUsed> first, Akka.Streams.Dsl.Source<T, Akka.NotUsed> second, System.Func<int, Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, TOut2>, Akka.NotUsed>> strategy, params Akka.Streams.Dsl.Source<, >[] rest) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMatOut> CombineMaterialized<T, TOut2, TMat1, TMat2, TMatOut>(Akka.Streams.Dsl.Source<T, TMat1> first, Akka.Streams.Dsl.Source<T, TMat2> second, System.Func<int, Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, TOut2>, Akka.NotUsed>> strategy, System.Func<TMat1, TMat2, TMatOut> combineMaterializers) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> Cycle<T>(System.Func<System.Collections.Generic.IEnumerator<T>> enumeratorFactory) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> Empty<T>() { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> Failed<T>(System.Exception cause) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> From<T>(System.Collections.Generic.IEnumerable<T> enumerable) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> FromEnumerator<T>(System.Func<System.Collections.Generic.IEnumerator<T>> enumeratorFactory) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> FromEvent<TDelegate, T>(System.Func<System.Action<T>, TDelegate> conversion, System.Action<TDelegate> addHandler, System.Action<TDelegate> removeHandler, int maxBufferCapacity = 128, Akka.Streams.OverflowStrategy overflowStrategy = 2) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> FromEvent<T>(System.Action<System.EventHandler<T>> addHandler, System.Action<System.EventHandler<T>> removeHandler, int maxBufferCapacity = 128, Akka.Streams.OverflowStrategy overflowStrategy = 2) { }
        public static Akka.Streams.Dsl.Source<T, TMat> FromGraph<T, TMat>(Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, TMat> source) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> FromObservable<T>(System.IObservable<T> observable, int maxBufferCapacity = 128, Akka.Streams.OverflowStrategy overflowStrategy = 2) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> FromPublisher<T>(Reactive.Streams.IPublisher<T> publisher) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> FromTask<T>(System.Threading.Tasks.Task<T> task) { }
        public static Akka.Streams.Dsl.Source<TOut, System.Threading.Tasks.Task<TMat>> Lazily<TOut, TMat>(System.Func<Akka.Streams.Dsl.Source<TOut, TMat>> create) { }
        public static Akka.Streams.Dsl.Source<T, System.Threading.Tasks.TaskCompletionSource<T>> Maybe<T>() { }
        public static Akka.Streams.Dsl.Source<T, Akka.Streams.ISourceQueueWithComplete<T>> Queue<T>(int bufferSize, Akka.Streams.OverflowStrategy overflowStrategy) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> Repeat<T>(T element) { }
        public static Akka.Streams.SourceShape<T> Shape<T>(string name) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> Single<T>(T element) { }
        public static Akka.Streams.Dsl.Source<T, Akka.Actor.ICancelable> Tick<T>(System.TimeSpan initialDelay, System.TimeSpan interval, T tick) { }
        public static Akka.Streams.Dsl.Source<TElem, Akka.NotUsed> Unfold<TState, TElem>(TState state, System.Func<TState, Akka.Util.Option<System.ValueTuple<TState, TElem>>> unfold) { }
        public static Akka.Streams.Dsl.Source<TElem, Akka.NotUsed> UnfoldAsync<TState, TElem>(TState state, System.Func<TState, System.Threading.Tasks.Task<Akka.Util.Option<System.ValueTuple<TState, TElem>>>> unfoldAsync) { }
        public static Akka.Streams.Dsl.Source<TElem, Akka.NotUsed> UnfoldInfinite<TState, TElem>(TState state, System.Func<TState, System.ValueTuple<TState, TElem>> unfold) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> UnfoldResource<T, TSource>(System.Func<TSource> create, System.Func<TSource, Akka.Util.Option<T>> read, System.Action<TSource> close) { }
        public static Akka.Streams.Dsl.Source<T, Akka.NotUsed> UnfoldResourceAsync<T, TSource>(System.Func<System.Threading.Tasks.Task<TSource>> create, System.Func<TSource, System.Threading.Tasks.Task<Akka.Util.Option<T>>> read, System.Func<TSource, System.Threading.Tasks.Task> close) { }
        public static Akka.Streams.Dsl.Source<System.Collections.Immutable.IImmutableList<T>, Akka.NotUsed> ZipN<T>(System.Collections.Generic.IEnumerable<Akka.Streams.Dsl.Source<T, Akka.NotUsed>> sources) { }
        public static Akka.Streams.Dsl.Source<TOut2, Akka.NotUsed> ZipWithN<T, TOut2>(System.Func<System.Collections.Immutable.IImmutableList<T>, TOut2> zipper, System.Collections.Generic.IEnumerable<Akka.Streams.Dsl.Source<T, Akka.NotUsed>> sources) { }
    }
    public class static SourceGen
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Source<TOut, TMat> UnfoldFlow<TState, TOut, TMat>(TState seed, Akka.Streams.IGraph<Akka.Streams.FlowShape<TState, System.ValueTuple<TState, TOut>>, TMat> flow, System.TimeSpan timeout) { }
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Source<TOut, TMat> UnfoldFlowWith<TOut, TState, TFlowOut, TMat>(TState seed, Akka.Streams.IGraph<Akka.Streams.FlowShape<TState, TFlowOut>, TMat> flow, System.Func<TFlowOut, Akka.Util.Option<System.ValueTuple<TState, TOut>>> unfoldWith, System.TimeSpan timeout) { }
    }
    public class static SourceOperations
    {
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Aggregate<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, TOut2> fold) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> AggregateAsync<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, System.Threading.Tasks.Task<TOut2>> fold) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> AlsoTo<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat> that) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat3> AlsoToMaterialized<TOut, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> that, System.Func<TMat, TMat2, TMat3> materializerFunction) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> AsSourceWithContext<TCtx, TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TOut, TCtx> fn) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> BackpressureTimeout<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Batch<TOut, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, long max, System.Func<TOut, TOut2> seed, System.Func<TOut2, TOut, TOut2> aggregate) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> BatchWeighted<TOut, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, long max, System.Func<TOut, long> costFunction, System.Func<TOut, TOut2> seed, System.Func<TOut2, TOut, TOut2> aggregate) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Buffer<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int size, Akka.Streams.OverflowStrategy strategy) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Collect<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, System.Func<TOut1, TOut2> collector) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMatOut> CombineMaterialized<T, TOut2, TMat1, TMat2, TMatOut>(this Akka.Streams.Dsl.Source<T, TMat1> flow, Akka.Streams.Dsl.Source<T, TMat2> other, System.Func<int, Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, TOut2>, Akka.NotUsed>> strategy, System.Func<TMat1, TMat2, TMatOut> combineMaterializers) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> CompletionTimeout<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Concat<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> ConcatMany<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, System.Func<TOut1, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat>> flatten) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Conflate<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TOut, TOut, TOut> aggregate) { }
        public static Akka.Streams.Dsl.Source<TSeed, TMat> ConflateWithSeed<TOut, TMat, TSeed>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TOut, TSeed> seed, System.Func<TSeed, TOut, TSeed> aggregate) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Delay<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan of, System.Nullable<Akka.Streams.DelayOverflowStrategy> strategy = null) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Detach<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Expand<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, System.Func<TOut1, System.Collections.Generic.IEnumerator<TOut2>> extrapolate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.IRunnableGraph<TMat>> GroupBy<TOut, TMat, TKey>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int maxSubstreams, System.Func<TOut, TKey> groupingFunc) { }
        public static Akka.Streams.Dsl.Source<System.Collections.Generic.IEnumerable<TOut>, TMat> Grouped<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int n) { }
        public static Akka.Streams.Dsl.Source<System.Collections.Generic.IEnumerable<TOut>, TMat> GroupedWithin<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int n, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> IdleTimeout<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> InitialDelay<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan delay) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> InitialTimeout<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.Source<T2, TMat> Interleave<T1, T2, TMat>(this Akka.Streams.Dsl.Source<T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other, int segmentSize)
            where T1 : T2 { }
        public static Akka.Streams.Dsl.Source<T2, TMat3> InterleaveMaterialized<T1, T2, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Source<T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat2> graph, int segmentSize, System.Func<TMat, TMat2, TMat3> combine)
            where T1 : T2 { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Intersperse<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, TOut start, TOut inject, TOut end) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Intersperse<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, TOut inject) { }
        public static Akka.Streams.Dsl.Source<TInjected, TMat> KeepAlive<TOut, TInjected, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan timeout, System.Func<TInjected> injectElement)
            where TOut : TInjected { }
        public static Akka.Streams.Dsl.Source<T, TMat> Limit<T, TMat>(this Akka.Streams.Dsl.Source<T, TMat> flow, long max) { }
        public static Akka.Streams.Dsl.Source<T, TMat> LimitWeighted<T, TMat>(this Akka.Streams.Dsl.Source<T, TMat> flow, long max, System.Func<T, long> costFunc) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Log<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, string name, System.Func<TOut, object> extract = null, Akka.Event.ILoggingAdapter log = null) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Merge<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat> other, bool eagerComplete = False)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> MergeMany<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, int breadth, System.Func<TOut1, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat>> flatten) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat3> MergeMaterialized<TOut1, TOut2, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat2> that, System.Func<TMat, TMat2, TMat3> combine)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> MergeSorted<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other, System.Func<TOut, TOut, int> orderFunc) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> MergeSorted<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other)
            where TOut : System.IComparable<TOut> { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> MergeSorted<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other, System.Collections.Generic.IComparer<TOut> comparer) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat2> Monitor<TOut, TMat, TMat2>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TMat, Akka.Streams.IFlowMonitor, TMat2> combine) { }
        public static Akka.Streams.Dsl.Source<T, TMat> OrElse<T, TMat>(this Akka.Streams.Dsl.Source<T, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, TMat> secondary) { }
        public static Akka.Streams.Dsl.Source<T, TMat3> OrElseMaterialized<T, TMat, TMat2, TMat3>(this Akka.Streams.Dsl.Source<T, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, TMat2> secondary, System.Func<TMat, TMat2, TMat3> materializedFunction) { }
        public static Akka.Streams.Dsl.Source<System.ValueTuple<System.Collections.Immutable.IImmutableList<TOut>, Akka.Streams.Dsl.Source<TOut, Akka.NotUsed>>, TMat> PrefixAndTail<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int n) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Prepend<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat> that)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Recover<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<System.Exception, Akka.Util.Option<TOut>> partialFunc) { }
        [System.ObsoleteAttribute("Use RecoverWithRetries instead. [1.1.2]")]
        public static Akka.Streams.Dsl.Source<TOut, TMat> RecoverWith<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunc) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> RecoverWithRetries<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunc, int attempts) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Scan<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, TOut2> scan) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> ScanAsync<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, TOut2 zero, System.Func<TOut2, TOut1, System.Threading.Tasks.Task<TOut2>> scan) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Select<TIn, TOut, TMat>(this Akka.Streams.Dsl.Source<TIn, TMat> flow, System.Func<TIn, TOut> mapper) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> SelectAsync<TIn, TOut, TMat>(this Akka.Streams.Dsl.Source<TIn, TMat> flow, int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> asyncMapper) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> SelectAsyncUnordered<TIn, TOut, TMat>(this Akka.Streams.Dsl.Source<TIn, TMat> flow, int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> asyncMapper) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> SelectError<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<System.Exception, System.Exception> selector) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> SelectMany<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, System.Func<TOut1, System.Collections.Generic.IEnumerable<TOut2>> mapConcater) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Skip<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, long n) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> SkipWhile<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> SkipWithin<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan duration) { }
        public static Akka.Streams.Dsl.Source<System.Collections.Generic.IEnumerable<TOut>, TMat> Sliding<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int n, int step = 1) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.IRunnableGraph<TMat>> SplitAfter<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.SubstreamCancelStrategy substreamCancelStrategy, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.IRunnableGraph<TMat>> SplitAfter<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.IRunnableGraph<TMat>> SplitWhen<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, Akka.Streams.SubstreamCancelStrategy substreamCancelStrategy, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, Akka.Streams.Dsl.IRunnableGraph<TMat>> SplitWhen<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.Source<TOut2, TMat> StatefulSelectMany<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, System.Func<System.Func<TOut1, System.Collections.Generic.IEnumerable<TOut2>>> mapConcaterFactory) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Sum<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TOut, TOut, TOut> reduce) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Take<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, long n) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> TakeWhile<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Predicate<TOut> predicate, bool inclusive = False) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> TakeWithin<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.TimeSpan duration) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Throttle<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int elements, System.TimeSpan per, int maximumBurst, Akka.Streams.ThrottleMode mode) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Throttle<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, int cost, System.TimeSpan per, int maximumBurst, System.Func<TOut, int> calculateCost, Akka.Streams.ThrottleMode mode) { }
        [System.ObsoleteAttribute("Use Via(GraphStage) instead. [1.1.2]")]
        public static Akka.Streams.Dsl.Source<TOut2, TMat> Transform<TOut1, TOut2, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow, System.Func<Akka.Streams.Stage.IStage<TOut1, TOut2>> stageFactory) { }
        public static Akka.Streams.Dsl.Source<T, TMat> Watch<T, TMat>(this Akka.Streams.Dsl.Source<T, TMat> flow, Akka.Actor.IActorRef actorRef) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat2> WatchTermination<TOut, TMat, TMat2>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Func<TMat, System.Threading.Tasks.Task, TMat2> materializerFunction) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> Where<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.Source<TOut, TMat> WhereNot<TOut, TMat>(this Akka.Streams.Dsl.Source<TOut, TMat> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.Source<System.ValueTuple<T1, T2>, TMat> Zip<T1, T2, TMat>(this Akka.Streams.Dsl.Source<T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other) { }
        public static Akka.Streams.Dsl.Source<T3, TMat> ZipWith<T1, T2, T3, TMat>(this Akka.Streams.Dsl.Source<T1, TMat> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other, System.Func<T1, T2, T3> combine) { }
        public static Akka.Streams.Dsl.Source<System.ValueTuple<TOut1, long>, TMat> ZipWithIndex<TOut1, TMat>(this Akka.Streams.Dsl.Source<TOut1, TMat> flow) { }
    }
    public class static SourceWithContextOperations
    {
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut2, TMat> Collect<TCtx, TOut, TOut2, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<TOut, TOut2> fn)
            where TOut2 :  class { }
        public static Akka.Streams.Dsl.SourceWithContext<System.Collections.Generic.IReadOnlyList<TCtx>, System.Collections.Generic.IReadOnlyList<TOut>, TMat> Grouped<TCtx, TOut, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, int n) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut2, TMat> Select<TCtx, TOut, TOut2, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<TOut, TOut2> fn) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut2, TMat> SelectAsync<TCtx, TOut, TOut2, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, int parallelism, System.Func<TOut, System.Threading.Tasks.Task<TOut2>> fn) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut2, TMat> SelectConcat<TCtx, TOut, TOut2, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<TOut, System.Collections.Generic.IEnumerable<TOut2>> fn) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx2, TOut, TMat> SelectContext<TCtx, TCtx2, TOut, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<TCtx, TCtx2> mapContext) { }
        public static Akka.Streams.Dsl.SourceWithContext<System.Collections.Generic.IReadOnlyList<TCtx>, System.Collections.Generic.IReadOnlyList<TOut>, TMat> Sliding<TCtx, TOut, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, int n, int step = 1) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut2, TMat> StatefulSelectConcat<TCtx, TOut, TOut2, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<System.Func<TOut, System.Collections.Generic.IEnumerable<TOut2>>> fn) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> Where<TCtx, TOut, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<TOut, bool> predicate) { }
        public static Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> WhereNot<TCtx, TOut, TMat>(this Akka.Streams.Dsl.SourceWithContext<TCtx, TOut, TMat> flow, System.Func<TOut, bool> predicate) { }
    }
    public sealed class SourceWithContext<TCtx, TOut, TMat> : Akka.Streams.GraphDelegate<Akka.Streams.SourceShape<System.ValueTuple<TOut, TCtx>>, TMat>
    {
        public SourceWithContext(Akka.Streams.Dsl.Source<System.ValueTuple<TOut, TCtx>, TMat> source) { }
        public Akka.Streams.Dsl.Source<System.ValueTuple<TOut, TCtx>, TMat> AsSource() { }
        public Akka.Streams.Dsl.SourceWithContext<TCtx2, TOut2, TMat> Via<TCtx2, TOut2, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TOut, TCtx>, System.ValueTuple<TOut2, TCtx2>>, TMat2> viaFlow) { }
        public Akka.Streams.Dsl.SourceWithContext<TCtx2, TOut2, TMat3> ViaMaterialized<TCtx2, TOut2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<System.ValueTuple<TOut, TCtx>, System.ValueTuple<TOut2, TCtx2>>, TMat2> viaFlow, System.Func<TMat, TMat2, TMat3> combine) { }
    }
    public sealed class Source<TOut, TMat> : Akka.Streams.Dsl.IFlow<TOut, TMat>, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>>, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>
    {
        public Source(Akka.Streams.Implementation.IModule module) { }
        public Akka.Streams.Implementation.IModule Module { get; }
        public Akka.Streams.SourceShape<TOut> Shape { get; }
        public Akka.Streams.Dsl.Source<TOut, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.Dsl.Source<TOut2, TMat> Ask<TOut2>(Akka.Actor.IActorRef actorRef, System.TimeSpan timeout, int parallelism = 2) { }
        public Akka.Streams.Dsl.Source<TOut, TMat> Async() { }
        public Akka.Streams.Dsl.Source<TOut2, Akka.NotUsed> Combine<T, TOut2>(Akka.Streams.Dsl.Source<T, Akka.NotUsed> first, Akka.Streams.Dsl.Source<T, Akka.NotUsed> second, System.Func<int, Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, TOut2>, Akka.NotUsed>> strategy, params Akka.Streams.Dsl.Source<, >[] rest) { }
        public Akka.Streams.Dsl.Source<TOut, TMat3> ConcatMaterialized<TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat2> that, System.Func<TMat, TMat2, TMat3> materializedFunction) { }
        public Akka.Streams.Dsl.Source<TOut, TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> mapFunc) { }
        public Akka.Streams.Dsl.Source<TOut, TMat> Named(string name) { }
        public System.ValueTuple<TMat, Akka.Streams.Dsl.Source<TOut, Akka.NotUsed>> PreMaterialize(Akka.Streams.IMaterializer materializer) { }
        public System.Threading.Tasks.Task<TOut2> RunAggregate<TOut2>(TOut2 zero, System.Func<TOut2, TOut, TOut2> aggregate, Akka.Streams.IMaterializer materializer) { }
        public System.Threading.Tasks.Task<TOut2> RunAggregateAsync<TOut2>(TOut2 zero, System.Func<TOut2, TOut, System.Threading.Tasks.Task<TOut2>> aggregate, Akka.Streams.IMaterializer materializer) { }
        public System.Threading.Tasks.Task RunForeach(System.Action<TOut> action, Akka.Streams.IMaterializer materializer) { }
        public System.Threading.Tasks.Task<TOut> RunSum(System.Func<TOut, TOut, TOut> reduce, Akka.Streams.IMaterializer materializer) { }
        public TMat2 RunWith<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink, Akka.Streams.IMaterializer materializer) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat> To<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink) { }
        public Akka.Streams.Dsl.IRunnableGraph<TMat3> ToMaterialized<TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink, System.Func<TMat, TMat2, TMat3> combine) { }
        public override string ToString() { }
        public Akka.Streams.Dsl.Source<T2, TMat> Via<T2, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow) { }
        public Akka.Streams.Dsl.Source<TOut2, TMat3> ViaMaterialized<TOut2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, TOut2>, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.Dsl.Source<TOut, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.Dsl.Source<System.Collections.Immutable.IImmutableList<T>, Akka.NotUsed> ZipN<T>(System.Collections.Generic.IEnumerable<Akka.Streams.Dsl.Source<T, Akka.NotUsed>> sources) { }
        public Akka.Streams.Dsl.Source<TOut2, Akka.NotUsed> ZipWithN<T, TOut2>(System.Func<System.Collections.Immutable.IImmutableList<T>, TOut2> zipper, System.Collections.Generic.IEnumerable<Akka.Streams.Dsl.Source<T, Akka.NotUsed>> sources) { }
    }
    public class static StreamConverters
    {
        public static Akka.Streams.Dsl.Sink<Akka.IO.ByteString, System.IO.Stream> AsInputStream(System.Nullable<System.TimeSpan> readTimeout = null) { }
        public static Akka.Streams.Dsl.Source<Akka.IO.ByteString, System.IO.Stream> AsOutputStream(System.Nullable<System.TimeSpan> writeTimeout = null) { }
        public static Akka.Streams.Dsl.Source<Akka.IO.ByteString, System.Threading.Tasks.Task<Akka.Streams.IO.IOResult>> FromInputStream(System.Func<System.IO.Stream> createInputStream, int chunkSize = 8192) { }
        public static Akka.Streams.Dsl.Sink<Akka.IO.ByteString, System.Threading.Tasks.Task<Akka.Streams.IO.IOResult>> FromOutputStream(System.Func<System.IO.Stream> createOutputStream, bool autoFlush = False) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class StreamRefSettings
    {
        public StreamRefSettings(int bufferCapacity, System.TimeSpan demandRedeliveryInterval, System.TimeSpan subscriptionTimeout, System.TimeSpan finalTerminationSignalDeadline) { }
        public int BufferCapacity { get; }
        public System.TimeSpan DemandRedeliveryInterval { get; }
        public System.TimeSpan FinalTerminationSignalDeadline { get; }
        public string ProductPrefix { get; }
        public System.TimeSpan SubscriptionTimeout { get; }
        public Akka.Streams.Dsl.StreamRefSettings Copy(System.Nullable<int> bufferCapacity = null, System.Nullable<System.TimeSpan> demandRedeliveryInterval = null, System.Nullable<System.TimeSpan> subscriptionTimeout = null, System.Nullable<System.TimeSpan> finalTerminationSignalDeadline = null) { }
        public static Akka.Streams.Dsl.StreamRefSettings Create(Akka.Configuration.Config config) { }
        public Akka.Streams.Dsl.StreamRefSettings WithBufferCapacity(int value) { }
        public Akka.Streams.Dsl.StreamRefSettings WithDemandRedeliveryInterval(System.TimeSpan value) { }
        public Akka.Streams.Dsl.StreamRefSettings WithSubscriptionTimeout(System.TimeSpan value) { }
    }
    [Akka.Annotations.ApiMayChangeAttribute()]
    public class static StreamRefs
    {
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Source<T, System.Threading.Tasks.Task<Akka.Streams.ISinkRef<T>>> SinkRef<T>() { }
        [Akka.Annotations.ApiMayChangeAttribute()]
        public static Akka.Streams.Dsl.Sink<T, System.Threading.Tasks.Task<Akka.Streams.ISourceRef<T>>> SourceRef<T>() { }
    }
    public class static SubFlowOperations
    {
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Aggregate<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, TOut2 zero, System.Func<TOut2, TOut1, TOut2> fold) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> AggregateAsync<TIn, TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TIn, TMat, TClosed> flow, TOut zero, System.Func<TOut, TIn, System.Threading.Tasks.Task<TOut>> fold) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> AlsoTo<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat> that) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat3, TClosed> AlsoToMaterialized<TOut, TMat, TMat2, TMat3, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> that, System.Func<TMat, TMat2, TMat3> materializerFunction) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> BackpressureTimeout<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Batch<TOut, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, long max, System.Func<TOut, TOut2> seed, System.Func<TOut2, TOut, TOut2> aggregate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> BatchWeighted<TOut, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, long max, System.Func<TOut, long> costFunction, System.Func<TOut, TOut2> seed, System.Func<TOut2, TOut, TOut2> aggregate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Buffer<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int size, Akka.Streams.OverflowStrategy strategy) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Collect<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, System.Func<TOut1, TOut2> collector) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> CompletionTimeout<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Concat<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> ConcatMany<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, System.Func<TOut1, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat>> flatten) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Conflate<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<TOut, TOut, TOut> aggregate) { }
        public static Akka.Streams.Dsl.SubFlow<TSeed, TMat, TClosed> ConflateWithSeed<TOut, TMat, TSeed, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<TOut, TSeed> seed, System.Func<TSeed, TOut, TSeed> aggregate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Delay<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan of, System.Nullable<Akka.Streams.DelayOverflowStrategy> strategy = null) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Detach<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Expand<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, System.Func<TOut1, System.Collections.Generic.IEnumerator<TOut2>> extrapolate) { }
        public static Akka.Streams.Dsl.SubFlow<System.Collections.Generic.IEnumerable<TOut>, TMat, TClosed> Grouped<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int n) { }
        public static Akka.Streams.Dsl.SubFlow<System.Collections.Generic.IEnumerable<TOut>, TMat, TClosed> GroupedWithin<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int n, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> IdleTimeout<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> InitialDelay<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan delay) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> InitialTimeout<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan timeout) { }
        public static Akka.Streams.Dsl.SubFlow<T2, TMat, TClosed> Interleave<T1, T2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<T1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other, int segmentSize)
            where T1 : T2 { }
        public static Akka.Streams.Dsl.SubFlow<T2, TMat3, TClosed> InterleaveMaterialized<T1, T2, TMat, TMat2, TMat3, TClosed>(this Akka.Streams.Dsl.SubFlow<T1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat2> graph, int segmentSize, System.Func<TMat, TMat2, TMat3> combine)
            where T1 : T2 { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Intersperse<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, TOut start, TOut inject, TOut end) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Intersperse<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, TOut inject) { }
        public static Akka.Streams.Dsl.SubFlow<TInjected, TMat, TClosed> KeepAlive<TOut, TInjected, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan timeout, System.Func<TInjected> injectElement)
            where TOut : TInjected { }
        public static Akka.Streams.Dsl.SubFlow<T, TMat, TClosed> Limit<T, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<T, TMat, TClosed> flow, long max) { }
        public static Akka.Streams.Dsl.SubFlow<T, TMat, TClosed> LimitWeighted<T, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<T, TMat, TClosed> flow, long max, System.Func<T, long> costFunc) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Log<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, string name, System.Func<TOut, object> extract = null, Akka.Event.ILoggingAdapter log = null) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Merge<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat> other, bool eagerComplete = False)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> MergeMany<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, int breadth, System.Func<TOut1, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat>> flatten) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat3, TClosed> MergeMaterialized<TOut1, TOut2, TMat, TMat2, TMat3, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat2> that, System.Func<TMat, TMat2, TMat3> combine)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> MergeSorted<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other, System.Func<TOut, TOut, int> orderFunc) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> MergeSorted<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other)
            where TOut : System.IComparable<TOut> { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> MergeSorted<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat> other, System.Collections.Generic.IComparer<TOut> comparer) { }
        public static Akka.Streams.Dsl.SubFlow<T, TMat, TClosed> OrElse<T, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<T, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, TMat> secondary) { }
        public static Akka.Streams.Dsl.SubFlow<System.ValueTuple<System.Collections.Immutable.IImmutableList<TOut>, Akka.Streams.Dsl.Source<TOut, Akka.NotUsed>>, TMat, TClosed> PrefixAndTail<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int n) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Prepend<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut2>, TMat> that)
            where TOut1 : TOut2 { }
        public static Akka.Streams.Dsl.SubFlow<Akka.Util.Option<TOut>, TMat, TClosed> Recover<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<System.Exception, Akka.Util.Option<TOut>> partialFunc) { }
        [System.ObsoleteAttribute("Use RecoverWithRetries instead. [1.1.2]")]
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> RecoverWith<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunc) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> RecoverWithRetries<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunc, int attempts) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Scan<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, TOut2 zero, System.Func<TOut2, TOut1, TOut2> scan) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> ScanAsync<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, TOut2 zero, System.Func<TOut2, TOut1, System.Threading.Tasks.Task<TOut2>> scan) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Select<TIn, TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TIn, TMat, TClosed> flow, System.Func<TIn, TOut> mapper) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> SelectAsync<TIn, TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TIn, TMat, TClosed> flow, int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> asyncMapper) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> SelectAsyncUnordered<TIn, TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TIn, TMat, TClosed> flow, int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> asyncMapper) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> SelectError<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<System.Exception, System.Exception> selector) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> SelectMany<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, System.Func<TOut1, System.Collections.Generic.IEnumerable<TOut2>> mapConcater) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Skip<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, long n) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> SkipWhile<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> SkipWithin<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan duration) { }
        public static Akka.Streams.Dsl.SubFlow<System.Collections.Generic.IEnumerable<TOut>, TMat, TClosed> Sliding<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int n, int step = 1) { }
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> StatefulSelectMany<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, System.Func<System.Func<TOut1, System.Collections.Generic.IEnumerable<TOut2>>> mapConcaterFactory) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Sum<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<TOut, TOut, TOut> reduce) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Take<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, long n) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> TakeWhile<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Predicate<TOut> predicate, bool inclusive = False) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> TakeWithin<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.TimeSpan duration) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Throttle<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int elements, System.TimeSpan per, int maximumBurst, Akka.Streams.ThrottleMode mode) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Throttle<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, int cost, System.TimeSpan per, int maximumBurst, System.Func<TOut, int> calculateCost, Akka.Streams.ThrottleMode mode) { }
        [System.ObsoleteAttribute("Use Via(GraphStage) instead. [1.1.2]")]
        public static Akka.Streams.Dsl.SubFlow<TOut2, TMat, TClosed> Transform<TOut1, TOut2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow, System.Func<Akka.Streams.Stage.IStage<TOut1, TOut2>> stageFactory) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat2, TClosed> WatchTermination<TOut, TMat, TMat2, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Func<TMat, System.Threading.Tasks.Task, TMat2> materializerFunction) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> Where<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> WhereNot<TOut, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed> flow, System.Predicate<TOut> predicate) { }
        public static Akka.Streams.Dsl.SubFlow<System.ValueTuple<T1, T2>, TMat, TClosed> Zip<T1, T2, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<T1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other) { }
        public static Akka.Streams.Dsl.SubFlow<T3, TMat, TClosed> ZipWith<T1, T2, T3, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<T1, TMat, TClosed> flow, Akka.Streams.IGraph<Akka.Streams.SourceShape<T2>, TMat> other, System.Func<T1, T2, T3> combine) { }
        public static Akka.Streams.Dsl.SubFlow<System.ValueTuple<TOut1, long>, TMat, TClosed> ZipWithIndex<TOut1, TMat, TClosed>(this Akka.Streams.Dsl.SubFlow<TOut1, TMat, TClosed> flow) { }
    }
    public abstract class SubFlow<TOut, TMat, TClosed> : Akka.Streams.Dsl.IFlow<TOut, TMat>
    {
        protected SubFlow() { }
        public virtual Akka.Streams.Dsl.IFlow<TOut, TMat> ConcatSubstream() { }
        public abstract Akka.Streams.Dsl.IFlow<TOut, TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> mapFunc);
        public virtual Akka.Streams.Dsl.IFlow<TOut, TMat> MergeSubstreams() { }
        public abstract Akka.Streams.Dsl.IFlow<TOut, TMat> MergeSubstreamsWithParallelism(int parallelism);
        public abstract TMat2 RunWith<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink, Akka.Streams.IMaterializer materializer);
        public abstract TClosed To<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink);
        public abstract Akka.Streams.Dsl.IFlow<T2, TMat> Via<T2, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow);
        public abstract Akka.Streams.Dsl.IFlow<T2, TMat3> ViaMaterialized<T2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine);
    }
    public enum SwitchMode
    {
        Open = 0,
        Close = 1,
    }
    public class Tcp : Akka.Actor.ExtensionIdProvider<Akka.Streams.Dsl.TcpExt>
    {
        public Tcp() { }
        public override Akka.Streams.Dsl.TcpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public struct IncomingConnection
        {
            public readonly Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> Flow;
            public readonly System.Net.EndPoint LocalAddress;
            public readonly System.Net.EndPoint RemoteAddress;
            public IncomingConnection(System.Net.EndPoint localAddress, System.Net.EndPoint remoteAddress, Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> flow) { }
            public TMat HandleWith<TMat>(Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, TMat> handler, Akka.Streams.IMaterializer materializer) { }
        }
        public struct OutgoingConnection
        {
            public readonly System.Net.EndPoint LocalAddress;
            public readonly System.Net.EndPoint RemoteAddress;
            public OutgoingConnection(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress) { }
        }
        public struct ServerBinding
        {
            public readonly System.Net.EndPoint LocalAddress;
            public ServerBinding(System.Net.EndPoint localAddress, System.Func<System.Threading.Tasks.Task> unbindAction) { }
            public System.Threading.Tasks.Task Unbind() { }
        }
    }
    public class TcpExt : Akka.Actor.IExtension
    {
        protected readonly System.TimeSpan BindShutdownTimeout;
        [Akka.Annotations.InternalApiAttribute()]
        public TcpExt(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.Streams.Dsl.Source<Akka.Streams.Dsl.Tcp.IncomingConnection, System.Threading.Tasks.Task<Akka.Streams.Dsl.Tcp.ServerBinding>> Bind(string host, int port, int backlog = 100, System.Collections.Immutable.IImmutableList<Akka.IO.Inet.SocketOption> options = null, bool halfClose = False, System.Nullable<System.TimeSpan> idleTimeout = null) { }
        public System.Threading.Tasks.Task<Akka.Streams.Dsl.Tcp.ServerBinding> BindAndHandle(Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, Akka.NotUsed> handler, Akka.Streams.IMaterializer materializer, string host, int port, int backlog = 100, System.Collections.Immutable.IImmutableList<Akka.IO.Inet.SocketOption> options = null, bool halfClose = False, System.Nullable<System.TimeSpan> idleTimeout = null) { }
        public Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, System.Threading.Tasks.Task<Akka.Streams.Dsl.Tcp.OutgoingConnection>> OutgoingConnection(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Immutable.IImmutableList<Akka.IO.Inet.SocketOption> options = null, bool halfClose = True, System.Nullable<System.TimeSpan> connectionTimeout = null, System.Nullable<System.TimeSpan> idleTimeout = null) { }
        public Akka.Streams.Dsl.Flow<Akka.IO.ByteString, Akka.IO.ByteString, System.Threading.Tasks.Task<Akka.Streams.Dsl.Tcp.OutgoingConnection>> OutgoingConnection(string host, int port) { }
    }
    public sealed class TcpIdleTimeoutException : System.TimeoutException
    {
        public TcpIdleTimeoutException(string message, System.TimeSpan duration) { }
        public System.TimeSpan Duration { get; }
    }
    public class static TcpStreamExtensions
    {
        public static Akka.Streams.Dsl.TcpExt TcpStream(this Akka.Actor.ActorSystem system) { }
    }
    public sealed class UnZip<T1, T2> : Akka.Streams.Dsl.UnzipWith<System.Collections.Generic.KeyValuePair<T1, T2>, T1, T2>
    {
        public UnZip() { }
        public override string ToString() { }
    }
    public class UnexpectedOutputException : System.Exception
    {
        public UnexpectedOutputException(object element) { }
    }
    public class UnzipWith
    {
        public static readonly Akka.Streams.Dsl.UnzipWith Instance;
        public static Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1> Apply<TIn, TOut0, TOut1>(System.Func<TIn, System.ValueTuple<TOut0, TOut1>> unzipper, Akka.Streams.Dsl.UnzipWithCreator<TIn, TOut0, TOut1> creator) { }
        public static Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2> Apply<TIn, TOut0, TOut1, TOut2>(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2>> unzipper, Akka.Streams.Dsl.UnzipWithCreator<TIn, TOut0, TOut1, TOut2> creator) { }
        public static Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3> Apply<TIn, TOut0, TOut1, TOut2, TOut3>(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3>> unzipper, Akka.Streams.Dsl.UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3> creator) { }
        public static Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4> Apply<TIn, TOut0, TOut1, TOut2, TOut3, TOut4>(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4>> unzipper, Akka.Streams.Dsl.UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3, TOut4> creator) { }
        public static Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5> Apply<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5>(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4, TOut5>> unzipper, Akka.Streams.Dsl.UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5> creator) { }
        public static Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6> Apply<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6>(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6>> unzipper, Akka.Streams.Dsl.UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6> creator) { }
    }
    public abstract class UnzipWithCreator<TIn, TOut0, TOut1> : Akka.Streams.Dsl.IUnzipWithCreator<TIn, System.ValueTuple<TOut0, TOut1>, Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1>>
    {
        protected UnzipWithCreator() { }
        public virtual Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1> Create(System.Func<TIn, System.ValueTuple<TOut0, TOut1>> unzipper) { }
    }
    public abstract class UnzipWithCreator<TIn, TOut0, TOut1, TOut2> : Akka.Streams.Dsl.IUnzipWithCreator<TIn, System.ValueTuple<TOut0, TOut1, TOut2>, Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2>>
    {
        protected UnzipWithCreator() { }
        public virtual Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2> Create(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2>> unzipper) { }
    }
    public abstract class UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3> : Akka.Streams.Dsl.IUnzipWithCreator<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3>, Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3>>
    {
        protected UnzipWithCreator() { }
        public virtual Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3> Create(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3>> unzipper) { }
    }
    public abstract class UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3, TOut4> : Akka.Streams.Dsl.IUnzipWithCreator<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4>, Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4>>
    {
        protected UnzipWithCreator() { }
        public virtual Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4> Create(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4>> unzipper) { }
    }
    public abstract class UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5> : Akka.Streams.Dsl.IUnzipWithCreator<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4, TOut5>, Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5>>
    {
        protected UnzipWithCreator() { }
        public virtual Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5> Create(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4, TOut5>> unzipper) { }
    }
    public abstract class UnzipWithCreator<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6> : Akka.Streams.Dsl.IUnzipWithCreator<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6>, Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6>>
    {
        protected UnzipWithCreator() { }
        public virtual Akka.Streams.Dsl.UnzipWith<TIn, TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6> Create(System.Func<TIn, System.ValueTuple<TOut0, TOut1, TOut2, TOut3, TOut4, TOut5, TOut6>> unzipper) { }
    }
    public class UnzipWith<TIn, T0, T1> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, T0, T1>>
    {
        public UnzipWith(System.Func<TIn, System.ValueTuple<T0, T1>> unzipper) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T0> Out0 { get; }
        public Akka.Streams.Outlet<T1> Out1 { get; }
        public virtual Akka.Streams.FanOutShape<TIn, T0, T1> Shape { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class UnzipWith<TIn, T0, T1, T2> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, T0, T1, T2>>
    {
        public UnzipWith(System.Func<TIn, System.ValueTuple<T0, T1, T2>> unzipper) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T0> Out0 { get; }
        public Akka.Streams.Outlet<T1> Out1 { get; }
        public Akka.Streams.Outlet<T2> Out2 { get; }
        public virtual Akka.Streams.FanOutShape<TIn, T0, T1, T2> Shape { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class UnzipWith<TIn, T0, T1, T2, T3> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3>>
    {
        public UnzipWith(System.Func<TIn, System.ValueTuple<T0, T1, T2, T3>> unzipper) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T0> Out0 { get; }
        public Akka.Streams.Outlet<T1> Out1 { get; }
        public Akka.Streams.Outlet<T2> Out2 { get; }
        public Akka.Streams.Outlet<T3> Out3 { get; }
        public virtual Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3> Shape { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class UnzipWith<TIn, T0, T1, T2, T3, T4> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3, T4>>
    {
        public UnzipWith(System.Func<TIn, System.ValueTuple<T0, T1, T2, T3, T4>> unzipper) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T0> Out0 { get; }
        public Akka.Streams.Outlet<T1> Out1 { get; }
        public Akka.Streams.Outlet<T2> Out2 { get; }
        public Akka.Streams.Outlet<T3> Out3 { get; }
        public Akka.Streams.Outlet<T4> Out4 { get; }
        public virtual Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3, T4> Shape { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class UnzipWith<TIn, T0, T1, T2, T3, T4, T5> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3, T4, T5>>
    {
        public UnzipWith(System.Func<TIn, System.ValueTuple<T0, T1, T2, T3, T4, T5>> unzipper) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T0> Out0 { get; }
        public Akka.Streams.Outlet<T1> Out1 { get; }
        public Akka.Streams.Outlet<T2> Out2 { get; }
        public Akka.Streams.Outlet<T3> Out3 { get; }
        public Akka.Streams.Outlet<T4> Out4 { get; }
        public Akka.Streams.Outlet<T5> Out5 { get; }
        public virtual Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3, T4, T5> Shape { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class UnzipWith<TIn, T0, T1, T2, T3, T4, T5, T6> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3, T4, T5, T6>>
    {
        public UnzipWith(System.Func<TIn, System.ValueTuple<T0, T1, T2, T3, T4, T5, T6>> unzipper) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T0> Out0 { get; }
        public Akka.Streams.Outlet<T1> Out1 { get; }
        public Akka.Streams.Outlet<T2> Out2 { get; }
        public Akka.Streams.Outlet<T3> Out3 { get; }
        public Akka.Streams.Outlet<T4> Out4 { get; }
        public Akka.Streams.Outlet<T5> Out5 { get; }
        public Akka.Streams.Outlet<T6> Out6 { get; }
        public virtual Akka.Streams.FanOutShape<TIn, T0, T1, T2, T3, T4, T5, T6> Shape { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class Valve<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.FlowShape<T, T>, System.Threading.Tasks.Task<Akka.Streams.Dsl.IValveSwitch>>
    {
        public Valve() { }
        public Valve(Akka.Streams.Dsl.SwitchMode mode) { }
        public Akka.Streams.Inlet<T> In { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public override Akka.Streams.FlowShape<T, T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<Akka.Streams.Dsl.IValveSwitch>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class static ZipN
    {
        public static Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<T, System.Collections.Immutable.IImmutableList<T>>> Create<T>(int n) { }
    }
    public sealed class ZipN<T> : Akka.Streams.Dsl.ZipWithN<T, System.Collections.Immutable.IImmutableList<T>>
    {
        public ZipN(int n) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override string ToString() { }
    }
    public sealed class ZipWith
    {
        public static readonly Akka.Streams.Dsl.ZipWith Instance;
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TOut> Apply<TIn0, TIn1, TOut>(System.Func<TIn0, TIn1, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TOut> Apply<TIn0, TIn1, TIn2, TOut>(System.Func<TIn0, TIn1, TIn2, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TIn3, TOut> Apply<TIn0, TIn1, TIn2, TIn3, TOut>(System.Func<TIn0, TIn1, TIn2, TIn3, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TOut> Apply<TIn0, TIn1, TIn2, TIn3, TIn4, TOut>(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut> Apply<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut>(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut> Apply<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut>(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut> Apply<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut>(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut> zipper) { }
        public static Akka.Streams.Dsl.ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut> Apply<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut>(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut> zipper) { }
    }
    public class static ZipWithN
    {
        public static Akka.Streams.IGraph<Akka.Streams.UniformFanInShape<TIn, TOut>> Create<TIn, TOut>(System.Func<System.Collections.Immutable.IImmutableList<TIn>, TOut> zipper, int n) { }
    }
    public class ZipWithN<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.UniformFanInShape<TIn, TOut>>
    {
        public ZipWithN(System.Func<System.Collections.Immutable.IImmutableList<TIn>, TOut> zipper, int n) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public System.Collections.Immutable.IImmutableList<Akka.Streams.Inlet<TIn>> Inlets { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.UniformFanInShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public Akka.Streams.Inlet<TIn> In(int i) { }
        public override string ToString() { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        public Akka.Streams.Inlet<TIn3> In3 { get; }
        public Akka.Streams.Inlet<TIn4> In4 { get; }
        public Akka.Streams.Inlet<TIn5> In5 { get; }
        public Akka.Streams.Inlet<TIn6> In6 { get; }
        public Akka.Streams.Inlet<TIn7> In7 { get; }
        public Akka.Streams.Inlet<TIn8> In8 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TIn8, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TIn3, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TIn3, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        public Akka.Streams.Inlet<TIn3> In3 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TIn3, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        public Akka.Streams.Inlet<TIn3> In3 { get; }
        public Akka.Streams.Inlet<TIn4> In4 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        public Akka.Streams.Inlet<TIn3> In3 { get; }
        public Akka.Streams.Inlet<TIn4> In4 { get; }
        public Akka.Streams.Inlet<TIn5> In5 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        public Akka.Streams.Inlet<TIn3> In3 { get; }
        public Akka.Streams.Inlet<TIn4> In4 { get; }
        public Akka.Streams.Inlet<TIn5> In5 { get; }
        public Akka.Streams.Inlet<TIn6> In6 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class ZipWith<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut>>
    {
        public ZipWith(System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut> zipper) { }
        public Akka.Streams.Inlet<TIn0> In0 { get; }
        public Akka.Streams.Inlet<TIn1> In1 { get; }
        public Akka.Streams.Inlet<TIn2> In2 { get; }
        public Akka.Streams.Inlet<TIn3> In3 { get; }
        public Akka.Streams.Inlet<TIn4> In4 { get; }
        public Akka.Streams.Inlet<TIn5> In5 { get; }
        public Akka.Streams.Inlet<TIn6> In6 { get; }
        public Akka.Streams.Inlet<TIn7> In7 { get; }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public virtual Akka.Streams.FanInShape<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut> Shape { get; }
        public System.Func<TIn0, TIn1, TIn2, TIn3, TIn4, TIn5, TIn6, TIn7, TOut> Zipper { get; }
        protected virtual Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public sealed class Zip<T1, T2> : Akka.Streams.Dsl.ZipWith<T1, T2, System.ValueTuple<T1, T2>>
    {
        public Zip() { }
        public override string ToString() { }
    }
}
namespace Akka.Streams.Dsl.Internal
{
    [Akka.Annotations.InternalApiAttribute()]
    public class GraphImpl<TShape, TMat> : Akka.Streams.IGraph<TShape>, Akka.Streams.IGraph<TShape, TMat>
        where TShape : Akka.Streams.Shape
    {
        public GraphImpl(TShape shape, Akka.Streams.Implementation.IModule module) { }
        public Akka.Streams.Implementation.IModule Module { get; }
        public TShape Shape { get; }
        public Akka.Streams.IGraph<TShape, TMat> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.IGraph<TShape, TMat> Async() { }
        public Akka.Streams.IGraph<TShape, TMat> Named(string name) { }
        public override string ToString() { }
        public Akka.Streams.IGraph<TShape, TMat> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class static ModuleExtractor
    {
        public static Akka.Util.Option<Akka.Streams.Implementation.IModule> Unapply<TShape, TMat>(Akka.Streams.IGraph<TShape, TMat> graph)
            where TShape : Akka.Streams.Shape { }
    }
}
namespace Akka.Streams.Extra
{
    public class static TimedFlowDsl
    {
        public static Akka.Streams.Dsl.Flow<TIn, TOut2, TMat2> Timed<TIn, TOut, TOut2, TMat, TMat2>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<Akka.Streams.Dsl.Flow<TIn, TOut, TMat>, Akka.Streams.Dsl.Flow<TIn, TOut2, TMat2>> measuredOps, System.Action<System.TimeSpan> onComplete) { }
        public static Akka.Streams.Dsl.Flow<TIn, TOut, TMat> TimedIntervalBetween<TIn, TOut, TMat>(this Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, System.Func<TOut, bool> matching, System.Action<System.TimeSpan> onInterval) { }
    }
    public class static TimedSourceDsl
    {
        public static Akka.Streams.Dsl.Source<TOut, TMat2> Timed<TIn, TOut, TMat, TMat2>(this Akka.Streams.Dsl.Source<TIn, TMat> source, System.Func<Akka.Streams.Dsl.Source<TIn, TMat>, Akka.Streams.Dsl.Source<TOut, TMat2>> measuredOps, System.Action<System.TimeSpan> onComplete) { }
        public static Akka.Streams.Dsl.Source<TIn, TMat> TimedIntervalBetween<TIn, TMat>(this Akka.Streams.Dsl.Source<TIn, TMat> source, System.Func<TIn, bool> matching, System.Action<System.TimeSpan> onInterval) { }
    }
}
namespace Akka.Streams.IO
{
    public struct IOResult
    {
        public readonly long Count;
        public IOResult(long count, Akka.Util.Result<Akka.NotUsed> status) { }
        public System.Exception Error { get; }
        public bool WasSuccessful { get; }
        public static Akka.Streams.IO.IOResult Failed(long count, System.Exception reason) { }
        public static Akka.Streams.IO.IOResult Success(long count) { }
    }
}
namespace Akka.Streams.Implementation
{
    public sealed class ActorMaterializerImpl : Akka.Streams.Implementation.ExtendedActorMaterializer
    {
        public ActorMaterializerImpl(Akka.Actor.ActorSystem system, Akka.Streams.ActorMaterializerSettings settings, Akka.Dispatch.Dispatchers dispatchers, Akka.Actor.IActorRef supervisor, Akka.Util.AtomicBoolean haveShutDown, Akka.Streams.Implementation.EnumerableActorName flowNames) { }
        public override Akka.Dispatch.MessageDispatcher ExecutionContext { get; }
        public override bool IsShutdown { get; }
        [Akka.Annotations.InternalApiAttribute()]
        public override Akka.Event.ILoggingAdapter Logger { get; }
        public override Akka.Streams.ActorMaterializerSettings Settings { get; }
        [Akka.Annotations.InternalApiAttribute()]
        public override Akka.Actor.IActorRef Supervisor { get; }
        public override Akka.Actor.ActorSystem System { get; }
        public override Akka.Streams.ActorMaterializerSettings EffectiveSettings(Akka.Streams.Attributes attributes) { }
        public override Akka.Event.ILoggingAdapter MakeLogger(object logSource) { }
        public override TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable) { }
        public override TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, System.Func<Akka.Streams.Implementation.Fusing.GraphInterpreterShell, Akka.Actor.IActorRef> subFlowFuser) { }
        public override TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, Akka.Streams.Attributes initialAttributes) { }
        public override TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, System.Func<Akka.Streams.Implementation.Fusing.GraphInterpreterShell, Akka.Actor.IActorRef> subFlowFuser, Akka.Streams.Attributes initialAttributes) { }
        public override Akka.Actor.ICancelable ScheduleOnce(System.TimeSpan delay, System.Action action) { }
        public override Akka.Actor.ICancelable ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }
        public override void Shutdown() { }
        public override Akka.Streams.IMaterializer WithNamePrefix(string name) { }
    }
    public class static ActorPublisher
    {
        public static readonly Akka.Streams.Implementation.NormalShutdownException NormalShutdownReason;
        public const string NormalShutdownReasonMessage = "Cannot subscribe to shut-down Publisher";
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ActorPublisherSource<TOut> : Akka.Streams.Implementation.SourceModule<TOut, Akka.Actor.IActorRef>
    {
        public ActorPublisherSource(Akka.Actor.Props props, Akka.Streams.Attributes attributes, Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override Reactive.Streams.IPublisher<TOut> Create(Akka.Streams.MaterializationContext context, out Akka.Actor.IActorRef materializer) { }
        protected override Akka.Streams.Implementation.SourceModule<TOut, Akka.Actor.IActorRef> NewInstance(Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class ActorPublisher<TOut> : Akka.Streams.IUntypedPublisher, Akka.Streams.Implementation.IActorPublisher, Reactive.Streams.IPublisher<TOut>
    {
        protected readonly Akka.Actor.IActorRef Impl;
        public ActorPublisher(Akka.Actor.IActorRef impl) { }
        protected virtual object WakeUpMessage { get; }
        public void Shutdown(System.Exception reason) { }
        public void Subscribe(Reactive.Streams.ISubscriber<TOut> subscriber) { }
        public System.Collections.Generic.IEnumerable<Reactive.Streams.ISubscriber<TOut>> TakePendingSubscribers() { }
    }
    public class ActorRefSinkActor : Akka.Streams.Actors.ActorSubscriber
    {
        protected readonly int HighWatermark;
        protected readonly object OnCompleteMessage;
        protected readonly Akka.Actor.IActorRef Ref;
        public ActorRefSinkActor(Akka.Actor.IActorRef @ref, int highWatermark, object onCompleteMessage) { }
        protected Akka.Event.ILoggingAdapter Log { get; }
        public override Akka.Streams.Actors.IRequestStrategy RequestStrategy { get; }
        public static Akka.Actor.Props Props(Akka.Actor.IActorRef @ref, int highWatermark, object onCompleteMessage) { }
        protected override bool Receive(object message) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ActorRefSink<TIn> : Akka.Streams.Implementation.SinkModule<TIn, Akka.NotUsed>
    {
        public ActorRefSink(Akka.Actor.IActorRef @ref, object onCompleteMessage, Akka.Streams.Attributes attributes, Akka.Streams.SinkShape<TIn> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override object Create(Akka.Streams.MaterializationContext context, out Akka.NotUsed materializer) { }
        protected override Akka.Streams.Implementation.SinkModule<TIn, Akka.NotUsed> NewInstance(Akka.Streams.SinkShape<TIn> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ActorRefSource<TOut> : Akka.Streams.Implementation.SourceModule<TOut, Akka.Actor.IActorRef>
    {
        public ActorRefSource(int bufferSize, Akka.Streams.OverflowStrategy overflowStrategy, Akka.Streams.Attributes attributes, Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        protected override string Label { get; }
        public override Reactive.Streams.IPublisher<TOut> Create(Akka.Streams.MaterializationContext context, out Akka.Actor.IActorRef materializer) { }
        protected override Akka.Streams.Implementation.SourceModule<TOut, Akka.Actor.IActorRef> NewInstance(Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ActorSubscriberSink<TIn> : Akka.Streams.Implementation.SinkModule<TIn, Akka.Actor.IActorRef>
    {
        public ActorSubscriberSink(Akka.Actor.Props props, Akka.Streams.Attributes attributes, Akka.Streams.SinkShape<TIn> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override object Create(Akka.Streams.MaterializationContext context, out Akka.Actor.IActorRef materializer) { }
        protected override Akka.Streams.Implementation.SinkModule<TIn, Akka.Actor.IActorRef> NewInstance(Akka.Streams.SinkShape<TIn> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class static ActorSubscription
    {
        public static Akka.Streams.Implementation.IActorSubscription Create<T>(Akka.Actor.IActorRef implementor, Reactive.Streams.ISubscriber<T> subscriber) { }
    }
    public class ActorSubscriptionWithCursor<TIn> : Akka.Streams.Implementation.ActorSubscription<TIn>, Akka.Streams.Implementation.ICursor, Reactive.Streams.ISubscription
    {
        public ActorSubscriptionWithCursor(Akka.Actor.IActorRef implementor, Reactive.Streams.ISubscriber<TIn> subscriber) { }
        public long Cursor { get; }
        public bool IsActive { get; }
        public long TotalDemand { get; }
        public void Dispatch(object element) { }
        public void Dispatch(TIn element) { }
    }
    public class ActorSubscription<T> : Akka.Streams.Implementation.IActorSubscription, Reactive.Streams.ISubscription
    {
        public readonly Akka.Actor.IActorRef Implementor;
        public readonly Reactive.Streams.ISubscriber<T> Subscriber;
        public ActorSubscription(Akka.Actor.IActorRef implementor, Reactive.Streams.ISubscriber<T> subscriber) { }
        public void Cancel() { }
        public void Request(long n) { }
    }
    public abstract class AtomicModule : Akka.Streams.Implementation.Module
    {
        protected AtomicModule() { }
        public virtual System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> Downstreams { get; }
        public virtual System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public virtual System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> Upstreams { get; }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class BackpressureTimeout<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public readonly System.TimeSpan Timeout;
        public BackpressureTimeout(System.TimeSpan timeout) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public abstract class BatchingInputBuffer
    {
        public readonly int Count;
        public readonly Akka.Streams.Implementation.IPump Pump;
        protected BatchingInputBuffer(int count, Akka.Streams.Implementation.IPump pump) { }
        public bool AreInputsAvailable { get; }
        public bool AreInputsDepleted { get; }
        public bool IsClosed { get; }
        public bool IsOpen { get; }
        public Akka.Streams.Implementation.TransferState NeedsInput { get; }
        public Akka.Streams.Implementation.TransferState NeedsInputOrComplete { get; }
        public virtual Akka.Streams.Implementation.SubReceive SubReceive { get; }
        public virtual void Cancel() { }
        protected virtual bool Completed(object message) { }
        public virtual object DequeueInputElement() { }
        protected virtual void EnqueueInputElement(object element) { }
        protected virtual void InputOnError(System.Exception e) { }
        protected virtual void OnComplete() { }
        protected virtual void OnError(System.Exception e) { }
        protected virtual void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
        public override string ToString() { }
        protected virtual bool UpstreamRunning(object message) { }
        protected virtual bool WaitingForUpstream(object message) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class CancelSink<T> : Akka.Streams.Implementation.SinkModule<T, Akka.NotUsed>
    {
        public CancelSink(Akka.Streams.Attributes attributes, Akka.Streams.SinkShape<T> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override object Create(Akka.Streams.MaterializationContext context, out Akka.NotUsed materializer) { }
        protected override Akka.Streams.Implementation.SinkModule<T, Akka.NotUsed> NewInstance(Akka.Streams.SinkShape<T> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public sealed class CancelingSubscriber<T> : Reactive.Streams.ISubscriber<T>
    {
        public static readonly Akka.Streams.Implementation.CancelingSubscriber<T> Instance;
        public void OnComplete() { }
        public void OnError(System.Exception cause) { }
        public void OnNext(T element) { }
        public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Completion<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public readonly System.TimeSpan Timeout;
        public Completion(System.TimeSpan timeout) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public sealed class CompositeModule : Akka.Streams.Implementation.Module
    {
        public CompositeModule(System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> subModules, Akka.Streams.Shape shape, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> downstreams, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> upstreams, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode materializedValueComputation, Akka.Streams.Attributes attributes) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> Downstreams { get; }
        public override Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public override System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> Upstreams { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public static Akka.Streams.Implementation.CompositeModule Create(Akka.Streams.Implementation.Module module, Akka.Streams.Shape shape) { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override string ToString() { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public sealed class CopiedModule : Akka.Streams.Implementation.Module
    {
        public CopiedModule(Akka.Streams.Shape shape, Akka.Streams.Attributes attributes, Akka.Streams.Implementation.IModule copyOf) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public Akka.Streams.Implementation.IModule CopyOf { get; }
        public override bool IsCopied { get; }
        public override Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override string ToString() { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class DelayInitial<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public readonly System.TimeSpan Delay;
        public DelayInitial(System.TimeSpan delay) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public class DistinctRetainingMultiReaderBuffer<T> : Akka.Streams.Implementation.RetainingMultiReaderBuffer<T>
    {
        public DistinctRetainingMultiReaderBuffer(long initialSize, long maxSize, Akka.Streams.Implementation.ICursors cursors) { }
        public override string ToString() { }
        public override bool Write(T value) { }
    }
    public sealed class EmptyModule : Akka.Streams.Implementation.Module
    {
        public static readonly Akka.Streams.Implementation.EmptyModule Instance;
        public override Akka.Streams.Attributes Attributes { get; }
        public override bool IsAtomic { get; }
        public override bool IsRunnable { get; }
        public override Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public override Akka.Streams.Implementation.IModule Compose(Akka.Streams.Implementation.IModule other) { }
        public override Akka.Streams.Implementation.IModule Compose<T1, T2, T3>(Akka.Streams.Implementation.IModule other, System.Func<T1, T2, T3> matFunc) { }
        public override Akka.Streams.Implementation.IModule Nest() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public sealed class EmptyPublisher<T> : Reactive.Streams.IPublisher<T>
    {
        public static readonly Reactive.Streams.IPublisher<T> Instance;
        public void Subscribe(Reactive.Streams.ISubscriber<T> subscriber) { }
        public override string ToString() { }
    }
    public sealed class EmptySource<TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<TOut>>
    {
        public EmptySource() { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.SourceShape<TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public abstract class EnumerableActorName
    {
        protected EnumerableActorName() { }
        public abstract Akka.Streams.Implementation.EnumerableActorName Copy(string newPrefix);
        public static Akka.Streams.Implementation.EnumerableActorName Create(string prefix) { }
        public abstract string Next();
    }
    public abstract class ExposedPublisherReceive
    {
        public readonly Akka.Actor.Receive ActiveReceive;
        public readonly System.Action<object> Unhandled;
        protected ExposedPublisherReceive(Akka.Actor.Receive activeReceive, System.Action<object> unhandled) { }
        public bool Apply(object message) { }
    }
    public abstract class ExtendedActorMaterializer : Akka.Streams.ActorMaterializer
    {
        protected ExtendedActorMaterializer() { }
        [Akka.Annotations.InternalApiAttribute()]
        public override Akka.Actor.IActorRef ActorOf(Akka.Streams.MaterializationContext context, Akka.Actor.Props props) { }
        [Akka.Annotations.InternalApiAttribute()]
        protected Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name, string dispatcher) { }
        [Akka.Annotations.InternalApiAttribute()]
        public abstract TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, System.Func<Akka.Streams.Implementation.Fusing.GraphInterpreterShell, Akka.Actor.IActorRef> subFlowFuser);
        [Akka.Annotations.InternalApiAttribute()]
        public abstract TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, System.Func<Akka.Streams.Implementation.Fusing.GraphInterpreterShell, Akka.Actor.IActorRef> subFlowFuser, Akka.Streams.Attributes initialAttributes);
    }
    public class static FanIn
    {
        public const byte Cancelled = 16;
        public const byte Completed = 8;
        public const byte Depleted = 4;
        public const byte Marked = 1;
        public const byte Pending = 2;
        public struct OnComplete : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly int Id;
            public OnComplete(int id) { }
        }
        public struct OnError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly System.Exception Cause;
            public readonly int Id;
            public OnError(int id, System.Exception cause) { }
        }
        public struct OnNext : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly object Element;
            public readonly int Id;
            public OnNext(int id, object element) { }
        }
        public struct OnSubscribe : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly int Id;
            public readonly Reactive.Streams.ISubscription Subscription;
            public OnSubscribe(int id, Reactive.Streams.ISubscription subscription) { }
        }
    }
    public abstract class FanIn<T> : Akka.Actor.ActorBase, Akka.Streams.Implementation.IPump
    {
        protected readonly Akka.Streams.Implementation.InputBunch InputBunch;
        protected readonly int InputCount;
        protected readonly Akka.Streams.Implementation.SimpleOutputs PrimaryOutputs;
        protected readonly Akka.Streams.ActorMaterializerSettings Settings;
        protected FanIn(Akka.Streams.ActorMaterializerSettings settings, int inputCount) { }
        public System.Action CurrentAction { get; set; }
        public bool IsPumpFinished { get; }
        protected Akka.Event.ILoggingAdapter Log { get; }
        public Akka.Streams.Implementation.TransferState TransferState { get; set; }
        protected void Fail(System.Exception cause) { }
        public void GotUpstreamSubscription() { }
        public void InitialPhase(int waitForUpstream, Akka.Streams.Implementation.TransferPhase andThen) { }
        public void NextPhase(Akka.Streams.Implementation.TransferPhase phase) { }
        protected override void PostRestart(System.Exception reason) { }
        protected override void PostStop() { }
        public void Pump() { }
        public void PumpFailed(System.Exception e) { }
        public void PumpFinished() { }
        protected override bool Receive(object message) { }
        public void WaitForUpstream(int waitForUpstream) { }
        public struct SubInput<T> : Reactive.Streams.ISubscriber<T>
        {
            public SubInput(Akka.Actor.IActorRef impl, int id) { }
            public void OnComplete() { }
            public void OnError(System.Exception cause) { }
            public void OnNext(T element) { }
            public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
        }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class static FanOut
    {
        public struct ExposedPublishers<T> : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly System.Collections.Immutable.ImmutableList<Akka.Streams.Implementation.ActorPublisher<T>> Publishers;
            public ExposedPublishers(System.Collections.Immutable.ImmutableList<Akka.Streams.Implementation.ActorPublisher<T>> publishers) { }
        }
        public struct SubstreamCancel : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly int Id;
            public SubstreamCancel(int id) { }
        }
        public struct SubstreamRequestMore : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly long Demand;
            public readonly int Id;
            public SubstreamRequestMore(int id, long demand) { }
        }
        public struct SubstreamSubscribePending : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly int Id;
            public SubstreamSubscribePending(int id) { }
        }
        public class SubstreamSubscription : Reactive.Streams.ISubscription
        {
            public SubstreamSubscription(Akka.Actor.IActorRef parent, int id) { }
            public void Cancel() { }
            public void Request(long elements) { }
            public override string ToString() { }
        }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class FanOut<T> : Akka.Actor.ActorBase, Akka.Streams.Implementation.IPump
    {
        protected readonly Akka.Streams.Implementation.OutputBunch<T> OutputBunch;
        protected readonly Akka.Streams.Implementation.BatchingInputBuffer PrimaryInputs;
        protected FanOut(Akka.Streams.ActorMaterializerSettings settings, int outputCount) { }
        public System.Action CurrentAction { get; set; }
        public bool IsPumpFinished { get; }
        protected Akka.Event.ILoggingAdapter Log { get; }
        public Akka.Streams.Implementation.TransferState TransferState { get; set; }
        protected void Fail(System.Exception e) { }
        public void GotUpstreamSubscription() { }
        public void InitialPhase(int waitForUpstream, Akka.Streams.Implementation.TransferPhase andThen) { }
        public void NextPhase(Akka.Streams.Implementation.TransferPhase phase) { }
        protected override void PostRestart(System.Exception reason) { }
        protected override void PostStop() { }
        public void Pump() { }
        public void PumpFailed(System.Exception e) { }
        public void PumpFinished() { }
        protected override bool Receive(object message) { }
        public void WaitForUpstream(int waitForUpstream) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class FirstOrDefaultStage<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<T>, System.Threading.Tasks.Task<T>>
    {
        public readonly Akka.Streams.Inlet<T> In;
        public FirstOrDefaultStage() { }
        public override Akka.Streams.SinkShape<T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<T>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class FlowNameCounter : Akka.Actor.ExtensionIdProvider<Akka.Streams.Implementation.FlowNameCounter>, Akka.Actor.IExtension
    {
        public readonly Akka.Util.Internal.AtomicCounterLong Counter;
        public FlowNameCounter() { }
        public override Akka.Streams.Implementation.FlowNameCounter CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.Streams.Implementation.FlowNameCounter Instance(Akka.Actor.ActorSystem system) { }
    }
    public sealed class FusedModule : Akka.Streams.Implementation.Module
    {
        public FusedModule(System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> subModules, Akka.Streams.Shape shape, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> downstreams, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> upstreams, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode materializedValueComputation, Akka.Streams.Attributes attributes, Akka.Streams.Implementation.StructuralInfoModule info) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> Downstreams { get; }
        public Akka.Streams.Implementation.StructuralInfoModule Info { get; }
        public override bool IsFused { get; }
        public override Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public override System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> Upstreams { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override string ToString() { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public interface IActorPublisher : Akka.Streams.IUntypedPublisher
    {
        void Shutdown(System.Exception reason);
        System.Collections.Generic.IEnumerable<Akka.Streams.IUntypedSubscriber> TakePendingSubscribers();
    }
    public interface IActorSubscription : Reactive.Streams.ISubscription { }
    public interface ICursor
    {
        long Cursor { get; set; }
    }
    public interface ICursors
    {
        System.Collections.Generic.IEnumerable<Akka.Streams.Implementation.ICursor> Cursors { get; }
    }
    public interface IMergeBack<TIn, TMat>
    {
        Akka.Streams.Dsl.IFlow<TOut, TMat> Apply<TOut>(Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, int breadth);
    }
    public interface IModule : System.IComparable<Akka.Streams.Implementation.IModule>
    {
        Akka.Streams.Attributes Attributes { get; }
        System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> Downstreams { get; }
        System.Collections.Immutable.IImmutableSet<Akka.Streams.InPort> InPorts { get; }
        bool IsAtomic { get; }
        bool IsBidiFlow { get; }
        bool IsCopied { get; }
        bool IsFlow { get; }
        bool IsRunnable { get; }
        bool IsSealed { get; }
        bool IsSink { get; }
        bool IsSource { get; }
        Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        System.Collections.Immutable.IImmutableSet<Akka.Streams.OutPort> OutPorts { get; }
        Akka.Streams.Shape Shape { get; }
        System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> Upstreams { get; }
        Akka.Streams.Implementation.IModule CarbonCopy();
        Akka.Streams.Implementation.IModule Compose(Akka.Streams.Implementation.IModule that);
        Akka.Streams.Implementation.IModule Compose<T1, T2, T3>(Akka.Streams.Implementation.IModule that, System.Func<T1, T2, T3> matFunc);
        Akka.Streams.Implementation.IModule ComposeNoMaterialized(Akka.Streams.Implementation.IModule that);
        Akka.Streams.Implementation.IModule Fuse(Akka.Streams.Implementation.IModule that, Akka.Streams.OutPort from, Akka.Streams.InPort to);
        Akka.Streams.Implementation.IModule Fuse<T1, T2, T3>(Akka.Streams.Implementation.IModule that, Akka.Streams.OutPort from, Akka.Streams.InPort to, System.Func<T1, T2, T3> matFunc);
        Akka.Streams.Implementation.IModule Nest();
        Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape);
        Akka.Streams.Implementation.IModule TransformMaterializedValue<TMat, TMat2>(System.Func<TMat, TMat2> mapFunc);
        Akka.Streams.Implementation.IModule Wire(Akka.Streams.OutPort from, Akka.Streams.InPort to);
        Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes);
    }
    public interface IPump
    {
        System.Action CurrentAction { get; set; }
        bool IsPumpFinished { get; }
        Akka.Streams.Implementation.TransferState TransferState { get; set; }
        void GotUpstreamSubscription();
        void InitialPhase(int waitForUpstream, Akka.Streams.Implementation.TransferPhase andThen);
        void NextPhase(Akka.Streams.Implementation.TransferPhase phase);
        void Pump();
        void PumpFailed(System.Exception e);
        void PumpFinished();
        void WaitForUpstream(int waitForUpstream);
    }
    public interface ISpecViolation { }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class IdleInject<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
        where TIn : TOut
    {
        public IdleInject(System.TimeSpan timeout, System.Func<TOut> inject) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class IdleTimeoutBidi<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.BidiShape<TIn, TIn, TOut, TOut>>
    {
        public readonly Akka.Streams.Inlet<TIn> In1;
        public readonly Akka.Streams.Inlet<TOut> In2;
        public readonly Akka.Streams.Outlet<TIn> Out1;
        public readonly Akka.Streams.Outlet<TOut> Out2;
        public readonly System.TimeSpan Timeout;
        public IdleTimeoutBidi(System.TimeSpan timeout) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.BidiShape<TIn, TIn, TOut, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Idle<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public readonly System.TimeSpan Timeout;
        public Idle(System.TimeSpan timeout) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public class static IgnorableMaterializedValueComposites
    {
        public static bool Apply(Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode composition) { }
        public static bool Apply(Akka.Streams.Implementation.IModule module) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Initial<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public readonly System.TimeSpan Timeout;
        public Initial(System.TimeSpan timeout) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public abstract class InputBunch
    {
        public readonly Akka.Streams.Implementation.TransferState AllOfMarkedInputs;
        public readonly Akka.Streams.Implementation.TransferState AnyOfMarkedInputs;
        public readonly Akka.Streams.Implementation.SubReceive SubReceive;
        protected InputBunch(int inputCount, int bufferSize, Akka.Streams.Implementation.IPump pump) { }
        public bool IsAllCompleted { get; }
        protected int LastDequeuedId { get; }
        public void Cancel() { }
        public void Cancel(int input) { }
        public object Dequeue(int id) { }
        public object DequeueAndYield() { }
        public object DequeueAndYield(int id) { }
        public object DequeuePreferring(int preferred) { }
        public int IdToDequeue() { }
        public Akka.Streams.Implementation.TransferState InputsAvailableFor(int id) { }
        public Akka.Streams.Implementation.TransferState InputsOrCompleteAvailableFor(int id) { }
        public bool IsCancelled(int index) { }
        public bool IsCompleted(int index) { }
        public bool IsDepleted(int index) { }
        public bool IsPending(int index) { }
        public void MarkAllInputs() { }
        public void MarkInput(int input) { }
        public virtual void OnCompleteWhenNoInput() { }
        public virtual void OnDepleted(int input) { }
        public abstract void OnError(int id, System.Exception cause);
        public void UnmarkAllInputs() { }
        public void UnmarkInput(int input) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class JsonObjectParser
    {
        public JsonObjectParser(int maximumObjectLength = 2147483647) { }
        public bool IsEmpty { get; }
        public void Offer(Akka.IO.ByteString input) { }
        public Akka.Util.Option<Akka.IO.ByteString> Poll() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class LastOrDefaultStage<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<T>, System.Threading.Tasks.Task<T>>
    {
        public readonly Akka.Streams.Inlet<T> In;
        public LastOrDefaultStage() { }
        public override Akka.Streams.SinkShape<T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<T>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public class static LazySource
    {
        public static Akka.Streams.Implementation.LazySource<TOut, TMat> Create<TOut, TMat>(System.Func<Akka.Streams.Dsl.Source<TOut, TMat>> create) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class LazySource<TOut, TMat> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SourceShape<TOut>, System.Threading.Tasks.Task<TMat>>
    {
        public LazySource(System.Func<Akka.Streams.Dsl.Source<TOut, TMat>> sourceFactory) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.SourceShape<TOut> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<TMat>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class MaterializerSession
    {
        protected readonly Akka.Streams.Attributes InitialAttributes;
        public static readonly bool IsDebug;
        protected readonly Akka.Streams.Implementation.IModule TopLevel;
        protected MaterializerSession(Akka.Streams.Implementation.IModule topLevel, Akka.Streams.Attributes initialAttributes) { }
        protected void AssignPort(Akka.Streams.InPort inPort, object subscriberOrVirtual) { }
        protected void AssignPort(Akka.Streams.OutPort outPort, Akka.Streams.IUntypedPublisher publisher) { }
        protected void EnterScope(Akka.Streams.Implementation.CopiedModule enclosing) { }
        protected void ExitScope(Akka.Streams.Implementation.CopiedModule enclosing) { }
        public object Materialize() { }
        protected abstract object MaterializeAtomic(Akka.Streams.Implementation.AtomicModule atomic, Akka.Streams.Attributes effectiveAttributes, System.Collections.Generic.IDictionary<Akka.Streams.Implementation.IModule, object> materializedValues);
        protected virtual object MaterializeComposite(Akka.Streams.Implementation.IModule composite, Akka.Streams.Attributes effectiveAttributes) { }
        protected object MaterializeModule(Akka.Streams.Implementation.IModule module, Akka.Streams.Attributes effectiveAttributes) { }
        protected virtual Akka.Streams.Attributes MergeAttributes(Akka.Streams.Attributes parent, Akka.Streams.Attributes current) { }
        protected void RegisterSource(Akka.Streams.Implementation.Fusing.IMaterializedValueSource materializedSource) { }
        public class MaterializationPanicException : System.Exception
        {
            public MaterializationPanicException(System.Exception innerException) { }
        }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class MaybeSource<TOut> : Akka.Streams.Implementation.SourceModule<TOut, System.Threading.Tasks.TaskCompletionSource<TOut>>
    {
        public MaybeSource(Akka.Streams.Attributes attributes, Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override Reactive.Streams.IPublisher<TOut> Create(Akka.Streams.MaterializationContext context, out System.Threading.Tasks.TaskCompletionSource<TOut> materializer) { }
        protected override Akka.Streams.Implementation.SourceModule<TOut, System.Threading.Tasks.TaskCompletionSource<TOut>> NewInstance(Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public abstract class Module : Akka.Streams.Implementation.IModule, System.IComparable<Akka.Streams.Implementation.IModule>
    {
        protected Module() { }
        public abstract Akka.Streams.Attributes Attributes { get; }
        public virtual System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> Downstreams { get; }
        public System.Collections.Immutable.IImmutableSet<Akka.Streams.InPort> InPorts { get; }
        public virtual bool IsAtomic { get; }
        public virtual bool IsBidiFlow { get; }
        public virtual bool IsCopied { get; }
        public virtual bool IsFlow { get; }
        public virtual bool IsFused { get; }
        public virtual bool IsRunnable { get; }
        public bool IsSealed { get; }
        public virtual bool IsSink { get; }
        public virtual bool IsSource { get; }
        public virtual Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        public System.Collections.Immutable.IImmutableSet<Akka.Streams.OutPort> OutPorts { get; }
        public abstract Akka.Streams.Shape Shape { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public virtual System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> Upstreams { get; }
        public abstract Akka.Streams.Implementation.IModule CarbonCopy();
        public int CompareTo(Akka.Streams.Implementation.IModule other) { }
        public virtual Akka.Streams.Implementation.IModule Compose(Akka.Streams.Implementation.IModule other) { }
        public virtual Akka.Streams.Implementation.IModule Compose<T1, T2, T3>(Akka.Streams.Implementation.IModule other, System.Func<T1, T2, T3> matFunc) { }
        public Akka.Streams.Implementation.IModule ComposeNoMaterialized(Akka.Streams.Implementation.IModule that) { }
        public virtual Akka.Streams.Implementation.IModule Fuse(Akka.Streams.Implementation.IModule other, Akka.Streams.OutPort from, Akka.Streams.InPort to) { }
        public virtual Akka.Streams.Implementation.IModule Fuse<T1, T2, T3>(Akka.Streams.Implementation.IModule other, Akka.Streams.OutPort from, Akka.Streams.InPort to, System.Func<T1, T2, T3> matFunc) { }
        public virtual Akka.Streams.Implementation.IModule Nest() { }
        public abstract Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape);
        public virtual Akka.Streams.Implementation.IModule TransformMaterializedValue<TMat, TMat2>(System.Func<TMat, TMat2> mapFunc) { }
        public virtual Akka.Streams.Implementation.IModule Wire(Akka.Streams.OutPort from, Akka.Streams.InPort to) { }
        public abstract Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes);
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class NoopSubscriptionTimeout : Akka.Actor.ICancelable
    {
        public static readonly Akka.Streams.Implementation.NoopSubscriptionTimeout Instance;
        public bool IsCancellationRequested { get; }
        public System.Threading.CancellationToken Token { get; }
        public void Cancel() { }
        public void Cancel(bool throwOnFirstException) { }
        public void CancelAfter(System.TimeSpan delay) { }
        public void CancelAfter(int millisecondsDelay) { }
    }
    public class NormalShutdownException : Akka.Pattern.IllegalStateException
    {
        public NormalShutdownException(string message) { }
    }
    public class NothingToReadException : System.Exception
    {
        public static readonly Akka.Streams.Implementation.NothingToReadException Instance;
    }
    public class OutputBunch<T>
    {
        public readonly Akka.Streams.Implementation.TransferState AllOfMarkedOutputs;
        public readonly Akka.Streams.Implementation.TransferState AnyOfMarkedOutputs;
        public readonly Akka.Streams.Implementation.SubReceive SubReceive;
        public OutputBunch(int outputCount, Akka.Actor.IActorRef impl, Akka.Streams.Implementation.IPump pump) { }
        public void Cancel(System.Exception e) { }
        public void Complete() { }
        public void Complete(int output) { }
        public Akka.Streams.Implementation.TransferState DemandAvailableFor(int id) { }
        public Akka.Streams.Implementation.TransferState DemandOrCancelAvailableFor(int id) { }
        public void Enqueue(int id, T element) { }
        public void EnqueueAndPrefer(T element, int preferred) { }
        public void EnqueueAndYield(T element) { }
        public void EnqueueMarked(T element) { }
        public void Error(int output, System.Exception e) { }
        public int IdToEnqueue() { }
        public int IdToEnqueueAndYield() { }
        public bool IsCancelled(int output) { }
        public bool IsCompleted(int output) { }
        public bool IsErrored(int output) { }
        public bool IsPending(int output) { }
        public void MarkAllOutputs() { }
        public void MarkOutput(int output) { }
        public void OnCancel(int output) { }
        public void UnmarkAllOutputs() { }
        public void UnmarkCancelledOutputs(bool enabled) { }
        public void UnmarkOutput(int output) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ProcessorModule<TIn, TOut, TMat> : Akka.Streams.Implementation.AtomicModule
    {
        public ProcessorModule(System.Func<System.ValueTuple<Reactive.Streams.IProcessor<TIn, TOut>, TMat>> createProcessor, Akka.Streams.Attributes attributes = null) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public Akka.Streams.Inlet In { get; }
        public Akka.Streams.Outlet Out { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public System.ValueTuple<object, object> CreateProcessor() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class PublisherSource<TOut> : Akka.Streams.Implementation.SourceModule<TOut, Akka.NotUsed>
    {
        public PublisherSource(Reactive.Streams.IPublisher<TOut> publisher, Akka.Streams.Attributes attributes, Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        protected override string Label { get; }
        public override Reactive.Streams.IPublisher<TOut> Create(Akka.Streams.MaterializationContext context, out Akka.NotUsed materializer) { }
        protected override Akka.Streams.Implementation.SourceModule<TOut, Akka.NotUsed> NewInstance(Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class QueueSink<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<T>, Akka.Streams.ISinkQueue<T>>
    {
        public readonly Akka.Streams.Inlet<T> In;
        public QueueSink() { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.SinkShape<T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<Akka.Streams.ISinkQueue<T>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class QueueSource<TOut> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SourceShape<TOut>, Akka.Streams.ISourceQueueWithComplete<TOut>>
    {
        public QueueSource(int maxBuffer, Akka.Streams.OverflowStrategy overflowStrategy) { }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.SourceShape<TOut> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<Akka.Streams.ISourceQueueWithComplete<TOut>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public interface IInput<TOut> { }
        public sealed class Materialized<TOut> : Akka.Streams.ISourceQueueWithComplete<TOut>, Akka.Streams.ISourceQueue<TOut>
        {
            public Materialized(System.Action<Akka.Streams.Implementation.QueueSource<TOut>.IInput> invokeLogic, System.Threading.Tasks.TaskCompletionSource<object> completion) { }
            public void Complete() { }
            public void Fail(System.Exception ex) { }
            public System.Threading.Tasks.Task<Akka.Streams.IQueueOfferResult> OfferAsync(TOut element) { }
            public System.Threading.Tasks.Task WatchCompletionAsync() { }
        }
    }
    public class static ReactiveStreamsCompliance
    {
        public const string CanNotSubscribeTheSameSubscriberMultipleTimes = "can not subscribe the same subscriber multiple times (see reactive-streams specif" +
            "ication, rules 1.10 and 2.12)";
        public static readonly System.Exception CanNotSubscribeTheSameSubscriberMultipleTimesException;
        public static readonly System.Exception ElementMustNotBeNullException;
        public const string ElementMustNotBeNullMsg = "Element must not be null, rule 2.13";
        public const string ExceptionMustNotBeNullMsg = "Exception must not be null, rule 2.13";
        public static readonly System.Exception NumberOfElementsInRequestMustBePositiveException;
        public const string NumberOfElementsInRequestMustBePositiveMsg = "The number of requested elements must be > 0 (see reactive-streams specification," +
            " rule 3.9)";
        public const string SubscriberMustNotBeNullMsg = "Subscriber must not be null, rule 1.9";
        public static readonly System.Exception SubscriptionMustNotBeNullException;
        public const string SubscriptionMustNotBeNullMsg = "Subscription must not be null, rule 2.13";
        public const string SupportsOnlyASingleSubscriber = "only supports one subscriber (which is allowed, see reactive-streams specificatio" +
            "n, rule 1.12)";
        public static System.Exception ExceptionMustNotBeNullException { get; }
        public static System.Exception SubscriberMustNotBeNullException { get; }
        public static void RejectAdditionalSubscriber<T>(Reactive.Streams.ISubscriber<T> subscriber, string rejector) { }
        public static void RejectDueToNonPositiveDemand<T>(Reactive.Streams.ISubscriber<T> subscriber) { }
        public static void RejectDuplicateSubscriber<T>(Reactive.Streams.ISubscriber<T> subscriber) { }
        public static void RequireNonNullElement(object element) { }
        public static void RequireNonNullException(System.Exception exception) { }
        public static void RequireNonNullSubscriber<T>(Reactive.Streams.ISubscriber<T> subscriber) { }
        public static void RequireNonNullSubscription(Reactive.Streams.ISubscription subscription) { }
        public static void TryCancel(Reactive.Streams.ISubscription subscription) { }
        public static void TryOnComplete<T>(Reactive.Streams.ISubscriber<T> subscriber) { }
        public static void TryOnError<T>(Reactive.Streams.ISubscriber<T> subscriber, System.Exception cause) { }
        public static void TryOnNext<T>(Reactive.Streams.ISubscriber<T> subscriber, T element) { }
        public static void TryOnSubscribe<T>(Reactive.Streams.ISubscriber<T> subscriber, Reactive.Streams.ISubscription subscription) { }
        public static void TryRequest(Reactive.Streams.ISubscription subscription, long demand) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class ResizableMultiReaderRingBuffer<T>
    {
        protected readonly Akka.Streams.Implementation.ICursors Cursors;
        public ResizableMultiReaderRingBuffer(long initialSize, long maxSize, Akka.Streams.Implementation.ICursors cursors) { }
        public long AvailableData { get; }
        public long CapacityLeft { get; }
        public long ImmediatelyAvailable { get; }
        public bool IsEmpty { get; }
        public long Length { get; }
        public bool NonEmpty { get; }
        protected T[] UnderlyingArray { get; }
        public long Count(Akka.Streams.Implementation.ICursor cursor) { }
        public void InitCursor(Akka.Streams.Implementation.ICursor cursor) { }
        public void OnCursorRemoved(Akka.Streams.Implementation.ICursor cursor) { }
        public T Read(Akka.Streams.Implementation.ICursor cursor) { }
        public override string ToString() { }
        public bool Write(T value) { }
    }
    public class RetainingMultiReaderBuffer<T>
    {
        protected readonly Akka.Streams.Implementation.ICursors Cursors;
        public RetainingMultiReaderBuffer(long initialSize, long maxSize, Akka.Streams.Implementation.ICursors cursors) { }
        public long AvailableData { get; }
        protected T[] Buffer { get; }
        public long CapacityLeft { get; }
        public bool IsEmpty { get; }
        public long Length { get; }
        public long Count(Akka.Streams.Implementation.ICursor cursor) { }
        public void InitCursor(Akka.Streams.Implementation.ICursor cursor) { }
        public void OnCursorRemoved(Akka.Streams.Implementation.ICursor cursor) { }
        public T Read(Akka.Streams.Implementation.ICursor cursor) { }
        public override string ToString() { }
        public virtual bool Write(T value) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SeqStage<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<T>, System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<T>>>
    {
        public readonly Akka.Streams.Inlet<T> In;
        public SeqStage() { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.SinkShape<T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<System.Collections.Immutable.IImmutableList<T>>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public class SignalThrewException : Akka.Pattern.IllegalStateException, Akka.Streams.Implementation.ISpecViolation
    {
        public SignalThrewException(string message, System.Exception cause) { }
    }
    public class SimpleOutputs
    {
        public readonly Akka.Actor.IActorRef Actor;
        protected long DownstreamDemand;
        protected Akka.Streams.Implementation.IActorPublisher ExposedPublisher;
        protected bool IsDownstreamCompleted;
        public readonly Akka.Streams.Implementation.IPump Pump;
        protected Akka.Streams.IUntypedSubscriber Subscriber;
        public SimpleOutputs(Akka.Actor.IActorRef actor, Akka.Streams.Implementation.IPump pump) { }
        public long DemandCount { get; }
        public bool IsClosed { get; }
        public bool IsDemandAvailable { get; }
        public bool IsOpen { get; }
        public bool IsSubscribed { get; }
        public Akka.Streams.Implementation.TransferState NeedsDemand { get; }
        public Akka.Streams.Implementation.TransferState NeedsDemandOrCancel { get; }
        public virtual Akka.Streams.Implementation.SubReceive SubReceive { get; }
        public virtual void Cancel() { }
        public virtual void Complete() { }
        protected Reactive.Streams.ISubscription CreateSubscription() { }
        protected bool DownstreamRunning(object message) { }
        public void EnqueueOutputElement(object element) { }
        public virtual void Error(System.Exception e) { }
        protected bool WaitingExposedPublisher(object message) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class SinkModule<TIn, TMat> : Akka.Streams.Implementation.AtomicModule
    {
        protected SinkModule(Akka.Streams.SinkShape<TIn> shape) { }
        protected virtual string Label { get; }
        public override Akka.Streams.Shape Shape { get; }
        protected Akka.Streams.SinkShape<TIn> AmendShape(Akka.Streams.Attributes attrs) { }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public abstract object Create(Akka.Streams.MaterializationContext context, out TMat materializer);
        protected abstract Akka.Streams.Implementation.SinkModule<TIn, TMat> NewInstance(Akka.Streams.SinkShape<TIn> shape);
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public virtual string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SinkholeSubscriber<TIn> : Reactive.Streams.ISubscriber<TIn>
    {
        public SinkholeSubscriber(System.Threading.Tasks.TaskCompletionSource<Akka.NotUsed> whenCompleted) { }
        public void OnComplete() { }
        public void OnError(System.Exception cause) { }
        public void OnNext(TIn element) { }
        public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class SourceModule<TOut, TMat> : Akka.Streams.Implementation.AtomicModule
    {
        protected SourceModule(Akka.Streams.SourceShape<TOut> shape) { }
        protected virtual string Label { get; }
        public override Akka.Streams.Shape Shape { get; }
        protected Akka.Streams.SourceShape<TOut> AmendShape(Akka.Streams.Attributes attributes) { }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public abstract Reactive.Streams.IPublisher<TOut> Create(Akka.Streams.MaterializationContext context, out TMat materializer);
        protected abstract Akka.Streams.Implementation.SourceModule<TOut, TMat> NewInstance(Akka.Streams.SourceShape<TOut> shape);
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public virtual string ToString() { }
    }
    public class static StreamLayout
    {
        public static readonly bool IsDebug;
        public static void Validate(Akka.Streams.Implementation.IModule module, int level = 0, bool shouldPrint = False, System.Collections.Generic.IDictionary<object, int> idMap = null) { }
        public sealed class Atomic : Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode
        {
            public readonly Akka.Streams.Implementation.IModule Module;
            public Atomic(Akka.Streams.Implementation.IModule module) { }
            public override string ToString() { }
        }
        public sealed class Combine : Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode
        {
            public readonly System.Func<object, object, object> Combinator;
            public readonly Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode Left;
            public readonly Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode Right;
            public Combine(System.Func<object, object, object> combinator, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode left, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode right) { }
            public override string ToString() { }
        }
        public interface IMaterializedValueNode { }
        public sealed class Ignore : Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode
        {
            public static readonly Akka.Streams.Implementation.StreamLayout.Ignore Instance;
            public override string ToString() { }
        }
        public sealed class Transform : Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode
        {
            public readonly Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode Node;
            public readonly System.Func<object, object> Transformator;
            public Transform(System.Func<object, object> transformator, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode node) { }
            public override string ToString() { }
        }
    }
    public class StreamSupervisor : Akka.Actor.ActorBase
    {
        public readonly Akka.Util.AtomicBoolean HaveShutdown;
        public readonly Akka.Streams.ActorMaterializerSettings Settings;
        public StreamSupervisor(Akka.Streams.ActorMaterializerSettings settings, Akka.Util.AtomicBoolean haveShutdown) { }
        public static string NextName() { }
        protected override void PostStop() { }
        public static Akka.Actor.Props Props(Akka.Streams.ActorMaterializerSettings settings, Akka.Util.AtomicBoolean haveShutdown) { }
        protected override bool Receive(object message) { }
        protected override Akka.Actor.SupervisorStrategy SupervisorStrategy() { }
        public sealed class Children
        {
            public readonly System.Collections.Immutable.IImmutableSet<Akka.Actor.IActorRef> Refs;
            public Children(System.Collections.Immutable.IImmutableSet<Akka.Actor.IActorRef> refs) { }
        }
        public sealed class GetChildren
        {
            public static readonly Akka.Streams.Implementation.StreamSupervisor.GetChildren Instance;
        }
        public sealed class Materialize : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            public readonly string Name;
            public readonly Akka.Actor.Props Props;
            public Materialize(Akka.Actor.Props props, string name) { }
        }
        public sealed class PrintDebugDump
        {
            public static readonly Akka.Streams.Implementation.StreamSupervisor.PrintDebugDump Instance;
        }
        public sealed class StopChildren
        {
            public static readonly Akka.Streams.Implementation.StreamSupervisor.StopChildren Instance;
        }
        public sealed class StoppedChildren
        {
            public static readonly Akka.Streams.Implementation.StreamSupervisor.StoppedChildren Instance;
        }
    }
    public sealed class StructuralInfoModule : Akka.Streams.Implementation.Module
    {
        public StructuralInfoModule(System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> subModules, Akka.Streams.Shape shape, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> downstreams, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> upstreams, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.Implementation.IModule> inOwners, System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.Implementation.IModule> outOwners, System.Collections.Immutable.IImmutableList<System.ValueTuple<Akka.Streams.Implementation.IModule, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode>> materializedValues, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode materializedValueComputation, Akka.Streams.Attributes attributes) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.InPort> Downstreams { get; }
        public System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.Implementation.IModule> InOwners { get; }
        public override bool IsFused { get; }
        public override Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode MaterializedValueComputation { get; }
        public System.Collections.Immutable.IImmutableList<System.ValueTuple<Akka.Streams.Implementation.IModule, Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode>> MaterializedValues { get; }
        public System.Collections.Immutable.IImmutableDictionary<Akka.Streams.OutPort, Akka.Streams.Implementation.IModule> OutOwners { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override System.Collections.Immutable.ImmutableArray<Akka.Streams.Implementation.IModule> SubModules { get; }
        public override System.Collections.Immutable.IImmutableDictionary<Akka.Streams.InPort, Akka.Streams.OutPort> Upstreams { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class SubFlowImpl<TIn, TOut, TMat, TClosed> : Akka.Streams.Dsl.SubFlow<TOut, TMat, TClosed>
    {
        public SubFlowImpl(Akka.Streams.Dsl.Flow<TIn, TOut, TMat> flow, Akka.Streams.Implementation.IMergeBack<TIn, TMat> mergeBackFunction, System.Func<Akka.Streams.Dsl.Sink<TIn, TMat>, TClosed> finishFunction) { }
        public Akka.Streams.Dsl.Flow<TIn, TOut, TMat> Flow { get; }
        public override Akka.Streams.Dsl.IFlow<TOut, TMat2> MapMaterializedValue<TMat2>(System.Func<TMat, TMat2> mapFunc) { }
        public override Akka.Streams.Dsl.IFlow<TOut, TMat> MergeSubstreamsWithParallelism(int parallelism) { }
        public override TMat2 RunWith<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink, Akka.Streams.IMaterializer materializer) { }
        public override TClosed To<TMat2>(Akka.Streams.IGraph<Akka.Streams.SinkShape<TOut>, TMat2> sink) { }
        public override Akka.Streams.Dsl.IFlow<T2, TMat> Via<T2, TMat2>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow) { }
        public override Akka.Streams.Dsl.IFlow<T2, TMat3> ViaMaterialized<T2, TMat2, TMat3>(Akka.Streams.IGraph<Akka.Streams.FlowShape<TOut, T2>, TMat2> flow, System.Func<TMat, TMat2, TMat3> combine) { }
        public Akka.Streams.Implementation.SubFlowImpl<TIn, TOut, TMat, TClosed> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class SubFusingActorMaterializerImpl : Akka.Streams.IMaterializer
    {
        public SubFusingActorMaterializerImpl(Akka.Streams.Implementation.ExtendedActorMaterializer delegateMaterializer, System.Func<Akka.Streams.Implementation.Fusing.GraphInterpreterShell, Akka.Actor.IActorRef> registerShell) { }
        public Akka.Dispatch.MessageDispatcher ExecutionContext { get; }
        public TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable) { }
        public TMat Materialize<TMat>(Akka.Streams.IGraph<Akka.Streams.ClosedShape, TMat> runnable, Akka.Streams.Attributes initialAttributes) { }
        public Akka.Actor.ICancelable ScheduleOnce(System.TimeSpan delay, System.Action action) { }
        public Akka.Actor.ICancelable ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }
        public Akka.Streams.IMaterializer WithNamePrefix(string namePrefix) { }
    }
    public class SubReceive
    {
        public SubReceive(Akka.Actor.Receive initial) { }
        public Akka.Actor.Receive CurrentReceive { get; }
        public void Become(Akka.Actor.Receive receive) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SubscriberSink<TIn> : Akka.Streams.Implementation.SinkModule<TIn, Akka.NotUsed>
    {
        public SubscriberSink(Reactive.Streams.ISubscriber<TIn> subscriber, Akka.Streams.Attributes attributes, Akka.Streams.SinkShape<TIn> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override object Create(Akka.Streams.MaterializationContext context, out Akka.NotUsed materializer) { }
        protected override Akka.Streams.Implementation.SinkModule<TIn, Akka.NotUsed> NewInstance(Akka.Streams.SinkShape<TIn> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SubscriberSource<TOut> : Akka.Streams.Implementation.SourceModule<TOut, Reactive.Streams.ISubscriber<TOut>>
    {
        public SubscriberSource(Akka.Streams.Attributes attributes, Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override Reactive.Streams.IPublisher<TOut> Create(Akka.Streams.MaterializationContext context, out Reactive.Streams.ISubscriber<TOut> materializer) { }
        protected override Akka.Streams.Implementation.SourceModule<TOut, Reactive.Streams.ISubscriber<TOut>> NewInstance(Akka.Streams.SourceShape<TOut> shape) { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class SubscriptionTimeoutException : System.Exception
    {
        public SubscriptionTimeoutException(string message) { }
        public SubscriptionTimeoutException(string message, System.Exception innerException) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class Throttle<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Throttle(int cost, System.TimeSpan per, int maximumBurst, System.Func<T, int> costCalculation, Akka.Streams.ThrottleMode mode) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class static Timers
    {
        public const string GraphStageLogicTimer = "GraphStageLogicTimer";
        public static System.TimeSpan IdleTimeoutCheckInterval(System.TimeSpan timeout) { }
    }
    public struct TransferPhase
    {
        public readonly System.Action Action;
        public readonly Akka.Streams.Implementation.TransferState Precondition;
        public TransferPhase(Akka.Streams.Implementation.TransferState precondition, System.Action action) { }
    }
    public abstract class TransferState
    {
        protected TransferState() { }
        public abstract bool IsCompleted { get; }
        public bool IsExecutable { get; }
        public abstract bool IsReady { get; }
        public Akka.Streams.Implementation.TransferState And(Akka.Streams.Implementation.TransferState other) { }
        public Akka.Streams.Implementation.TransferState Or(Akka.Streams.Implementation.TransferState other) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class UnfoldAsync<TState, TElement> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<TElement>>
    {
        public readonly Akka.Streams.Outlet<TElement> Out;
        public readonly TState State;
        public readonly System.Func<TState, System.Threading.Tasks.Task<Akka.Util.Option<System.ValueTuple<TState, TElement>>>> UnfoldFunc;
        public UnfoldAsync(TState state, System.Func<TState, System.Threading.Tasks.Task<Akka.Util.Option<System.ValueTuple<TState, TElement>>>> unfoldFunc) { }
        public override Akka.Streams.SourceShape<TElement> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class UnfoldInfinite<TState, TElement> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<TElement>>
    {
        public readonly Akka.Streams.Outlet<TElement> Out;
        public readonly TState State;
        public readonly System.Func<TState, System.ValueTuple<TState, TElement>> UnfoldFunc;
        public UnfoldInfinite(TState state, System.Func<TState, System.ValueTuple<TState, TElement>> unfoldFunc) { }
        public override Akka.Streams.SourceShape<TElement> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class UnfoldResourceSourceAsync<TOut, TSource> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<TOut>>
    {
        public UnfoldResourceSourceAsync(System.Func<System.Threading.Tasks.Task<TSource>> create, System.Func<TSource, System.Threading.Tasks.Task<Akka.Util.Option<TOut>>> readData, System.Func<TSource, System.Threading.Tasks.Task> close) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.SourceShape<TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class UnfoldResourceSource<TOut, TSource> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<TOut>>
    {
        public UnfoldResourceSource(System.Func<TSource> create, System.Func<TSource, Akka.Util.Option<TOut>> readData, System.Action<TSource> close) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.SourceShape<TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class Unfold<TState, TElement> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<TElement>>
    {
        public readonly Akka.Streams.Outlet<TElement> Out;
        public readonly TState State;
        public readonly System.Func<TState, Akka.Util.Option<System.ValueTuple<TState, TElement>>> UnfoldFunc;
        public Unfold(TState state, System.Func<TState, Akka.Util.Option<System.ValueTuple<TState, TElement>>> unfoldFunc) { }
        public override Akka.Streams.SourceShape<TElement> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class VirtualProcessor<T> : Akka.Util.AtomicReference<object>, Reactive.Streams.IProcessor<T, T>, Reactive.Streams.IPublisher<T>, Reactive.Streams.ISubscriber<T>
    {
        public VirtualProcessor() { }
        public void OnComplete() { }
        public void OnError(System.Exception cause) { }
        public void OnNext(T element) { }
        public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
        public void Subscribe(Reactive.Streams.ISubscriber<T> subscriber) { }
    }
}
namespace Akka.Streams.Implementation.Fusing
{
    [Akka.Annotations.InternalApiAttribute()]
    public class ActorGraphInterpreter : Akka.Actor.ActorBase
    {
        public ActorGraphInterpreter(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell) { }
        public Akka.Event.ILoggingAdapter Log { get; }
        protected override void PostStop() { }
        protected override void PreStart() { }
        public static Akka.Actor.Props Props(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell) { }
        protected override bool Receive(object message) { }
        public Akka.Actor.IActorRef RegisterShell(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell) { }
        public struct Abort : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public Abort(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct AsyncInput : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly object Event;
            public readonly System.Action<object> Handler;
            public readonly Akka.Streams.Stage.GraphStageLogic Logic;
            public AsyncInput(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, Akka.Streams.Stage.GraphStageLogic logic, object @event, System.Action<object> handler) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public class BatchingActorInputBoundary : Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic
        {
            public BatchingActorInputBoundary(int size, int id) { }
            public override Akka.Streams.Outlet Out { get; }
            public void Cancel() { }
            public void OnComplete() { }
            public void OnError(System.Exception reason) { }
            public void OnInternalError(System.Exception reason) { }
            public void OnNext(object element) { }
            public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
            public override string ToString() { }
        }
        public sealed class BoundaryPublisher<T> : Akka.Streams.Implementation.ActorPublisher<T>
        {
            public BoundaryPublisher(Akka.Actor.IActorRef parent, Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id) { }
            protected override object WakeUpMessage { get; }
        }
        public sealed class BoundarySubscriber<T> : Reactive.Streams.ISubscriber<T>
        {
            public BoundarySubscriber(Akka.Actor.IActorRef parent, Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id) { }
            public void OnComplete() { }
            public void OnError(System.Exception cause) { }
            public void OnNext(T element) { }
            public void OnSubscribe(Reactive.Streams.ISubscription subscription) { }
        }
        public sealed class BoundarySubscription : Reactive.Streams.ISubscription
        {
            public BoundarySubscription(Akka.Actor.IActorRef parent, Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id) { }
            public void Cancel() { }
            public void Request(long elements) { }
            public override string ToString() { }
        }
        public struct Cancel : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly int Id;
            public Cancel(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct ExposedPublisher : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly int Id;
            public readonly Akka.Streams.Implementation.IActorPublisher Publisher;
            public ExposedPublisher(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id, Akka.Streams.Implementation.IActorPublisher publisher) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public interface IBoundaryEvent : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression
        {
            Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct OnComplete : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly int Id;
            public OnComplete(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct OnError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly System.Exception Cause;
            public readonly int Id;
            public OnError(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id, System.Exception cause) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct OnNext : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly object Event;
            public readonly int Id;
            public OnNext(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id, object @event) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct OnSubscribe : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly int Id;
            public readonly Reactive.Streams.ISubscription Subscription;
            public OnSubscribe(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id, Reactive.Streams.ISubscription subscription) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct RequestMore : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly long Demand;
            public readonly int Id;
            public RequestMore(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id, long demand) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct Resume : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public Resume(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
        public struct SubscribePending : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent
        {
            public readonly int Id;
            public SubscribePending(Akka.Streams.Implementation.Fusing.GraphInterpreterShell shell, int id) { }
            public Akka.Streams.Implementation.Fusing.GraphInterpreterShell Shell { get; }
        }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class AggregateAsync<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public AggregateAsync(TOut zero, System.Func<TOut, TIn, System.Threading.Tasks.Task<TOut>> aggregate) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Aggregate<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public Aggregate(TOut zero, System.Func<TOut, TIn, TOut> aggregate) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Batch<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public Batch(long max, System.Func<TIn, long> costFunc, System.Func<TIn, TOut> seed, System.Func<TOut, TIn, TOut> aggregate) { }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Buffer<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Buffer(int count, Akka.Streams.OverflowStrategy overflowStrategy) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Collect<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public Collect(System.Func<TIn, TOut> func) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Delay<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Delay(System.TimeSpan delay, Akka.Streams.DelayOverflowStrategy strategy) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Detacher<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Detacher() { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Expand<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public Expand(System.Func<TIn, System.Collections.Generic.IEnumerator<TOut>> extrapolate) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class GraphAssembly
    {
        public readonly int[] InletOwners;
        public readonly Akka.Streams.Inlet[] Inlets;
        public readonly Akka.Streams.Attributes[] OriginalAttributes;
        public readonly int[] OutletOwners;
        public readonly Akka.Streams.Outlet[] Outlets;
        public readonly Akka.Streams.Stage.IGraphStageWithMaterializedValue<, >[] Stages;
        public GraphAssembly(Akka.Streams.Stage.IGraphStageWithMaterializedValue<, >[] stages, Akka.Streams.Attributes[] originalAttributes, Akka.Streams.Inlet[] inlets, int[] inletOwners, Akka.Streams.Outlet[] outlets, int[] outletOwners) { }
        public int ConnectionCount { get; }
        public static Akka.Streams.Implementation.Fusing.GraphAssembly Create(System.Collections.Generic.IList<Akka.Streams.Inlet> inlets, System.Collections.Generic.IList<Akka.Streams.Outlet> outlets, System.Collections.Generic.IList<Akka.Streams.Stage.IGraphStageWithMaterializedValue<Akka.Streams.Shape, object>> stages) { }
        public System.ValueTuple<Connection[], Akka.Streams.Stage.GraphStageLogic[]> Materialize(Akka.Streams.Attributes inheritedAttributes, Akka.Streams.Implementation.IModule[] copiedModules, System.Collections.Generic.IDictionary<Akka.Streams.Implementation.IModule, object> materializedValues, System.Action<Akka.Streams.Implementation.Fusing.IMaterializedValueSource> register) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class GraphInterpreter
    {
        public readonly Akka.Streams.Implementation.Fusing.GraphAssembly Assembly;
        public const int Boundary = -1;
        public readonly Connection[] Connections;
        public readonly bool FuzzingMode;
        public const int InClosed = 16;
        public const int InFailed = 64;
        public const int InReady = 1;
        public const bool IsDebug = false;
        public const int KeepGoingFlag = 67108864;
        public const int KeepGoingMask = 67108863;
        public readonly Akka.Event.ILoggingAdapter Log;
        public readonly Akka.Streams.Stage.GraphStageLogic[] Logics;
        public readonly Akka.Streams.IMaterializer Materializer;
        public const Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection NoEvent = null;
        public readonly System.Action<Akka.Streams.Stage.GraphStageLogic, object, System.Action<object>> OnAsyncInput;
        public const int OutClosed = 32;
        public const int OutReady = 8;
        public const int PullEndFlip = 10;
        public const int PullStartFlip = 3;
        public const int Pulling = 2;
        public const int PushEndFlip = 5;
        public const int PushStartFlip = 12;
        public const int Pushing = 4;
        public int RunningStagesCount;
        public static readonly Akka.Streams.Attributes[] SingleNoAttribute;
        public GraphInterpreter(Akka.Streams.Implementation.Fusing.GraphAssembly assembly, Akka.Streams.IMaterializer materializer, Akka.Event.ILoggingAdapter log, Akka.Streams.Stage.GraphStageLogic[] logics, Connection[] connections, System.Action<Akka.Streams.Stage.GraphStageLogic, object, System.Action<object>> onAsyncInput, bool fuzzingMode, Akka.Actor.IActorRef context) { }
        public Akka.Actor.IActorRef Context { get; }
        public static Akka.Streams.Implementation.Fusing.GraphInterpreter Current { get; }
        public static Akka.Streams.Implementation.Fusing.GraphInterpreter CurrentInterpreterOrNull { get; }
        public bool IsCompleted { get; }
        public bool IsSuspended { get; }
        public void AttachDownstreamBoundary(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection connection, Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic logic) { }
        public void AttachDownstreamBoundary(int connection, Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic logic) { }
        public void AttachUpstreamBoundary(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection connection, Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic logic) { }
        public void AttachUpstreamBoundary(int connection, Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic logic) { }
        public void DumpWaits() { }
        public void Enqueue(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection connection) { }
        public int Execute(int eventLimit) { }
        public void Finish() { }
        public void Init(Akka.Streams.IMaterializer subMaterializer) { }
        public void RunAsyncInput(Akka.Streams.Stage.GraphStageLogic logic, object evt, System.Action<object> handler) { }
        public void SetHandler(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection connection, Akka.Streams.Stage.IInHandler handler) { }
        public void SetHandler(Akka.Streams.Implementation.Fusing.GraphInterpreter.Connection connection, Akka.Streams.Stage.IOutHandler handler) { }
        public override string ToString() { }
        [Akka.Annotations.InternalApiAttribute()]
        public sealed class Connection
        {
            public Connection(int id, int inOwnerId, Akka.Streams.Stage.GraphStageLogic inOwner, int outOwnerId, Akka.Streams.Stage.GraphStageLogic outOwner, Akka.Streams.Stage.IInHandler inHandler, Akka.Streams.Stage.IOutHandler outHandler) { }
            public int Id { get; }
            public Akka.Streams.Stage.IInHandler InHandler { get; set; }
            public Akka.Streams.Stage.GraphStageLogic InOwner { get; }
            public int InOwnerId { get; }
            public Akka.Streams.Stage.IOutHandler OutHandler { get; set; }
            public Akka.Streams.Stage.GraphStageLogic OutOwner { get; }
            public int OutOwnerId { get; }
            public int PortState { get; set; }
            public object Slot { get; set; }
            public override string ToString() { }
        }
        public abstract class DownstreamBoundaryStageLogic : Akka.Streams.Stage.GraphStageLogic
        {
            protected DownstreamBoundaryStageLogic() { }
            public abstract Akka.Streams.Inlet In { get; }
        }
        public sealed class Empty
        {
            public static readonly Akka.Streams.Implementation.Fusing.GraphInterpreter.Empty Instance;
            public override string ToString() { }
        }
        public sealed class Failed
        {
            public readonly object PreviousElement;
            public readonly System.Exception Reason;
            public Failed(System.Exception reason, object previousElement) { }
        }
        public abstract class UpstreamBoundaryStageLogic : Akka.Streams.Stage.GraphStageLogic
        {
            protected UpstreamBoundaryStageLogic() { }
            public abstract Akka.Streams.Outlet Out { get; }
        }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class GraphInterpreterShell
    {
        public GraphInterpreterShell(Akka.Streams.Implementation.Fusing.GraphAssembly assembly, Connection[] connections, Akka.Streams.Stage.GraphStageLogic[] logics, Akka.Streams.Shape shape, Akka.Streams.ActorMaterializerSettings settings, Akka.Streams.Implementation.ExtendedActorMaterializer materializer) { }
        public bool CanShutdown { get; }
        public Akka.Streams.Implementation.Fusing.GraphInterpreter Interpreter { get; }
        public bool IsInitialized { get; }
        public bool IsTerminated { get; }
        public Akka.Event.ILoggingAdapter Log { get; }
        public Akka.Actor.IActorRef Self { get; }
        public int Init(Akka.Actor.IActorRef self, Akka.Streams.Implementation.SubFusingActorMaterializerImpl subMat, System.Action<object> enqueueToShourtCircuit, int eventLimit) { }
        public int Receive(Akka.Streams.Implementation.Fusing.ActorGraphInterpreter.IBoundaryEvent e, int eventLimit) { }
        public override string ToString() { }
        public void TryAbort(System.Exception reason) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class GraphModule : Akka.Streams.Implementation.AtomicModule
    {
        public readonly Akka.Streams.Implementation.Fusing.GraphAssembly Assembly;
        public readonly Akka.Streams.Implementation.IModule[] MaterializedValueIds;
        public GraphModule(Akka.Streams.Implementation.Fusing.GraphAssembly assembly, Akka.Streams.Shape shape, Akka.Streams.Attributes attributes, Akka.Streams.Implementation.IModule[] materializedValueIds) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape newShape) { }
        public override string ToString() { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class GraphStageModule : Akka.Streams.Implementation.AtomicModule
    {
        public readonly Akka.Streams.Stage.IGraphStageWithMaterializedValue<Akka.Streams.Shape, object> Stage;
        public GraphStageModule(Akka.Streams.Shape shape, Akka.Streams.Attributes attributes, Akka.Streams.Stage.IGraphStageWithMaterializedValue<Akka.Streams.Shape, object> stage) { }
        public override Akka.Streams.Attributes Attributes { get; }
        public override Akka.Streams.Shape Shape { get; }
        public override Akka.Streams.Implementation.IModule CarbonCopy() { }
        public override Akka.Streams.Implementation.IModule ReplaceShape(Akka.Streams.Shape shape) { }
        public override string ToString() { }
        public override Akka.Streams.Implementation.IModule WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public class static GraphStages
    {
        public static Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T> Identity<T>() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class GroupedWithin<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>>>
    {
        public GroupedWithin(int count, System.TimeSpan timeout) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Grouped<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>>>
    {
        public Grouped(int count) { }
        public Akka.Streams.Inlet<T> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<System.Collections.Generic.IEnumerable<T>> Out { get; }
        public override Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public interface IMaterializedValueSource
    {
        Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode Computation { get; }
        Akka.Streams.Implementation.IModule Module { get; }
        Akka.Streams.Outlet Outlet { get; }
        Akka.Streams.Implementation.Fusing.IMaterializedValueSource CopySource();
        void SetValue(object result);
    }
    public sealed class Identity<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public static readonly Akka.Streams.Implementation.Fusing.Identity<T> Instance;
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class IgnoreSink<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<T>, System.Threading.Tasks.Task>
    {
        public IgnoreSink() { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Inlet<T> Inlet { get; }
        public override Akka.Streams.SinkShape<T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Intersperse<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Intersperse(T inject) { }
        public Intersperse(T start, T inject, T end) { }
        public bool InjectStartEnd { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class LimitWeighted<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public LimitWeighted(long max, System.Func<T, long> costFunc) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Log<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Log(string name, System.Func<T, object> extract, Akka.Event.ILoggingAdapter adapter) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class MaterializedValueSource<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<T>>, Akka.Streams.Implementation.Fusing.IMaterializedValueSource
    {
        public readonly Akka.Streams.Outlet<T> Outlet;
        public MaterializedValueSource(Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode computation, Akka.Streams.Outlet<T> outlet) { }
        public MaterializedValueSource(Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode computation) { }
        public Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode Computation { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.SourceShape<T> Shape { get; }
        public Akka.Streams.Implementation.Fusing.MaterializedValueSource<T> CopySource() { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public void SetValue(T value) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class OnCompleted<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, Akka.NotUsed>>
    {
        public OnCompleted(System.Action success, System.Action<System.Exception> failure) { }
        public Akka.Streams.Inlet<T> In { get; }
        public Akka.Streams.Outlet<Akka.NotUsed> Out { get; }
        public override Akka.Streams.FlowShape<T, Akka.NotUsed> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class RecoverWith<TOut, TMat> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<TOut>
    {
        public RecoverWith(System.Func<System.Exception, Akka.Streams.IGraph<Akka.Streams.SourceShape<TOut>, TMat>> partialFunction, int maximumRetries) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Recover<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Recover(System.Func<System.Exception, Akka.Util.Option<T>> recovery) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class ScanAsync<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public ScanAsync(TOut zero, System.Func<TOut, TIn, System.Threading.Tasks.Task<TOut>> aggregate) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Scan<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public Scan(TOut zero, System.Func<TOut, TIn, TOut> aggregate) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SelectAsyncUnordered<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public readonly Akka.Streams.Inlet<TIn> In;
        public readonly Akka.Streams.Outlet<TOut> Out;
        public SelectAsyncUnordered(int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> mapFunc) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SelectAsync<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public readonly Akka.Streams.Inlet<TIn> In;
        public readonly Akka.Streams.Outlet<TOut> Out;
        public SelectAsync(int parallelism, System.Func<TIn, System.Threading.Tasks.Task<TOut>> mapFunc) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SelectError<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public SelectError(System.Func<System.Exception, System.Exception> selector) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Select<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public Select(System.Func<TIn, TOut> func) { }
        public Akka.Streams.Inlet<TIn> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<TOut> Out { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class SimpleLinearGraphStage<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, T>>
    {
        public readonly Akka.Streams.Inlet<T> Inlet;
        public readonly Akka.Streams.Outlet<T> Outlet;
        protected SimpleLinearGraphStage(string name = null) { }
        public override Akka.Streams.FlowShape<T, T> Shape { get; }
    }
    public sealed class SingleSource<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<T>>
    {
        public readonly Akka.Streams.Outlet<T> Outlet;
        public SingleSource(T element) { }
        public override Akka.Streams.SourceShape<T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SkipWhile<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public SkipWhile(System.Predicate<T> predicate) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class SkipWithin<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public SkipWithin(System.TimeSpan timeout) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Skip<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Skip(long count) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Sliding<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>>>
    {
        public Sliding(int count, int step) { }
        public Akka.Streams.Inlet<T> In { get; }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<System.Collections.Generic.IEnumerable<T>> Out { get; }
        public override Akka.Streams.FlowShape<T, System.Collections.Generic.IEnumerable<T>> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class StatefulSelectMany<TIn, TOut> : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<TIn, TOut>>
    {
        public StatefulSelectMany(System.Func<System.Func<TIn, System.Collections.Generic.IEnumerable<TOut>>> concatFactory) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Sum<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Sum(System.Func<T, T, T> reduce) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class SupervisedGraphStageLogic : Akka.Streams.Stage.GraphStageLogic
    {
        protected SupervisedGraphStageLogic(Akka.Streams.Attributes inheritedAttributes, Akka.Streams.Shape shape) { }
        protected virtual void OnRestart(System.Exception ex) { }
        protected virtual void OnResume(System.Exception ex) { }
        protected virtual void OnStop(System.Exception ex) { }
        protected Akka.Util.Option<T> WithSupervision<T>(System.Func<T> function) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class TakeWhile<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public TakeWhile(System.Predicate<T> predicate, bool inclusive) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class TakeWithin<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public TakeWithin(System.TimeSpan timeout) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Take<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Take(long count) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public sealed class TaskSource<T> : Akka.Streams.Stage.GraphStage<Akka.Streams.SourceShape<T>>
    {
        public readonly Akka.Streams.Outlet<T> Outlet;
        public TaskSource(System.Threading.Tasks.Task<T> task) { }
        public override Akka.Streams.SourceShape<T> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public sealed class TickSource<T> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SourceShape<T>, Akka.Actor.ICancelable>
    {
        public TickSource(System.TimeSpan initialDelay, System.TimeSpan interval, T tick) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Outlet<T> Out { get; }
        public override Akka.Streams.SourceShape<T> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<Akka.Actor.ICancelable> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public sealed class Where<T> : Akka.Streams.Implementation.Fusing.SimpleLinearGraphStage<T>
    {
        public Where(System.Predicate<T> predicate) { }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
}
namespace Akka.Streams.Implementation.IO
{
    [Akka.Annotations.InternalApiAttribute()]
    public class IncomingConnectionStage : Akka.Streams.Stage.GraphStage<Akka.Streams.FlowShape<Akka.IO.ByteString, Akka.IO.ByteString>>
    {
        public IncomingConnectionStage(Akka.Actor.IActorRef connection, System.Net.EndPoint remoteAddress, bool halfClose) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<Akka.IO.ByteString, Akka.IO.ByteString> Shape { get; }
        protected override Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
}
namespace Akka.Streams.Implementation.Stages
{
    public class static DefaultAttributes
    {
        public static readonly Akka.Streams.Attributes ActorPublisherSource;
        public static readonly Akka.Streams.Attributes ActorRefSink;
        public static readonly Akka.Streams.Attributes ActorRefSource;
        public static readonly Akka.Streams.Attributes ActorRefWithAck;
        public static readonly Akka.Streams.Attributes ActorSubscriberSink;
        public static readonly Akka.Streams.Attributes Aggregate;
        public static readonly Akka.Streams.Attributes AggregateAsync;
        public static readonly Akka.Streams.Attributes BackpressureTimeout;
        public static readonly Akka.Streams.Attributes Balance;
        public static readonly Akka.Streams.Attributes Batch;
        public static readonly Akka.Streams.Attributes BatchWeighted;
        public static readonly Akka.Streams.Attributes Broadcast;
        public static readonly Akka.Streams.Attributes Buffer;
        public static readonly Akka.Streams.Attributes CancelledSink;
        public static readonly Akka.Streams.Attributes Collect;
        public static readonly Akka.Streams.Attributes Completion;
        public static readonly Akka.Streams.Attributes Concat;
        public static readonly Akka.Streams.Attributes ConcatAll;
        public static readonly Akka.Streams.Attributes ConcatMaterializedSource;
        public static readonly Akka.Streams.Attributes ConcatSource;
        public static readonly Akka.Streams.Attributes Conflate;
        public static readonly Akka.Streams.Attributes CycledSource;
        public static readonly Akka.Streams.Attributes Delay;
        public static readonly Akka.Streams.Attributes DelayInitial;
        public static readonly Akka.Streams.Attributes DelimiterFraming;
        public static readonly Akka.Streams.Attributes Drop;
        public static readonly Akka.Streams.Attributes EmptySource;
        public static readonly Akka.Streams.Attributes EnumerableSource;
        public static readonly Akka.Streams.Attributes Expand;
        public static readonly Akka.Streams.Attributes FailedSource;
        public static readonly Akka.Streams.Attributes FanoutPublisherSink;
        public static readonly Akka.Streams.Attributes FileSink;
        public static readonly Akka.Streams.Attributes FileSource;
        public static readonly Akka.Streams.Attributes FirstOrDefaultSink;
        public static readonly Akka.Streams.Attributes FirstSink;
        public static readonly Akka.Streams.Attributes FlattenMerge;
        public static readonly Akka.Streams.Attributes Fused;
        public static readonly Akka.Streams.Attributes GroupBy;
        public static readonly Akka.Streams.Attributes Grouped;
        public static readonly Akka.Streams.Attributes IODispatcher;
        public static readonly Akka.Streams.Attributes IdentityOp;
        public static readonly Akka.Streams.Attributes Idle;
        public static readonly Akka.Streams.Attributes IdleInject;
        public static readonly Akka.Streams.Attributes IdleTimeoutBidi;
        public static readonly Akka.Streams.Attributes IgnoreSink;
        public static readonly Akka.Streams.Attributes Initial;
        public static readonly Akka.Streams.Attributes InputStreamSink;
        public static readonly Akka.Streams.Attributes InputStreamSource;
        public static readonly Akka.Streams.Attributes LastOrDefaultSink;
        public static readonly Akka.Streams.Attributes LastSink;
        public static readonly Akka.Streams.Attributes LazySink;
        public static readonly Akka.Streams.Attributes LazySource;
        public static readonly Akka.Streams.Attributes Limit;
        public static readonly Akka.Streams.Attributes LimitWeighted;
        public static readonly Akka.Streams.Attributes Log;
        public static readonly Akka.Streams.Attributes MapAsync;
        public static readonly Akka.Streams.Attributes MapAsyncUnordered;
        public static readonly Akka.Streams.Attributes MaybeSource;
        public static readonly Akka.Streams.Attributes Merge;
        public static readonly Akka.Streams.Attributes MergePreferred;
        public static readonly Akka.Streams.Attributes OrElse;
        public static readonly Akka.Streams.Attributes OutputStreamSink;
        public static readonly Akka.Streams.Attributes OutputStreamSource;
        public static readonly Akka.Streams.Attributes PrefixAndTail;
        public static readonly Akka.Streams.Attributes Processor;
        public static readonly Akka.Streams.Attributes ProcessorWithKey;
        public static readonly Akka.Streams.Attributes PublisherSink;
        public static readonly Akka.Streams.Attributes PublisherSource;
        public static readonly Akka.Streams.Attributes QueueSink;
        public static readonly Akka.Streams.Attributes QueueSource;
        public static readonly Akka.Streams.Attributes Recover;
        public static readonly Akka.Streams.Attributes RecoverWith;
        public static readonly Akka.Streams.Attributes Repeat;
        public static readonly Akka.Streams.Attributes Scan;
        public static readonly Akka.Streams.Attributes ScanAsync;
        public static readonly Akka.Streams.Attributes Select;
        public static readonly Akka.Streams.Attributes SeqSink;
        public static readonly Akka.Streams.Attributes SingleSource;
        public static readonly Akka.Streams.Attributes Skip;
        public static readonly Akka.Streams.Attributes SkipWhile;
        public static readonly Akka.Streams.Attributes Sliding;
        public static readonly Akka.Streams.Attributes Split;
        public static readonly Akka.Streams.Attributes StatefulSelectMany;
        public static readonly Akka.Streams.Attributes SubscriberSink;
        public static readonly Akka.Streams.Attributes SubscriberSource;
        public static readonly Akka.Streams.Attributes Sum;
        public static readonly Akka.Streams.Attributes Take;
        public static readonly Akka.Streams.Attributes TakeWhile;
        public static readonly Akka.Streams.Attributes TaskSource;
        public static readonly Akka.Streams.Attributes TerminationWatcher;
        public static readonly Akka.Streams.Attributes TickSource;
        public static readonly Akka.Streams.Attributes Unfold;
        public static readonly Akka.Streams.Attributes UnfoldAsync;
        public static readonly Akka.Streams.Attributes UnfoldInf;
        public static readonly Akka.Streams.Attributes UnfoldResourceSource;
        public static readonly Akka.Streams.Attributes UnfoldResourceSourceAsync;
        public static readonly Akka.Streams.Attributes Unzip;
        public static readonly Akka.Streams.Attributes Watch;
        public static readonly Akka.Streams.Attributes Where;
        public static readonly Akka.Streams.Attributes Zip;
        public static readonly Akka.Streams.Attributes ZipN;
        public static readonly Akka.Streams.Attributes ZipWithIndex;
        public static readonly Akka.Streams.Attributes ZipWithN;
    }
    public sealed class FirstOrDefault<TIn> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<TIn>, System.Threading.Tasks.Task<TIn>>
    {
        public FirstOrDefault(bool throwOnDefault = False) { }
        public override Akka.Streams.SinkShape<TIn> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<TIn>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public interface ISymbolicStage<in TIn, out TOut> : Akka.Streams.Stage.IStage<TIn, TOut>
    {
        Akka.Streams.Attributes Attributes { get; }
        Akka.Streams.Stage.IStage<TIn, TOut> Create(Akka.Streams.Attributes effectiveAttributes);
    }
    public sealed class LastOrDefault<TIn> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.SinkShape<TIn>, System.Threading.Tasks.Task<TIn>>
    {
        public LastOrDefault(bool throwOnDefault = False) { }
        public override Akka.Streams.SinkShape<TIn> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<System.Threading.Tasks.Task<TIn>> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public override string ToString() { }
    }
    public sealed class SymbolicGraphStage<TIn, TOut> : Akka.Streams.Stage.PushPullGraphStage<TIn, TOut>
    {
        public SymbolicGraphStage(Akka.Streams.Implementation.Stages.ISymbolicStage<TIn, TOut> symbolicStage) { }
    }
    public abstract class SymbolicStage<TIn, TOut> : Akka.Streams.Implementation.Stages.ISymbolicStage<TIn, TOut>, Akka.Streams.Stage.IStage<TIn, TOut>
    {
        protected SymbolicStage(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.Attributes Attributes { get; }
        public abstract Akka.Streams.Stage.IStage<TIn, TOut> Create(Akka.Streams.Attributes effectiveAttributes);
        protected Akka.Streams.Supervision.Decider Supervision(Akka.Streams.Attributes attributes) { }
    }
}
namespace Akka.Streams.Serialization
{
    public sealed class StreamRefSerializer : Akka.Serialization.SerializerWithStringManifest
    {
        public StreamRefSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override object FromBinary(byte[] bytes, string manifest) { }
        public override string Manifest(object o) { }
        public override byte[] ToBinary(object o) { }
    }
}
namespace Akka.Streams.Stage
{
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.2]")]
    public abstract class AbstractStage<TIn, TOut> : Akka.Streams.Stage.IStage<TIn, TOut>
    {
        protected AbstractStage() { }
        protected virtual bool IsDetached { get; }
        public virtual Akka.Streams.Supervision.Directive Decide(System.Exception cause) { }
        public abstract Akka.Streams.Stage.ITerminationDirective OnDownstreamFinish(Akka.Streams.Stage.IContext context);
        public abstract Akka.Streams.Stage.IDirective OnPull(Akka.Streams.Stage.IContext context);
        public abstract Akka.Streams.Stage.IDirective OnPush(TIn element, Akka.Streams.Stage.IContext context);
        public abstract Akka.Streams.Stage.ITerminationDirective OnUpstreamFailure(System.Exception cause, Akka.Streams.Stage.IContext context);
        public abstract Akka.Streams.Stage.ITerminationDirective OnUpstreamFinish(Akka.Streams.Stage.IContext context);
        public virtual void PostStop() { }
        public virtual void PreStart(Akka.Streams.Stage.ILifecycleContext context) { }
        public virtual Akka.Streams.Stage.IStage<TIn, TOut> Restart() { }
    }
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.2]")]
    public abstract class AbstractStage<TIn, TOut, TPushDirective, TPullDirective, TContext> : Akka.Streams.Stage.AbstractStage<TIn, TOut>
        where TPushDirective : Akka.Streams.Stage.IDirective
        where TPullDirective : Akka.Streams.Stage.IDirective
        where TContext : Akka.Streams.Stage.IContext
    {
        protected TContext Context;
        protected AbstractStage() { }
        public virtual Akka.Streams.Stage.ITerminationDirective OnDownstreamFinish(Akka.Streams.Stage.IContext context) { }
        public virtual Akka.Streams.Stage.ITerminationDirective OnDownstreamFinish(TContext context) { }
        public abstract TPullDirective OnPull(TContext context);
        public override Akka.Streams.Stage.IDirective OnPull(Akka.Streams.Stage.IContext context) { }
        public abstract TPushDirective OnPush(TIn element, TContext context);
        public virtual Akka.Streams.Stage.IDirective OnPush(TIn element, Akka.Streams.Stage.IContext context) { }
        public virtual Akka.Streams.Stage.ITerminationDirective OnUpstreamFailure(System.Exception cause, Akka.Streams.Stage.IContext context) { }
        public virtual Akka.Streams.Stage.ITerminationDirective OnUpstreamFailure(System.Exception cause, TContext context) { }
        public virtual Akka.Streams.Stage.ITerminationDirective OnUpstreamFinish(Akka.Streams.Stage.IContext context) { }
        public virtual Akka.Streams.Stage.ITerminationDirective OnUpstreamFinish(TContext context) { }
    }
    public delegate void AsyncCallback(object element);
    public delegate void AsyncCallback<in T>(T element);
    public class ConditionalTerminateInput : Akka.Streams.Stage.InHandler
    {
        public ConditionalTerminateInput(System.Func<bool> predicate) { }
        public override void OnPush() { }
        public override void OnUpstreamFinish() { }
    }
    public class ConditionalTerminateOutput : Akka.Streams.Stage.OutHandler
    {
        public ConditionalTerminateOutput(System.Func<bool> predicate) { }
        public override void OnDownstreamFinish() { }
        public override void OnPull() { }
    }
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.0]")]
    public abstract class DetachedStage<TIn, TOut> : Akka.Streams.Stage.AbstractStage<TIn, TOut, Akka.Streams.Stage.IUpstreamDirective, Akka.Streams.Stage.IDownstreamDirective, Akka.Streams.Stage.IDetachedContext<TOut>>
    {
        protected DetachedStage() { }
        protected override bool IsDetached { get; }
    }
    public sealed class EagerTerminateInput : Akka.Streams.Stage.InHandler
    {
        public static readonly Akka.Streams.Stage.EagerTerminateInput Instance;
        public override void OnPush() { }
    }
    public sealed class EagerTerminateOutput : Akka.Streams.Stage.OutHandler
    {
        public static readonly Akka.Streams.Stage.EagerTerminateOutput Instance;
        public override void OnPull() { }
    }
    public sealed class FreeDirective : Akka.Streams.Stage.IAsyncDirective, Akka.Streams.Stage.IDirective, Akka.Streams.Stage.IDownstreamDirective, Akka.Streams.Stage.ISyncDirective, Akka.Streams.Stage.ITerminationDirective, Akka.Streams.Stage.IUpstreamDirective
    {
        public FreeDirective() { }
    }
    public abstract class GraphStageLogic : Akka.Streams.Stage.IStageLogging
    {
        public static System.Action DoNothing;
        public static readonly Akka.Streams.Stage.InHandler EagerTerminateInput;
        public static readonly Akka.Streams.Stage.OutHandler EagerTerminateOutput;
        public static readonly Akka.Streams.Stage.InHandler IgnoreTerminateInput;
        public static readonly Akka.Streams.Stage.OutHandler IgnoreTerminateOutput;
        public readonly int InCount;
        public readonly int OutCount;
        public static readonly Akka.Streams.Stage.InHandler TotallyIgnorantInput;
        protected GraphStageLogic(int inCount, int outCount) { }
        protected GraphStageLogic(Akka.Streams.Shape shape) { }
        public virtual bool KeepGoingAfterAllPortsClosed { get; }
        public Akka.Event.ILoggingAdapter Log { get; }
        protected object LogSource { get; }
        protected Akka.Streams.IMaterializer Materializer { get; }
        public Akka.Streams.Stage.StageActor StageActor { get; }
        [Akka.Annotations.ApiMayChangeAttribute()]
        protected virtual string StageActorName { get; }
        protected Akka.Streams.IMaterializer SubFusingMaterializer { get; }
        protected void AbortEmitting<T>(Akka.Streams.Outlet<T> outlet) { }
        protected void AbortReading<T>(Akka.Streams.Inlet<T> inlet) { }
        protected virtual void AfterPostStop() { }
        protected virtual void BeforePreStart() { }
        protected void Cancel<T>(Akka.Streams.Inlet<T> inlet) { }
        protected void Complete<T>(Akka.Streams.Outlet<T> outlet) { }
        public void CompleteStage() { }
        public static Akka.Streams.Stage.InHandler ConditionalTerminateInput(System.Func<bool> predicate) { }
        public static Akka.Streams.Stage.OutHandler ConditionalTerminateOutput(System.Func<bool> predicate) { }
        protected Akka.Streams.Stage.GraphStageLogic.SubSinkInlet<T> CreateSubSinkInlet<T>(string name) { }
        protected void Emit<T>(Akka.Streams.Outlet<T> outlet, T element, System.Action andThen) { }
        protected void Emit<T>(Akka.Streams.Outlet<T> outlet, T element) { }
        protected void EmitMultiple<T>(Akka.Streams.Outlet<T> outlet, System.Collections.Generic.IEnumerable<T> elements, System.Action andThen) { }
        protected void EmitMultiple<T>(Akka.Streams.Outlet<T> outlet, System.Collections.Generic.IEnumerable<T> elements) { }
        protected void EmitMultiple<T>(Akka.Streams.Outlet<T> outlet, System.Collections.Generic.IEnumerator<T> enumerator, System.Action andThen) { }
        protected void EmitMultiple<T>(Akka.Streams.Outlet<T> outlet, System.Collections.Generic.IEnumerator<T> enumerator) { }
        protected void Fail<T>(Akka.Streams.Outlet<T> outlet, System.Exception reason) { }
        public void FailStage(System.Exception reason) { }
        protected System.Action<T> GetAsyncCallback<T>(System.Action<T> handler) { }
        protected System.Action GetAsyncCallback(System.Action handler) { }
        protected Akka.Streams.Stage.IInHandler GetHandler<T>(Akka.Streams.Inlet<T> inlet) { }
        protected Akka.Streams.Stage.IOutHandler GetHandler<T>(Akka.Streams.Outlet<T> outlet) { }
        [Akka.Annotations.ApiMayChangeAttribute()]
        protected Akka.Streams.Stage.StageActor GetStageActor(Akka.Streams.Stage.StageActorRef.Receive receive) { }
        protected T Grab<T>(Akka.Streams.Inlet<T> inlet) { }
        protected bool HasBeenPulled<T>(Akka.Streams.Inlet<T> inlet) { }
        protected bool IsAvailable<T>(Akka.Streams.Inlet<T> inlet) { }
        protected bool IsAvailable<T>(Akka.Streams.Outlet<T> outlet) { }
        protected bool IsClosed<T>(Akka.Streams.Inlet<T> inlet) { }
        protected bool IsClosed<T>(Akka.Streams.Outlet<T> outlet) { }
        protected void PassAlong<TOut, TIn>(Akka.Streams.Inlet<TIn> from, Akka.Streams.Outlet<TOut> to, bool doFinish = True, bool doFail = True, bool doPull = False)
            where TIn : TOut { }
        public virtual void PostStop() { }
        public virtual void PreStart() { }
        protected void Pull<T>(Akka.Streams.Inlet<T> inlet) { }
        protected void Push<T>(Akka.Streams.Outlet<T> outlet, T element) { }
        protected void Read<T>(Akka.Streams.Inlet<T> inlet, System.Action<T> andThen, System.Action onClose) { }
        protected void ReadMany<T>(Akka.Streams.Inlet<T> inlet, int n, System.Action<System.Collections.Generic.IEnumerable<T>> andThen, System.Action<System.Collections.Generic.IEnumerable<T>> onComplete) { }
        protected void SetHandler<T>(Akka.Streams.Inlet<T> inlet, Akka.Streams.Stage.IInHandler handler) { }
        protected void SetHandler<T>(Akka.Streams.Inlet<T> inlet, System.Action onPush, System.Action onUpstreamFinish = null, System.Action<System.Exception> onUpstreamFailure = null) { }
        protected void SetHandler<T>(Akka.Streams.Outlet<T> outlet, Akka.Streams.Stage.IOutHandler handler) { }
        protected void SetHandler<T>(Akka.Streams.Outlet<T> outlet, System.Action onPull, System.Action onDownstreamFinish = null) { }
        protected void SetHandler<TIn, TOut>(Akka.Streams.Inlet<TIn> inlet, Akka.Streams.Outlet<TOut> outlet, Akka.Streams.Stage.InAndOutGraphStageLogic handler) { }
        protected void SetKeepGoing(bool enabled) { }
        protected void TryPull<T>(Akka.Streams.Inlet<T> inlet) { }
        protected sealed class LambdaInHandler : Akka.Streams.Stage.InHandler
        {
            public LambdaInHandler(System.Action onPush, System.Action onUpstreamFinish = null, System.Action<System.Exception> onUpstreamFailure = null) { }
            public override void OnPush() { }
            public override void OnUpstreamFailure(System.Exception e) { }
            public override void OnUpstreamFinish() { }
        }
        protected sealed class LambdaOutHandler : Akka.Streams.Stage.OutHandler
        {
            public LambdaOutHandler(System.Action onPull, System.Action onDownstreamFinish = null) { }
            public override void OnDownstreamFinish() { }
            public override void OnPull() { }
        }
        [Akka.Annotations.InternalApiAttribute()]
        protected class SubSinkInlet<T>
        {
            public SubSinkInlet(Akka.Streams.Stage.GraphStageLogic logic, string name) { }
            public bool HasBeenPulled { get; }
            public bool IsAvailable { get; }
            public bool IsClosed { get; }
            public Akka.Streams.IGraph<Akka.Streams.SinkShape<T>, Akka.NotUsed> Sink { get; }
            public void Cancel() { }
            public T Grab() { }
            public void Pull() { }
            public void SetHandler(Akka.Streams.Stage.InHandler handler) { }
            public override string ToString() { }
        }
        [Akka.Annotations.InternalApiAttribute()]
        protected class SubSourceOutlet<T>
        {
            public SubSourceOutlet(Akka.Streams.Stage.GraphStageLogic logic, string name) { }
            public bool IsAvailable { get; }
            public bool IsClosed { get; }
            public Akka.Streams.IGraph<Akka.Streams.SourceShape<T>, Akka.NotUsed> Source { get; }
            public void Complete() { }
            public void Fail(System.Exception ex) { }
            public void Push(T elem) { }
            public void SetHandler(Akka.Streams.Stage.IOutHandler handler) { }
            public void Timeout(System.TimeSpan d) { }
            public override string ToString() { }
        }
    }
    public abstract class GraphStageWithMaterializedValue<TShape, TMaterialized> : Akka.Streams.IGraph<TShape>, Akka.Streams.IGraph<TShape, TMaterialized>, Akka.Streams.Stage.IGraphStageWithMaterializedValue<TShape, TMaterialized>
        where TShape : Akka.Streams.Shape
    {
        protected GraphStageWithMaterializedValue() { }
        protected virtual Akka.Streams.Attributes InitialAttributes { get; }
        public Akka.Streams.Implementation.IModule Module { get; }
        public abstract TShape Shape { get; }
        public Akka.Streams.IGraph<TShape, TMaterialized> AddAttributes(Akka.Streams.Attributes attributes) { }
        public Akka.Streams.IGraph<TShape, TMaterialized> Async() { }
        public abstract Akka.Streams.Stage.ILogicAndMaterializedValue<TMaterialized> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes);
        public Akka.Streams.IGraph<TShape, TMaterialized> Named(string name) { }
        public Akka.Streams.IGraph<TShape, TMaterialized> WithAttributes(Akka.Streams.Attributes attributes) { }
    }
    public abstract class GraphStage<TShape> : Akka.Streams.Stage.GraphStageWithMaterializedValue<TShape, Akka.NotUsed>
        where TShape : Akka.Streams.Shape
    {
        protected GraphStage() { }
        protected abstract Akka.Streams.Stage.GraphStageLogic CreateLogic(Akka.Streams.Attributes inheritedAttributes);
        public virtual Akka.Streams.Stage.ILogicAndMaterializedValue<Akka.NotUsed> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
    }
    public interface IAsyncContext : Akka.Streams.Stage.IContext, Akka.Streams.Stage.IDetachedContext, Akka.Streams.Stage.ILifecycleContext
    {
        Akka.Streams.Stage.AsyncCallback GetAsyncCallback();
        Akka.Streams.Stage.IAsyncDirective Ignore();
    }
    public interface IAsyncContext<in TOut, in TExt> : Akka.Streams.Stage.IAsyncContext, Akka.Streams.Stage.IContext, Akka.Streams.Stage.IContext<TOut>, Akka.Streams.Stage.IDetachedContext, Akka.Streams.Stage.IDetachedContext<TOut>, Akka.Streams.Stage.ILifecycleContext
    {
        Akka.Streams.Stage.AsyncCallback<TExt> GetAsyncCallback();
    }
    public interface IAsyncDirective : Akka.Streams.Stage.IDirective { }
    public interface IBoundaryContext : Akka.Streams.Stage.IContext, Akka.Streams.Stage.ILifecycleContext
    {
        Akka.Streams.Stage.FreeDirective Exit();
    }
    public interface IContext : Akka.Streams.Stage.ILifecycleContext
    {
        bool IsFinishing { get; }
        Akka.Streams.Stage.ITerminationDirective AbsorbTermination();
        Akka.Streams.Stage.FreeDirective Fail(System.Exception cause);
        Akka.Streams.Stage.FreeDirective Finish();
        Akka.Streams.Stage.IUpstreamDirective Pull();
        Akka.Streams.Stage.IDownstreamDirective Push(object element);
        Akka.Streams.Stage.IDownstreamDirective PushAndFinish(object element);
    }
    public interface IContext<in TOut> : Akka.Streams.Stage.IContext, Akka.Streams.Stage.ILifecycleContext
    {
        Akka.Streams.Stage.IDownstreamDirective Push(TOut element);
        Akka.Streams.Stage.IDownstreamDirective PushAndFinish(TOut element);
    }
    public interface IDetachedContext : Akka.Streams.Stage.IContext, Akka.Streams.Stage.ILifecycleContext
    {
        bool IsHoldingBoth { get; }
        bool IsHoldingDownstream { get; }
        bool IsHoldingUpstream { get; }
        Akka.Streams.Stage.IDownstreamDirective HoldDownstream();
        Akka.Streams.Stage.IDownstreamDirective HoldDownstreamAndPull();
        Akka.Streams.Stage.IUpstreamDirective HoldUpstream();
        Akka.Streams.Stage.IUpstreamDirective HoldUpstreamAndPush(object element);
        Akka.Streams.Stage.FreeDirective PushAndPull(object element);
    }
    public interface IDetachedContext<in TOut> : Akka.Streams.Stage.IContext, Akka.Streams.Stage.IContext<TOut>, Akka.Streams.Stage.IDetachedContext, Akka.Streams.Stage.ILifecycleContext
    {
        Akka.Streams.Stage.IUpstreamDirective HoldUpstreamAndPush(TOut element);
        Akka.Streams.Stage.FreeDirective PushAndPull(TOut element);
    }
    public interface IDirective { }
    public interface IDownstreamDirective : Akka.Streams.Stage.IDirective, Akka.Streams.Stage.ISyncDirective { }
    public interface IGraphStageWithMaterializedValue<out TShape, out TMaterialized> : Akka.Streams.IGraph<TShape>, Akka.Streams.IGraph<TShape, TMaterialized>
        where out TShape : Akka.Streams.Shape
    {
        Akka.Streams.Stage.ILogicAndMaterializedValue<TMaterialized> CreateLogicAndMaterializedValue(Akka.Streams.Attributes attributes);
    }
    public interface IInHandler
    {
        void OnPush();
        void OnUpstreamFailure(System.Exception e);
        void OnUpstreamFinish();
    }
    public interface ILifecycleContext
    {
        Akka.Streams.Attributes Attributes { get; }
        Akka.Streams.IMaterializer Materializer { get; }
    }
    public interface ILogicAndMaterializedValue<out TMaterialized>
    {
        Akka.Streams.Stage.GraphStageLogic Logic { get; }
        TMaterialized MaterializedValue { get; }
    }
    public interface IOutHandler
    {
        void OnDownstreamFinish();
        void OnPull();
    }
    public interface IStageLogging
    {
        Akka.Event.ILoggingAdapter Log { get; }
    }
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.0]")]
    public interface IStage<in TIn, out TOut> { }
    public interface ISyncDirective : Akka.Streams.Stage.IDirective { }
    public interface ITerminationDirective : Akka.Streams.Stage.IDirective, Akka.Streams.Stage.ISyncDirective { }
    public interface IUpstreamDirective : Akka.Streams.Stage.IDirective, Akka.Streams.Stage.ISyncDirective { }
    public sealed class IgnoreTerminateInput : Akka.Streams.Stage.InHandler
    {
        public static readonly Akka.Streams.Stage.IgnoreTerminateInput Instance;
        public override void OnPush() { }
        public override void OnUpstreamFinish() { }
    }
    public sealed class IgnoreTerminateOutput : Akka.Streams.Stage.OutHandler
    {
        public static readonly Akka.Streams.Stage.IgnoreTerminateOutput Instance;
        public override void OnDownstreamFinish() { }
        public override void OnPull() { }
    }
    public abstract class InAndOutGraphStageLogic : Akka.Streams.Stage.GraphStageLogic, Akka.Streams.Stage.IInHandler, Akka.Streams.Stage.IOutHandler
    {
        protected InAndOutGraphStageLogic(int inCount, int outCount) { }
        protected InAndOutGraphStageLogic(Akka.Streams.Shape shape) { }
        public virtual void OnDownstreamFinish() { }
        public abstract void OnPull();
        public abstract void OnPush();
        public virtual void OnUpstreamFailure(System.Exception e) { }
        public virtual void OnUpstreamFinish() { }
    }
    public abstract class InAndOutHandler : Akka.Streams.Stage.IInHandler, Akka.Streams.Stage.IOutHandler
    {
        protected InAndOutHandler() { }
        public virtual void OnDownstreamFinish() { }
        public abstract void OnPull();
        public abstract void OnPush();
        public virtual void OnUpstreamFailure(System.Exception e) { }
        public virtual void OnUpstreamFinish() { }
    }
    public abstract class InGraphStageLogic : Akka.Streams.Stage.GraphStageLogic, Akka.Streams.Stage.IInHandler
    {
        protected InGraphStageLogic(int inCount, int outCount) { }
        protected InGraphStageLogic(Akka.Streams.Shape shape) { }
        public abstract void OnPush();
        public virtual void OnUpstreamFailure(System.Exception e) { }
        public virtual void OnUpstreamFinish() { }
    }
    public abstract class InHandler : Akka.Streams.Stage.IInHandler
    {
        protected InHandler() { }
        public abstract void OnPush();
        public virtual void OnUpstreamFailure(System.Exception e) { }
        public virtual void OnUpstreamFinish() { }
    }
    public struct LogicAndMaterializedValue<TMaterialized> : Akka.Streams.Stage.ILogicAndMaterializedValue<TMaterialized>
    {
        public LogicAndMaterializedValue(Akka.Streams.Stage.GraphStageLogic logic, TMaterialized materializedValue) { }
        public Akka.Streams.Stage.GraphStageLogic Logic { get; }
        public TMaterialized MaterializedValue { get; }
    }
    public abstract class OutGraphStageLogic : Akka.Streams.Stage.GraphStageLogic, Akka.Streams.Stage.IOutHandler
    {
        protected OutGraphStageLogic(int inCount, int outCount) { }
        protected OutGraphStageLogic(Akka.Streams.Shape shape) { }
        public virtual void OnDownstreamFinish() { }
        public abstract void OnPull();
    }
    public abstract class OutHandler : Akka.Streams.Stage.IOutHandler
    {
        protected OutHandler() { }
        public virtual void OnDownstreamFinish() { }
        public abstract void OnPull();
    }
    public class PushPullGraphStageWithMaterializedValue<TIn, TOut, TMat> : Akka.Streams.Stage.GraphStageWithMaterializedValue<Akka.Streams.FlowShape<TIn, TOut>, TMat>
    {
        public readonly System.Func<Akka.Streams.Attributes, System.ValueTuple<Akka.Streams.Stage.IStage<TIn, TOut>, TMat>> Factory;
        public PushPullGraphStageWithMaterializedValue(System.Func<Akka.Streams.Attributes, System.ValueTuple<Akka.Streams.Stage.IStage<TIn, TOut>, TMat>> factory, Akka.Streams.Attributes stageAttributes) { }
        protected override Akka.Streams.Attributes InitialAttributes { get; }
        public override Akka.Streams.FlowShape<TIn, TOut> Shape { get; }
        public override Akka.Streams.Stage.ILogicAndMaterializedValue<TMat> CreateLogicAndMaterializedValue(Akka.Streams.Attributes inheritedAttributes) { }
        public virtual string ToString() { }
    }
    public class PushPullGraphStage<TIn, TOut> : Akka.Streams.Stage.PushPullGraphStageWithMaterializedValue<TIn, TOut, Akka.NotUsed>
    {
        public PushPullGraphStage(System.Func<Akka.Streams.Attributes, Akka.Streams.Stage.IStage<TIn, TOut>> factory, Akka.Streams.Attributes stageAttributes) { }
    }
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.0]")]
    public abstract class PushPullStage<TIn, TOut> : Akka.Streams.Stage.AbstractStage<TIn, TOut, Akka.Streams.Stage.ISyncDirective, Akka.Streams.Stage.ISyncDirective, Akka.Streams.Stage.IContext<TOut>>
    {
        protected PushPullStage() { }
    }
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.0]")]
    public abstract class PushStage<TIn, TOut> : Akka.Streams.Stage.PushPullStage<TIn, TOut>
    {
        protected PushStage() { }
        public virtual Akka.Streams.Stage.ISyncDirective OnPull(Akka.Streams.Stage.IContext<TOut> context) { }
    }
    public sealed class StageActor
    {
        public StageActor(Akka.Streams.ActorMaterializer materializer, System.Func<Akka.Streams.Stage.StageActorRef.Receive, System.Action<System.ValueTuple<Akka.Actor.IActorRef, object>>> getAsyncCallback, Akka.Streams.Stage.StageActorRef.Receive initialReceive, string name = null) { }
        public Akka.Actor.IActorRef Ref { get; }
        public void Become(Akka.Streams.Stage.StageActorRef.Receive receive) { }
        public void Stop() { }
        public void Unwatch(Akka.Actor.IActorRef actorRef) { }
        public void Watch(Akka.Actor.IActorRef actorRef) { }
    }
    public class static StageActorRef
    {
        public delegate void Receive(System.ValueTuple<Akka.Actor.IActorRef, object> args);
    }
    public class StageActorRefNotInitializedException : System.Exception
    {
        public static readonly Akka.Streams.Stage.StageActorRefNotInitializedException Instance;
    }
    public abstract class StageState<TIn, TOut>
    {
        protected StageState() { }
        public virtual Akka.Streams.Stage.ISyncDirective OnPull(Akka.Streams.Stage.IContext<TOut> context) { }
        public abstract Akka.Streams.Stage.ISyncDirective OnPush(TIn element, Akka.Streams.Stage.IContext<TOut> context);
    }
    public class static StatefulStage { }
    [System.ObsoleteAttribute("Please use GraphStage instead. [1.1.0]")]
    public abstract class StatefulStage<TIn, TOut> : Akka.Streams.Stage.PushPullStage<TIn, TOut>
    {
        protected StatefulStage(Akka.Streams.Stage.StageState<TIn, TOut> current) { }
        public Akka.Streams.Stage.StageState<TIn, TOut> Current { get; }
        public abstract Akka.Streams.Stage.StageState<TIn, TOut> Initial { get; }
        public void Become(Akka.Streams.Stage.StageState<TIn, TOut> state) { }
        public Akka.Streams.Stage.ISyncDirective Emit(System.Collections.Generic.IEnumerator<TOut> enumerator, Akka.Streams.Stage.IContext<TOut> context) { }
        public Akka.Streams.Stage.ISyncDirective Emit(System.Collections.Generic.IEnumerator<TOut> enumerator, Akka.Streams.Stage.IContext<TOut> context, Akka.Streams.Stage.StageState<TIn, TOut> nextState) { }
        public Akka.Streams.Stage.ISyncDirective EmitAndFinish(System.Collections.Generic.IEnumerator<TOut> enumerator, Akka.Streams.Stage.IContext<TOut> context) { }
        public virtual Akka.Streams.Stage.ISyncDirective OnPull(Akka.Streams.Stage.IContext<TOut> context) { }
        public virtual Akka.Streams.Stage.ISyncDirective OnPush(TIn element, Akka.Streams.Stage.IContext<TOut> context) { }
        public override Akka.Streams.Stage.ITerminationDirective OnUpstreamFinish(Akka.Streams.Stage.IContext<TOut> context) { }
        public Akka.Streams.Stage.ISyncDirective TerminationEmit(System.Collections.Generic.IEnumerator<TOut> enumerator, Akka.Streams.Stage.IContext<TOut> context) { }
    }
    public abstract class TimerGraphStageLogic : Akka.Streams.Stage.GraphStageLogic
    {
        protected TimerGraphStageLogic(Akka.Streams.Shape shape) { }
        protected override void AfterPostStop() { }
        protected void CancelTimer(object timerKey) { }
        protected bool IsTimerActive(object timerKey) { }
        protected abstract void OnTimer(object timerKey);
        protected void ScheduleOnce(object timerKey, System.TimeSpan delay) { }
        protected void ScheduleRepeatedly(object timerKey, System.TimeSpan initialDelay, System.TimeSpan interval) { }
        protected void ScheduleRepeatedly(object timerKey, System.TimeSpan interval) { }
    }
    public sealed class TotallyIgnorantInput : Akka.Streams.Stage.InHandler
    {
        public static readonly Akka.Streams.Stage.TotallyIgnorantInput Instance;
        public override void OnPush() { }
        public override void OnUpstreamFailure(System.Exception e) { }
        public override void OnUpstreamFinish() { }
    }
}
namespace Akka.Streams.Supervision
{
    public delegate Akka.Streams.Supervision.Directive Decider(System.Exception cause);
    public class static Deciders
    {
        public static readonly Akka.Streams.Supervision.Decider RestartingDecider;
        public static readonly Akka.Streams.Supervision.Decider ResumingDecider;
        public static readonly Akka.Streams.Supervision.Decider StoppingDecider;
    }
    public enum Directive
    {
        Stop = 0,
        Resume = 1,
        Restart = 2,
    }
}
namespace Akka.Streams.Util
{
    public class ContinuallyEnumerable<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        public ContinuallyEnumerable(System.Func<System.Collections.Generic.IEnumerator<T>> enumeratorFactory) { }
        public System.Collections.Generic.IEnumerator<T> GetEnumerator() { }
        public sealed class ContinuallyEnumerator<T> : System.Collections.Generic.IEnumerator<T>, System.Collections.IEnumerator, System.IDisposable
        {
            public ContinuallyEnumerator(System.Func<System.Collections.Generic.IEnumerator<T>> enumeratorFactory) { }
            public T Current { get; }
            public void Dispose() { }
            public bool MoveNext() { }
            public void Reset() { }
        }
    }
    public class EnumeratorEnumerable<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        public EnumeratorEnumerable(System.Func<System.Collections.Generic.IEnumerator<T>> enumeratorFactory) { }
        public System.Collections.Generic.IEnumerator<T> GetEnumerator() { }
    }
    public class static Int32Extensions { }
    public class static ObjectExtensions
    {
        public static bool IsDefaultForType<T>(this T obj) { }
    }
    public class static TypeExtensions
    {
        public static System.Type GetPublishedType(this System.Type type) { }
        public static System.Type GetSubscribedType(this System.Type type) { }
    }
}