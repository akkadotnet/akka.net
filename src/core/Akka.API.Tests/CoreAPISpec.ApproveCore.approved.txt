[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tests.MultiNode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tools")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.MultiNodeTestRunner.Shared.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests.MultiNode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.TestKit.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Tests.Performance")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.InteropServices.GuidAttribute("1a5cab08-b032-49ca-8db3-9428c5a9db14")]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.5", FrameworkDisplayName=".NET Framework 4.5")]
namespace Akka.Actor
{
    public abstract class ActorBase : Akka.Actor.IInternalActor
    {
        protected ActorBase() { }
        protected static Akka.Actor.IActorContext Context { get; }
        protected static Akka.Actor.Receive EmptyReceive { get; }
        protected Akka.Actor.IActorRef Self { get; }
        protected Akka.Actor.IActorRef Sender { get; }
        public virtual void AroundPostRestart(System.Exception cause, object message) { }
        public virtual void AroundPostStop() { }
        public virtual void AroundPreRestart(System.Exception cause, object message) { }
        public virtual void AroundPreStart() { }
        protected internal bool AroundReceive(Akka.Actor.Receive receive, object message) { }
        [System.ObsoleteAttribute("Use Become or BecomeStacked instead. This method will be removed in future versio" +
            "ns")]
        protected void Become(Akka.Actor.Receive receive, bool discardOld = True) { }
        protected void Become(Akka.Actor.Receive receive) { }
        protected void BecomeStacked(Akka.Actor.Receive receive) { }
        protected virtual void PostRestart(System.Exception reason) { }
        protected virtual void PostStop() { }
        protected virtual void PreRestart(System.Exception reason, object message) { }
        protected virtual void PreStart() { }
        protected abstract bool Receive(object message);
        protected void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout) { }
        protected virtual Akka.Actor.SupervisorStrategy SupervisorStrategy() { }
        [System.ObsoleteAttribute("Use UnbecomeStacked instead. This method will be removed in future versions")]
        protected void Unbecome() { }
        protected void UnbecomeStacked() { }
        protected virtual void Unhandled(object message) { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{Self,nq}")]
    public class ActorCell : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch, Akka.Actor.ICell, Akka.Actor.IUntypedActorContext
    {
        public const int UndefinedUid = 0;
        public ActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef parent) { }
        protected Akka.Actor.ActorBase Actor { get; }
        public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }
        public int CurrentEnvelopeId { get; }
        public object CurrentMessage { get; }
        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        public bool HasMessages { get; }
        public bool IsLocal { get; }
        protected bool IsNormal { get; }
        public bool IsTerminated { get; }
        protected bool IsTerminating { get; }
        public Akka.Dispatch.Mailbox Mailbox { get; }
        public int NumberOfMessages { get; }
        public Akka.Actor.IInternalActorRef Parent { get; }
        public Akka.Actor.Props Props { get; }
        public System.Nullable<System.TimeSpan> ReceiveTimeout { get; }
        public Akka.Actor.IActorRef Self { get; }
        public Akka.Actor.IActorRef Sender { get; }
        public Akka.Actor.ActorSystem System { get; }
        public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }
        public Akka.Dispatch.ActorTaskScheduler TaskScheduler { get; }
        public virtual Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }
        public Akka.Actor.ActorSelection ActorSelection(string path) { }
        public Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath path) { }
        protected void AddressTerminated(Akka.Actor.Address address) { }
        protected void AddWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }
        public virtual Akka.Actor.IActorRef AttachChild(Akka.Actor.Props props, bool isSystemService, string name = null) { }
        protected virtual void AutoReceiveMessage(Akka.Actor.Envelope envelope) { }
        public void Become(Akka.Actor.Receive receive) { }
        public void BecomeStacked(Akka.Actor.Receive receive) { }
        public void CheckReceiveTimeout() { }
        protected void ClearActor(Akka.Actor.ActorBase actor) { }
        protected void ClearActorCell() { }
        protected virtual Akka.Actor.ActorBase CreateNewActorInstance() { }
        [System.ObsoleteAttribute("Use TryGetChildStatsByName", true)]
        public Akka.Actor.IInternalActorRef GetChildByName(string name) { }
        public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }
        public static Akka.Actor.IActorRef GetCurrentSelfOrNoSender() { }
        public static Akka.Actor.IActorRef GetCurrentSenderOrNoSender() { }
        [System.ObsoleteAttribute("Use TryGetSingleChild")]
        public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public void Init(bool sendSupervise, Akka.Dispatch.MailboxType mailboxType) { }
        public Akka.Actor.Internal.ChildRestartStats InitChild(Akka.Actor.IInternalActorRef actor) { }
        public void Invoke(Akka.Actor.Envelope envelope) { }
        protected void PrepareForNewActor() { }
        protected virtual void PreStart() { }
        protected void ReceivedTerminated(Akka.Actor.Terminated t) { }
        public void ReceiveMessageForTest(Akka.Actor.Envelope envelope) { }
        protected Akka.Actor.Internal.SuspendReason RemoveChildAndGetStateChange(Akka.Actor.IActorRef child) { }
        protected void RemWatcher(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }
        public void ReserveChild(string name) { }
        public void Restart(System.Exception cause) { }
        public void Resume(System.Exception causedByFailure) { }
        public virtual void SendMessage(Akka.Actor.Envelope message) { }
        public virtual void SendMessage(Akka.Actor.IActorRef sender, object message) { }
        public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }
        protected void SetActorFields(Akka.Actor.ActorBase actor) { }
        protected bool SetChildrenTerminationReason(Akka.Actor.Internal.SuspendReason reason) { }
        public void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout = null) { }
        protected void SetTerminated() { }
        public static Akka.Actor.NameAndUid SplitNameAndUid(string name) { }
        public virtual void Start() { }
        protected void Stash(Akka.Dispatch.SysMsg.SystemMessage msg) { }
        public void Stop() { }
        public void Stop(Akka.Actor.IActorRef child) { }
        public void Suspend() { }
        protected void TellWatchersWeDied() { }
        public void TerminatedQueuedFor(Akka.Actor.IActorRef subject) { }
        public bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child) { }
        protected bool TryGetChildStatsByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats child) { }
        public bool TryGetSingleChild(string name, out Akka.Actor.IInternalActorRef child) { }
        public void UnbecomeStacked() { }
        protected void UnreserveChild(string name) { }
        public Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject) { }
        protected void UnwatchWatchedActors(Akka.Actor.ActorBase actor) { }
        public void UseThreadContext(System.Action action) { }
        public Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject) { }
        protected void WatchedActorTerminated(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }
    }
    public sealed class ActorIdentity
    {
        public ActorIdentity(object messageId, Akka.Actor.IActorRef subject) { }
        public object MessageId { get; }
        public Akka.Actor.IActorRef Subject { get; }
        public override string ToString() { }
    }
    public class ActorInitializationException : Akka.Actor.AkkaException
    {
        protected ActorInitializationException() { }
        public ActorInitializationException(string message) { }
        public ActorInitializationException(string message, System.Exception cause) { }
        public ActorInitializationException(Akka.Actor.IActorRef actor, string message, System.Exception cause = null) { }
        protected ActorInitializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public Akka.Actor.IActorRef Actor { get; }
        public override string ToString() { }
    }
    public class ActorInterruptedException : Akka.Actor.AkkaException
    {
        public ActorInterruptedException(string message = null, System.Exception cause = null) { }
    }
    public class ActorKilledException : Akka.Actor.AkkaException
    {
        public ActorKilledException(string message) { }
        protected ActorKilledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class ActorNotFoundException : Akka.Actor.AkkaException
    {
        public ActorNotFoundException() { }
        protected ActorNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public ActorNotFoundException(string message, System.Exception innerException = null) { }
    }
    public abstract class ActorPath : Akka.Util.ISurrogated, System.IComparable<Akka.Actor.ActorPath>, System.IEquatable<Akka.Actor.ActorPath>
    {
        protected ActorPath(Akka.Actor.Address address, string name) { }
        protected ActorPath(Akka.Actor.ActorPath parentPath, string name, long uid) { }
        public Akka.Actor.Address Address { get; }
        public System.Collections.Generic.IReadOnlyList<string> Elements { get; }
        public System.Collections.Generic.IReadOnlyList<string> ElementsWithUid { get; }
        public string Name { get; }
        public abstract Akka.Actor.ActorPath Parent { get; }
        public abstract Akka.Actor.ActorPath Root { get; }
        public long Uid { get; }
        public Akka.Actor.ActorPath Child(string childName) { }
        public abstract int CompareTo(Akka.Actor.ActorPath other);
        public bool Equals(Akka.Actor.ActorPath other) { }
        public override bool Equals(object obj) { }
        public static string FormatPathElements(System.Collections.Generic.IEnumerable<string> pathElements) { }
        public override int GetHashCode() { }
        public static bool IsValidPathElement(string s) { }
        public static Akka.Actor.ActorPath Parse(string path) { }
        public string ToSerializationFormat() { }
        public string ToSerializationFormatWithAddress(Akka.Actor.Address address) { }
        public override string ToString() { }
        public string ToStringWithAddress() { }
        public string ToStringWithAddress(Akka.Actor.Address address) { }
        public string ToStringWithoutAddress() { }
        public string ToStringWithUid() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public static bool TryParse(string path, out Akka.Actor.ActorPath actorPath) { }
        public static bool TryParseAddress(string path, out Akka.Actor.Address address) { }
        public abstract Akka.Actor.ActorPath WithUid(long uid);
        public class Surrogate : Akka.Util.ISurrogate, System.IEquatable<Akka.Actor.ActorPath.Surrogate>, System.IEquatable<Akka.Actor.ActorPath>
        {
            public Surrogate(string path) { }
            public string Path { get; }
            public bool Equals(Akka.Actor.ActorPath.Surrogate other) { }
            public bool Equals(Akka.Actor.ActorPath other) { }
            public override bool Equals(object obj) { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
            public override int GetHashCode() { }
        }
    }
    public class ActorProducerPipeline : System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin>, System.Collections.IEnumerable
    {
        public ActorProducerPipeline(System.Lazy<Akka.Event.ILoggingAdapter> log, System.Collections.Generic.IEnumerable<Akka.Actor.IActorProducerPlugin> plugins) { }
        public int Count { get; }
        public void AfterActorIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public void BeforeActorIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public System.Collections.Generic.IEnumerator<Akka.Actor.IActorProducerPlugin> GetEnumerator() { }
    }
    public class ActorProducerPipelineResolver
    {
        public ActorProducerPipelineResolver(System.Func<Akka.Event.ILoggingAdapter> logBuilder) { }
        public int TotalPluginCount { get; }
        public bool Insert(int index, Akka.Actor.IActorProducerPlugin plugin) { }
        public bool IsRegistered(Akka.Actor.IActorProducerPlugin plugin) { }
        public bool Register(Akka.Actor.IActorProducerPlugin plugin) { }
        public bool Unregister(Akka.Actor.IActorProducerPlugin plugin) { }
    }
    public abstract class ActorProducerPluginBase : Akka.Actor.IActorProducerPlugin
    {
        protected ActorProducerPluginBase() { }
        public virtual void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public virtual void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public virtual bool CanBeAppliedTo(System.Type actorType) { }
    }
    public abstract class ActorProducerPluginBase<TActor> : Akka.Actor.IActorProducerPlugin
        where TActor : Akka.Actor.ActorBase
    {
        protected ActorProducerPluginBase() { }
        public virtual void AfterIncarnated(TActor actor, Akka.Actor.IActorContext context) { }
        public virtual void BeforeIncarnated(TActor actor, Akka.Actor.IActorContext context) { }
        public virtual bool CanBeAppliedTo(System.Type actorType) { }
    }
    public abstract class ActorRefBase : Akka.Actor.IActorRef, Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        protected ActorRefBase() { }
        public abstract Akka.Actor.ActorPath Path { get; }
        public int CompareTo(object obj) { }
        public int CompareTo(Akka.Actor.IActorRef other) { }
        public override bool Equals(object obj) { }
        public bool Equals(Akka.Actor.IActorRef other) { }
        public override int GetHashCode() { }
        public void Tell(object message, Akka.Actor.IActorRef sender) { }
        protected abstract void TellInternal(object message, Akka.Actor.IActorRef sender);
        public override string ToString() { }
        public virtual Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class Surrogate : Akka.Util.ISurrogate
        {
            public Surrogate(string path) { }
            public string Path { get; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class static ActorRefExtensions
    {
        public static bool IsNobody(this Akka.Actor.IActorRef actorRef) { }
    }
    public class static ActorRefFactoryExtensions
    {
        public static Akka.Actor.IActorRef ActorOf<TActor>(this Akka.Actor.IActorRefFactory factory, string name = null)
            where TActor : Akka.Actor.ActorBase, new () { }
        public static Akka.Actor.ActorSelection ActorSelection(this Akka.Actor.IActorRefFactory factory, Akka.Actor.IActorRef anchorRef, string actorPath) { }
    }
    public class static ActorRefFactoryShared
    {
        public static Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath, Akka.Actor.ActorSystem system) { }
        public static Akka.Actor.ActorSelection ActorSelection(string path, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef lookupRoot) { }
        public static Akka.Actor.ActorSelection ActorSelection(Akka.Actor.IActorRef anchorActorRef, string path) { }
    }
    public class static ActorRefImplicitSenderExtensions
    {
        public static void Forward(this Akka.Actor.IActorRef receiver, object message) { }
        public static void Tell(this Akka.Actor.IActorRef receiver, object message) { }
    }
    public class static ActorRefs
    {
        public static readonly Akka.Actor.Nobody Nobody;
        public static readonly Akka.Actor.IActorRef NoSender;
    }
    public abstract class ActorRefWithCell : Akka.Actor.InternalActorRefBase
    {
        protected ActorRefWithCell() { }
        public abstract System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }
        public abstract Akka.Actor.ICell Underlying { get; }
        public abstract Akka.Actor.IInternalActorRef GetSingleChild(string name);
    }
    public class ActorSelection : Akka.Actor.ICanTell
    {
        public ActorSelection() { }
        public ActorSelection(Akka.Actor.IActorRef anchor, Akka.Actor.SelectionPathElement[] path) { }
        public ActorSelection(Akka.Actor.IActorRef anchor, string path) { }
        public ActorSelection(Akka.Actor.IActorRef anchor, System.Collections.Generic.IEnumerable<string> elements) { }
        public Akka.Actor.IActorRef Anchor { get; }
        public Akka.Actor.SelectionPathElement[] Path { get; }
        public string PathString { get; }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Actor.ActorSelection other) { }
        public override int GetHashCode() { }
        public System.Threading.Tasks.Task<Akka.Actor.IActorRef> ResolveOne(System.TimeSpan timeout) { }
        public void Tell(object message, Akka.Actor.IActorRef sender = null) { }
        public override string ToString() { }
    }
    public class ActorSelectionMessage : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IPossiblyHarmful
    {
        public ActorSelectionMessage(object message, Akka.Actor.SelectionPathElement[] elements, bool wildCardFanOut = False) { }
        public Akka.Actor.SelectionPathElement[] Elements { get; }
        public object Message { get; }
        public bool WildCardFanOut { get; }
        public override string ToString() { }
    }
    public class ActorStashPlugin : Akka.Actor.ActorProducerPluginBase
    {
        public ActorStashPlugin() { }
        public override void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public override void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context) { }
        public override bool CanBeAppliedTo(System.Type actorType) { }
    }
    public abstract class ActorSystem : Akka.Actor.IActorRefFactory, System.IDisposable
    {
        protected ActorSystem() { }
        public abstract Akka.Actor.IActorRef DeadLetters { get; }
        public abstract Akka.Dispatch.Dispatchers Dispatchers { get; }
        public abstract Akka.Event.EventStream EventStream { get; }
        public abstract Akka.Event.ILoggingAdapter Log { get; }
        public abstract Akka.Dispatch.Mailboxes Mailboxes { get; }
        public abstract string Name { get; }
        public abstract Akka.Actor.IScheduler Scheduler { get; }
        public abstract Akka.Serialization.Serialization Serialization { get; }
        public abstract Akka.Actor.Settings Settings { get; }
        public System.TimeSpan StartTime { get; }
        [System.ObsoleteAttribute("Use WhenTerminated instead. This property will be removed in future versions")]
        public abstract System.Threading.Tasks.Task TerminationTask { get; }
        public System.TimeSpan Uptime { get; }
        public abstract System.Threading.Tasks.Task WhenTerminated { get; }
        public abstract Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null);
        public abstract Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath);
        public abstract Akka.Actor.ActorSelection ActorSelection(string actorPath);
        [System.ObsoleteAttribute("Use WhenTerminated instead. This method will be removed in future versions")]
        public abstract void AwaitTermination();
        [System.ObsoleteAttribute("Use WhenTerminated instead. This method will be removed in future versions")]
        public abstract bool AwaitTermination(System.TimeSpan timeout);
        [System.ObsoleteAttribute("Use WhenTerminated instead. This method will be removed in future versions")]
        public abstract bool AwaitTermination(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken);
        public static Akka.Actor.ActorSystem Create(string name, Akka.Configuration.Config config) { }
        public static Akka.Actor.ActorSystem Create(string name) { }
        public void Dispose() { }
        public abstract object GetExtension(Akka.Actor.IExtensionId extensionId);
        public abstract T GetExtension<T>()
            where T :  class, Akka.Actor.IExtension;
        public abstract bool HasExtension(System.Type t);
        public abstract bool HasExtension<T>()
            where T :  class, Akka.Actor.IExtension;
        public abstract object RegisterExtension(Akka.Actor.IExtensionId extension);
        public abstract void RegisterOnTermination(System.Action code);
        [System.ObsoleteAttribute("Use Terminate instead. This method will be removed in future versions")]
        public abstract void Shutdown();
        public abstract void Stop(Akka.Actor.IActorRef actor);
        public abstract System.Threading.Tasks.Task Terminate();
        public abstract bool TryGetExtension(System.Type extensionType, out object extension);
        public abstract bool TryGetExtension<T>(out T extension)
            where T :  class, Akka.Actor.IExtension;
        [System.ObsoleteAttribute("Use AwaitTermination instead")]
        public void WaitForShutdown() { }
    }
    public class static ActorSystemWithExtensions
    {
        public static T WithExtension<T>(this Akka.Actor.ActorSystem system)
            where T :  class, Akka.Actor.IExtension { }
        public static T WithExtension<T>(this Akka.Actor.ActorSystem system, System.Type extensionId)
            where T :  class, Akka.Actor.IExtension { }
        public static T WithExtension<T, TI>(this Akka.Actor.ActorSystem system)
            where T :  class, Akka.Actor.IExtension
            where TI : Akka.Actor.IExtensionId { }
    }
    public sealed class Address : Akka.Util.ISurrogated, System.ICloneable, System.IEquatable<Akka.Actor.Address>
    {
        public static readonly Akka.Actor.Address AllSystems;
        public Address(string protocol, string system, string host = null, System.Nullable<int> port = null) { }
        public bool HasGlobalScope { get; }
        public bool HasLocalScope { get; }
        public string Host { get; }
        public System.Nullable<int> Port { get; }
        public string Protocol { get; }
        public string System { get; }
        public object Clone() { }
        public bool Equals(Akka.Actor.Address other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public string HostPort() { }
        public static Akka.Actor.Address Parse(string address) { }
        public override string ToString() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Address WithHost(string host = null) { }
        public Akka.Actor.Address WithPort(System.Nullable<int> port = null) { }
        public Akka.Actor.Address WithProtocol(string protocol) { }
        public Akka.Actor.Address WithSystem(string system) { }
        public class AddressSurrogate : Akka.Util.ISurrogate
        {
            public AddressSurrogate() { }
            public string Host { get; set; }
            public System.Nullable<int> Port { get; set; }
            public string Protocol { get; set; }
            public string System { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public abstract class AkkaException : System.Exception
    {
        protected AkkaException() { }
        protected AkkaException(string message, System.Exception cause = null) { }
        protected AkkaException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        protected System.Exception Cause { get; }
    }
    public class AllForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.AllForOneStrategy>
    {
        public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public AllForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }
        public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }
        public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }
        public AllForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public AllForOneStrategy(Akka.Actor.IDecider decider) { }
        protected AllForOneStrategy() { }
        public override Akka.Actor.IDecider Decider { get; }
        public int MaxNumberOfRetries { get; }
        public int WithinTimeRangeMilliseconds { get; }
        public bool Equals(Akka.Actor.AllForOneStrategy other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception x) { }
        public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }
        [System.ObsoleteAttribute()]
        protected override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, System.Exception cause, Akka.Actor.Internal.ChildRestartStats failedChildStats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> allChildren) { }
        protected override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class AllForOneStrategySurrogate : Akka.Util.ISurrogate
        {
            public AllForOneStrategySurrogate() { }
            public Akka.Actor.IDecider Decider { get; set; }
            public bool LoggingEnabled { get; set; }
            public int MaxNumberOfRetries { get; set; }
            public int WithinTimeRangeMilliseconds { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class AlreadyCanceledCancelable : Akka.Actor.ICancelable
    {
        public static Akka.Actor.ICancelable Instance { get; }
        public bool IsCancellationRequested { get; }
        public System.Threading.CancellationToken Token { get; }
        public void Cancel() { }
        public void Cancel(bool throwOnFirstException) { }
    }
    public class AskTimeoutException : Akka.Actor.AkkaException
    {
        public AskTimeoutException(string message) { }
        protected AskTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class Cancelable : Akka.Actor.ICancelable, System.IDisposable
    {
        public Cancelable(Akka.Actor.IActionScheduler scheduler, System.TimeSpan delay) { }
        public Cancelable(Akka.Actor.IScheduler scheduler, System.TimeSpan delay) { }
        public Cancelable(Akka.Actor.IScheduler scheduler, int millisecondsDelay) { }
        public Cancelable(Akka.Actor.IScheduler scheduler) { }
        public Cancelable(Akka.Actor.IActionScheduler scheduler) { }
        public bool IsCancellationRequested { get; }
        public System.Threading.CancellationToken Token { get; }
        public void Cancel() { }
        public void Cancel(bool throwOnFirstException) { }
        public void CancelAfter(System.TimeSpan delay) { }
        public void CancelAfter(int millisecondsDelay) { }
        public static Akka.Actor.ICancelable CreateCanceled() { }
        public static Akka.Actor.ICancelable CreateLinkedCancelable(Akka.Actor.IScheduler scheduler, params Akka.Actor.ICancelable[] cancelables) { }
        public static Akka.Actor.ICancelable CreateLinkedCancelable(Akka.Actor.IActionScheduler scheduler, params Akka.Actor.ICancelable[] cancelables) { }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
    }
    public class static CancelableExtensions
    {
        public static void CancelIfNotNull(this Akka.Actor.ICancelable cancelable) { }
    }
    public class ChildActorPath : Akka.Actor.ActorPath
    {
        public ChildActorPath(Akka.Actor.ActorPath parentPath, string name, long uid) { }
        public override Akka.Actor.ActorPath Parent { get; }
        public override Akka.Actor.ActorPath Root { get; }
        public override int CompareTo(Akka.Actor.ActorPath other) { }
        public override Akka.Actor.ActorPath WithUid(long uid) { }
    }
    public class DateTimeOffsetNowTimeProvider : Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider
    {
        public System.TimeSpan HighResMonotonicClock { get; }
        public static Akka.Actor.DateTimeOffsetNowTimeProvider Instance { get; }
        public System.TimeSpan MonotonicClock { get; }
        public System.DateTimeOffset Now { get; }
    }
    public class DeadLetterActorRef : Akka.Actor.EmptyLocalActorRef
    {
        public DeadLetterActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }
        protected override bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class DeadLetterMailbox : Akka.Dispatch.Mailbox
    {
        public DeadLetterMailbox(Akka.Actor.IActorRef deadLetters) { }
    }
    public class DeathPactException : Akka.Actor.AkkaException
    {
        public DeathPactException(Akka.Actor.IActorRef deadActor) { }
        protected DeathPactException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public Akka.Actor.IActorRef DeadActor { get; }
    }
    public class static Decider
    {
        public static Akka.Actor.DeployableDecider From(Akka.Actor.Directive defaultDirective, params System.Collections.Generic.KeyValuePair<, >[] pairs) { }
        public static Akka.Actor.DeployableDecider From(Akka.Actor.Directive defaultDirective, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive>> pairs) { }
        public static Akka.Actor.LocalOnlyDecider From(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
    }
    [System.ObsoleteAttribute("Replaced with HashedWheelTimerScheduler")]
    public class DedicatedThreadScheduler : Akka.Actor.SchedulerBase, Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider, System.IDisposable
    {
        [System.ObsoleteAttribute("Dangerous and bad. Use DedicatedThreadScheduler(Config config, ILoggingAdapter lo" +
            "g) instead.")]
        public DedicatedThreadScheduler(Akka.Actor.ActorSystem sys) { }
        public DedicatedThreadScheduler(Akka.Configuration.Config config, Akka.Event.ILoggingAdapter log) { }
        public override System.TimeSpan HighResMonotonicClock { get; }
        public override System.TimeSpan MonotonicClock { get; }
        protected override System.DateTimeOffset TimeNow { get; }
        public void Dispose() { }
        protected override void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }
    }
    public class DefaultSupervisorStrategy : Akka.Actor.SupervisorStrategyConfigurator
    {
        public DefaultSupervisorStrategy() { }
        public override Akka.Actor.SupervisorStrategy Create() { }
    }
    public class Deploy : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Deploy>
    {
        public static readonly Akka.Actor.Deploy Local;
        public static readonly string NoDispatcherGiven;
        public static readonly string NoMailboxGiven;
        public static readonly Akka.Actor.Deploy None;
        public static readonly Akka.Actor.Scope NoScopeGiven;
        public Deploy() { }
        public Deploy(string path, Akka.Actor.Scope scope) { }
        public Deploy(Akka.Actor.Scope scope) { }
        public Deploy(Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope) { }
        public Deploy(Akka.Routing.RouterConfig routerConfig) { }
        public Deploy(string path, Akka.Configuration.Config config, Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope, string dispatcher) { }
        public Deploy(string path, Akka.Configuration.Config config, Akka.Routing.RouterConfig routerConfig, Akka.Actor.Scope scope, string dispatcher, string mailbox) { }
        public Akka.Configuration.Config Config { get; }
        public string Dispatcher { get; }
        public string Mailbox { get; }
        public string Path { get; }
        public Akka.Routing.RouterConfig RouterConfig { get; }
        public Akka.Actor.Scope Scope { get; }
        public bool Equals(Akka.Actor.Deploy other) { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Deploy WithDispatcher(string dispatcher) { }
        public Akka.Actor.Deploy WithFallback(Akka.Actor.Deploy other) { }
        public Akka.Actor.Deploy WithMailbox(string mailbox) { }
        public Akka.Actor.Deploy WithRouterConfig(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Actor.Deploy WithScope(Akka.Actor.Scope scope) { }
        public class DeploySurrogate : Akka.Util.ISurrogate
        {
            public DeploySurrogate() { }
            public Akka.Configuration.Config Config { get; set; }
            public string Dispatcher { get; set; }
            public string Mailbox { get; set; }
            public string Path { get; set; }
            public Akka.Routing.RouterConfig RouterConfig { get; set; }
            public Akka.Actor.Scope Scope { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class DeployableDecider : Akka.Actor.IDecider, System.IEquatable<Akka.Actor.DeployableDecider>
    {
        protected DeployableDecider() { }
        public DeployableDecider(Akka.Actor.Directive defaultDirective, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive>> pairs) { }
        public DeployableDecider(Akka.Actor.Directive defaultDirective, params System.Collections.Generic.KeyValuePair<, >[] pairs) { }
        public Akka.Actor.Directive DefaultDirective { get; }
        public System.Collections.Generic.KeyValuePair<, >[] Pairs { get; }
        public Akka.Actor.Directive Decide(System.Exception cause) { }
        public bool Equals(Akka.Actor.DeployableDecider other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public class Deployer
    {
        protected readonly Akka.Configuration.Config Default;
        public Deployer(Akka.Actor.Settings settings) { }
        public Akka.Actor.Deploy Lookup(Akka.Actor.ActorPath path) { }
        public Akka.Actor.Deploy Lookup(System.Collections.Generic.IEnumerable<string> path) { }
        public Akka.Actor.Deploy Lookup(System.Collections.Generic.IEnumerator<string> path) { }
        public virtual Akka.Actor.Deploy ParseConfig(string key, Akka.Configuration.Config config) { }
        public void SetDeploy(Akka.Actor.Deploy deploy) { }
    }
    [System.ObsoleteAttribute("Deprecated. Will be removed")]
    public class static DeprecatedSchedulerExtensions
    {
        [System.ObsoleteAttribute("Use ScheduleTellRepeatedly() or Context.SelfTellRepeatedly() which will return an" +
            " ICancelable. This method will be removed in future versions.")]
        public static void Schedule(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.IActorRef receiver, object message) { }
        [System.ObsoleteAttribute("Use ScheduleTellRepeatedly() or Context.SelfTellRepeatedly() instead. This method" +
            " will be removed in future versions.")]
        public static void Schedule(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.IActorRef receiver, object message, System.Threading.CancellationToken cancellationToken) { }
        [System.ObsoleteAttribute("To schedule sending messages use ScheduleTellRepeatedly. Scheduling actions insid" +
            "e actors is discouraged, but if you really need to, use Advanced.ScheduleRepeate" +
            "dly(). This method will be removed in future versions.")]
        public static void Schedule(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }
        [System.ObsoleteAttribute("To schedule sending messages use ScheduleTellRepeatedly. Scheduling actions insid" +
            "e actors is discouraged, but if you really need to, use Advanced.ScheduleRepeate" +
            "dly(). This method will be removed in future versions.")]
        public static void Schedule(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, System.Threading.CancellationToken cancellationToken) { }
        [System.ObsoleteAttribute("Use ScheduleTellOnce() or Context.SelfTellOnce() which will return an ICancelable" +
            ". This method will be removed in future versions.")]
        public static void ScheduleOnce(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, Akka.Actor.IActorRef receiver, object message) { }
        [System.ObsoleteAttribute("Use ScheduleTellOnce() or Context.SelfTellOnce() which will return an ICancelable" +
            ". This method will be removed in future versions.")]
        public static void ScheduleOnce(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, Akka.Actor.IActorRef receiver, object message, System.Threading.CancellationToken cancellationToken) { }
        [System.ObsoleteAttribute("To schedule sending messages use ScheduleTellOnce. Scheduling actions inside acto" +
            "rs is discouraged, but if you really need to, use Advanced.ScheduleOnce(). This " +
            "method will be removed in future versions.")]
        public static void ScheduleOnce(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.Action action) { }
        [System.ObsoleteAttribute("To schedule sending messages use ScheduleTellOnce. Scheduling actions inside acto" +
            "rs is discouraged, but if you really need to, use Advanced.ScheduleOnce(). This " +
            "method will be removed in future versions.")]
        public static void ScheduleOnce(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.Action action, System.Threading.CancellationToken cancellationToken) { }
    }
    public enum Directive
    {
        Resume = 0,
        Restart = 1,
        Escalate = 2,
        Stop = 3,
    }
    public class static DirectiveExtensions
    {
        public static System.Collections.Generic.KeyValuePair<System.Type, Akka.Actor.Directive> When<TException>(this Akka.Actor.Directive self)
            where TException : System.Exception { }
    }
    public class EmptyLocalActorRef : Akka.Actor.MinimalActorRef
    {
        public EmptyLocalActorRef(Akka.Actor.IActorRefProvider provider, Akka.Actor.ActorPath path, Akka.Event.EventStream eventStream) { }
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated>")]
        public override bool IsTerminated { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        protected virtual bool SpecialHandle(object message, Akka.Actor.IActorRef sender) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public struct Envelope
    {
        public Envelope(object message, Akka.Actor.IActorRef sender, Akka.Actor.ActorSystem system) { }
        public Envelope(object message, Akka.Actor.IActorRef sender) { }
        public object Message { get; }
        public Akka.Actor.IActorRef Sender { get; }
        public override string ToString() { }
    }
    public class EventStreamActor : Akka.Actor.ActorBase
    {
        public EventStreamActor() { }
        protected override bool Receive(object message) { }
    }
    public abstract class ExtendedActorSystem : Akka.Actor.ActorSystem
    {
        protected ExtendedActorSystem() { }
        public abstract Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }
        public abstract Akka.Actor.IInternalActorRef Guardian { get; }
        public abstract Akka.Actor.IInternalActorRef LookupRoot { get; }
        public abstract Akka.Actor.IActorRefProvider Provider { get; }
        public abstract Akka.Actor.IInternalActorRef SystemGuardian { get; }
        public abstract void Abort();
        public abstract Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null);
        public abstract Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)
            where TActor : Akka.Actor.ActorBase, new ();
    }
    public abstract class ExtensionIdProvider<T> : Akka.Actor.IExtensionId, Akka.Actor.IExtensionId<T>
        where T : Akka.Actor.IExtension
    {
        protected ExtensionIdProvider() { }
        public System.Type ExtensionType { get; }
        public T Apply(Akka.Actor.ActorSystem system) { }
        public abstract T CreateExtension(Akka.Actor.ExtendedActorSystem system);
        public override bool Equals(object obj) { }
        public T Get(Akka.Actor.ActorSystem system) { }
        public override int GetHashCode() { }
    }
    public class Failure
    {
        public Failure() { }
        public System.Exception Exception { get; set; }
        public System.DateTime Timestamp { get; set; }
    }
    public class Failures
    {
        public Failures() { }
        public System.Collections.Generic.List<Akka.Actor.Failure> Entries { get; }
    }
    public abstract class FSM<TState, TData> : Akka.Actor.FSMBase, Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState, TData>, Akka.Routing.IListeners
    {
        protected bool DebugEvent;
        protected FSM() { }
        public Akka.Routing.ListenerSupport Listeners { get; }
        public TData NextStateData { get; }
        public TData StateData { get; }
        public TState StateName { get; }
        public void CancelTimer(string name) { }
        public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName) { }
        public Akka.Actor.FSMBase.State<TState, TData> GoTo(TState nextStateName, TData stateData) { }
        public void Initialize() { }
        public bool IsTimerActive(string name) { }
        protected virtual void LogTermination(Akka.Actor.FSMBase.Reason reason) { }
        public void OnTermination(System.Action<Akka.Actor.FSMBase.StopEvent<TState, TData>> terminationHandler) { }
        public void OnTransition(Akka.Actor.FSM<TState, TData>.TransitionHandler transitionHandler) { }
        protected override void PostStop() { }
        protected override bool Receive(object message) { }
        public void SetStateTimeout(TState state, System.Nullable<System.TimeSpan> timeout) { }
        public void SetTimer(string name, object msg, System.TimeSpan timeout, bool repeat = False) { }
        public void StartWith(TState stateName, TData stateData, System.Nullable<System.TimeSpan> timeout = null) { }
        public Akka.Actor.FSMBase.State<TState, TData> Stay() { }
        public Akka.Actor.FSMBase.State<TState, TData> Stop() { }
        public Akka.Actor.FSMBase.State<TState, TData> Stop(Akka.Actor.FSMBase.Reason reason) { }
        public Akka.Actor.FSMBase.State<TState, TData> Stop(Akka.Actor.FSMBase.Reason reason, TData stateData) { }
        public Akka.Actor.FSM<TState, TData>.TransformHelper Transform(Akka.Actor.FSM<TState, TData>.StateFunction func) { }
        public void When(TState stateName, Akka.Actor.FSM<TState, TData>.StateFunction func, System.Nullable<System.TimeSpan> timeout = null) { }
        public void WhenUnhandled(Akka.Actor.FSM<TState, TData>.StateFunction stateFunction) { }
        public delegate Akka.Actor.FSMBase.State<TState, TData> StateFunction<TState, TData>(Akka.Actor.FSMBase.Event<TData> fsmEvent);
        public sealed class TransformHelper<TState, TData>
        {
            public TransformHelper(Akka.Actor.FSM<TState, TData>.StateFunction func) { }
            public Akka.Actor.FSM<TState, TData>.StateFunction Func { get; }
            public Akka.Actor.FSM<TState, TData>.StateFunction Using(System.Func<Akka.Actor.FSMBase.State<TState, TData>, Akka.Actor.FSMBase.State<TState, TData>> andThen) { }
        }
        public delegate void TransitionHandler<TState, TData>(TState initialState, TState nextState);
    }
    public abstract class FSMBase : Akka.Actor.ActorBase
    {
        protected FSMBase() { }
        public class CurrentState<TS>
        {
            public CurrentState(Akka.Actor.IActorRef fsmRef, TS state) { }
            public Akka.Actor.IActorRef FsmRef { get; }
            public TS State { get; }
        }
        public class Event<TD> : Akka.Actor.INoSerializationVerificationNeeded
        {
            public Event(object fsmEvent, TD stateData) { }
            public object FsmEvent { get; }
            public TD StateData { get; }
            public override string ToString() { }
        }
        public class Failure : Akka.Actor.FSMBase.Reason
        {
            public Failure(object cause) { }
            public object Cause { get; }
        }
        public class LogEntry<TS, TD>
        {
            public LogEntry(TS stateName, TD stateData, object fsmEvent) { }
            public object FsmEvent { get; }
            public TD StateData { get; }
            public TS StateName { get; }
        }
        public class Normal : Akka.Actor.FSMBase.Reason
        {
            public Normal() { }
        }
        public abstract class Reason
        {
            protected Reason() { }
        }
        public class Shutdown : Akka.Actor.FSMBase.Reason
        {
            public Shutdown() { }
        }
        public class State<TS, TD> : System.IEquatable<Akka.Actor.FSMBase.State<TS, TD>>
        {
            public State(TS stateName, TD stateData, System.Nullable<System.TimeSpan> timeout = null, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.List<object> replies = null) { }
            public System.Collections.Generic.List<object> Replies { get; set; }
            public TD StateData { get; }
            public TS StateName { get; }
            public Akka.Actor.FSMBase.Reason StopReason { get; }
            public System.Nullable<System.TimeSpan> Timeout { get; }
            public Akka.Actor.FSMBase.State<TS, TD> Copy(System.Nullable<System.TimeSpan> timeout, Akka.Actor.FSMBase.Reason stopReason = null, System.Collections.Generic.List<object> replies = null) { }
            public bool Equals(Akka.Actor.FSMBase.State<TS, TD> other) { }
            public override bool Equals(object obj) { }
            public Akka.Actor.FSMBase.State<TS, TD> ForMax(System.TimeSpan timeout) { }
            public override int GetHashCode() { }
            public Akka.Actor.FSMBase.State<TS, TD> Replying(object replyValue) { }
            public override string ToString() { }
            public Akka.Actor.FSMBase.State<TS, TD> Using(TD nextStateData) { }
        }
        public class StateTimeout
        {
            public StateTimeout() { }
        }
        public class StopEvent<TS, TD> : Akka.Actor.INoSerializationVerificationNeeded
        {
            public StopEvent(Akka.Actor.FSMBase.Reason reason, TS terminatedState, TD stateData) { }
            public Akka.Actor.FSMBase.Reason Reason { get; }
            public TD StateData { get; }
            public TS TerminatedState { get; }
        }
        public class SubscribeTransitionCallBack
        {
            public SubscribeTransitionCallBack(Akka.Actor.IActorRef actorRef) { }
            public Akka.Actor.IActorRef ActorRef { get; }
        }
        public class Transition<TS>
        {
            public Transition(Akka.Actor.IActorRef fsmRef, TS from, TS to) { }
            public TS From { get; }
            public Akka.Actor.IActorRef FsmRef { get; }
            public TS To { get; }
            public override string ToString() { }
        }
        public class UnsubscribeTransitionCallBack
        {
            public UnsubscribeTransitionCallBack(Akka.Actor.IActorRef actorRef) { }
            public Akka.Actor.IActorRef ActorRef { get; }
        }
    }
    public class FutureActorRef : Akka.Actor.MinimalActorRef
    {
        public FutureActorRef(System.Threading.Tasks.TaskCompletionSource<object> result, System.Action unregister, Akka.Actor.ActorPath path) { }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class static Futures
    {
        public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }
        public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<object> Ask(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout = null) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Threading.CancellationToken cancellationToken) { }
        public static System.Threading.Tasks.Task<T> Ask<T>(this Akka.Actor.ICanTell self, object message, System.Nullable<System.TimeSpan> timeout, System.Threading.CancellationToken cancellationToken) { }
    }
    public class static GracefulStopSupport
    {
        public static System.Threading.Tasks.Task<bool> GracefulStop(this Akka.Actor.IActorRef target, System.TimeSpan timeout) { }
        public static System.Threading.Tasks.Task<bool> GracefulStop(this Akka.Actor.IActorRef target, System.TimeSpan timeout, object stopMessage) { }
    }
    public class GuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        public GuardianActor() { }
        protected override void PreStart() { }
        protected override bool Receive(object message) { }
    }
    public class HashedWheelTimerScheduler : Akka.Actor.SchedulerBase, Akka.Actor.IDateTimeOffsetNowTimeProvider, Akka.Actor.ITimeProvider, System.IDisposable
    {
        public HashedWheelTimerScheduler(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }
        public override System.TimeSpan HighResMonotonicClock { get; }
        public override System.TimeSpan MonotonicClock { get; }
        protected override System.DateTimeOffset TimeNow { get; }
        public void Dispose() { }
        protected override void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }
        protected override void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable) { }
    }
    public interface IActionScheduler
    {
        void ScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);
        void ScheduleOnce(System.TimeSpan delay, System.Action action);
        void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);
        void ScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action);
    }
    public interface IActorContext : Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch
    {
        Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        Akka.Actor.IActorRef Parent { get; }
        Akka.Actor.Props Props { get; }
        System.Nullable<System.TimeSpan> ReceiveTimeout { get; }
        Akka.Actor.IActorRef Self { get; }
        Akka.Actor.IActorRef Sender { get; }
        Akka.Actor.ActorSystem System { get; }
        void Become(Akka.Actor.Receive receive);
        [System.ObsoleteAttribute("Use Become or BecomeStacked instead. This method will be removed in future versio" +
            "ns")]
        void Become(Akka.Actor.Receive receive, bool discardOld = True);
        void BecomeStacked(Akka.Actor.Receive receive);
        Akka.Actor.IActorRef Child(string name);
        System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> GetChildren();
        void SetReceiveTimeout(System.Nullable<System.TimeSpan> timeout);
        void Stop(Akka.Actor.IActorRef child);
        [System.ObsoleteAttribute("Use UnbecomeStacked instead. This method will be removed in future versions")]
        void Unbecome();
        void UnbecomeStacked();
    }
    [System.ObsoleteAttribute()]
    public interface IActorLogging
    {
        Akka.Event.ILoggingAdapter Log { get; }
    }
    public interface IActorProducerPlugin
    {
        void AfterIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context);
        void BeforeIncarnated(Akka.Actor.ActorBase actor, Akka.Actor.IActorContext context);
        bool CanBeAppliedTo(System.Type actorType);
    }
    public interface IActorRef : Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        Akka.Actor.ActorPath Path { get; }
    }
    public interface IActorRefFactory
    {
        Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null);
        Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath);
        Akka.Actor.ActorSelection ActorSelection(string actorPath);
    }
    public interface IActorRefProvider
    {
        Akka.Actor.IActorRef DeadLetters { get; }
        Akka.Actor.Address DefaultAddress { get; }
        Akka.Actor.Deployer Deployer { get; }
        Akka.Actor.LocalActorRef Guardian { get; }
        Akka.Actor.IInternalActorRef RootGuardian { get; }
        Akka.Actor.ActorPath RootPath { get; }
        Akka.Actor.Settings Settings { get; }
        Akka.Actor.LocalActorRef SystemGuardian { get; }
        Akka.Actor.IInternalActorRef TempContainer { get; }
        System.Threading.Tasks.Task TerminationTask { get; }
        Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async);
        Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address);
        void Init(Akka.Actor.Internal.ActorSystemImpl system);
        void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path);
        Akka.Actor.IActorRef ResolveActorRef(string path);
        Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath actorPath);
        Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address);
        Akka.Actor.ActorPath TempPath();
        void UnregisterTempActor(Akka.Actor.ActorPath path);
    }
    public interface IActorRefScope
    {
        bool IsLocal { get; }
    }
    public interface IActorStash
    {
        Akka.Actor.IStash Stash { get; set; }
    }
    public interface IAdvancedScheduler : Akka.Actor.IActionScheduler { }
    public interface IAutoReceivedMessage : Akka.Actor.INoSerializationVerificationNeeded { }
    public interface ICancelable
    {
        bool IsCancellationRequested { get; }
        System.Threading.CancellationToken Token { get; }
        void Cancel();
        void Cancel(bool throwOnFirstException);
        void CancelAfter(System.TimeSpan delay);
        void CancelAfter(int millisecondsDelay);
    }
    public interface ICanTell
    {
        void Tell(object message, Akka.Actor.IActorRef sender);
    }
    public interface ICanWatch
    {
        Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject);
        Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject);
    }
    public interface ICell
    {
        Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }
        bool HasMessages { get; }
        bool IsLocal { get; }
        bool IsTerminated { get; }
        int NumberOfMessages { get; }
        Akka.Actor.IInternalActorRef Parent { get; }
        Akka.Actor.Props Props { get; }
        Akka.Actor.IActorRef Self { get; }
        Akka.Actor.ActorSystem System { get; }
        Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }
        Akka.Actor.IInternalActorRef GetChildByName(string name);
        [System.ObsoleteAttribute("Used ChildrenRefs instead")]
        System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren();
        Akka.Actor.IInternalActorRef GetSingleChild(string name);
        void Restart(System.Exception cause);
        void Resume(System.Exception causedByFailure);
        void SendMessage(Akka.Actor.IActorRef sender, object message);
        void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);
        void Start();
        void Stop();
        void Suspend();
        bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child);
    }
    public interface IDateTimeOffsetNowTimeProvider : Akka.Actor.ITimeProvider { }
    public interface IDecider
    {
        Akka.Actor.Directive Decide(System.Exception cause);
    }
    public sealed class Identify : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.INotInfluenceReceiveTimeout
    {
        public Identify(object messageId) { }
        public object MessageId { get; }
        public override string ToString() { }
    }
    public interface IExtension { }
    public interface IExtensionId
    {
        System.Type ExtensionType { get; }
        object Apply(Akka.Actor.ActorSystem system);
        object CreateExtension(Akka.Actor.ExtendedActorSystem system);
        object Get(Akka.Actor.ActorSystem system);
    }
    public interface IExtensionId<out T> : Akka.Actor.IExtensionId
        where out T : Akka.Actor.IExtension
    {
        T Apply(Akka.Actor.ActorSystem system);
        T CreateExtension(Akka.Actor.ExtendedActorSystem system);
        T Get(Akka.Actor.ActorSystem system);
    }
    public interface IHandle<in TMessage>
    {
        void Handle(TMessage message);
    }
    public interface IInboxable : Akka.Actor.ICanWatch
    {
        Akka.Actor.IActorRef Receiver { get; }
        object Receive();
        object Receive(System.TimeSpan timeout);
        System.Threading.Tasks.Task<object> ReceiveAsync();
        System.Threading.Tasks.Task<object> ReceiveAsync(System.TimeSpan timeout);
        object ReceiveWhere(System.Predicate<object> predicate);
        object ReceiveWhere(System.Predicate<object> predicate, System.TimeSpan timeout);
        void Send(Akka.Actor.IActorRef target, object message);
    }
    public interface IIndirectActorProducer
    {
        System.Type ActorType { get; }
        Akka.Actor.ActorBase Produce();
        void Release(Akka.Actor.ActorBase actor);
    }
    public interface IInternalActor
    {
        Akka.Actor.IActorContext ActorContext { get; }
    }
    public interface IInternalActorRef : Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated>")]
        bool IsTerminated { get; }
        Akka.Actor.IInternalActorRef Parent { get; }
        Akka.Actor.IActorRefProvider Provider { get; }
        Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name);
        void Restart(System.Exception cause);
        void Resume(System.Exception causedByFailure = null);
        [System.ObsoleteAttribute("Use SendSystemMessage(message)")]
        void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message, Akka.Actor.IActorRef sender);
        void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);
        void Start();
        void Stop();
        void Suspend();
    }
    public class IllegalActorNameException : Akka.Actor.AkkaException
    {
        public IllegalActorNameException(string message) { }
        protected IllegalActorNameException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class IllegalActorStateException : Akka.Actor.AkkaException
    {
        public IllegalActorStateException(string message) { }
        protected IllegalActorStateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public interface ILoggingFSM { }
    public interface ILogReceive { }
    public class Inbox : Akka.Actor.ICanWatch, Akka.Actor.IInboxable, System.IDisposable
    {
        public Akka.Actor.IActorRef Receiver { get; }
        public static Akka.Actor.Inbox Create(Akka.Actor.ActorSystem system) { }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
        public object Receive() { }
        public object Receive(System.TimeSpan timeout) { }
        public System.Threading.Tasks.Task<object> ReceiveAsync() { }
        public System.Threading.Tasks.Task<object> ReceiveAsync(System.TimeSpan timeout) { }
        public object ReceiveWhere(System.Predicate<object> predicate) { }
        public object ReceiveWhere(System.Predicate<object> predicate, System.TimeSpan timeout) { }
        public void Send(Akka.Actor.IActorRef actorRef, object msg) { }
        public Akka.Actor.IActorRef Unwatch(Akka.Actor.IActorRef subject) { }
        public Akka.Actor.IActorRef Watch(Akka.Actor.IActorRef subject) { }
    }
    public interface INoSerializationVerificationNeeded { }
    public interface INotInfluenceReceiveTimeout { }
    public abstract class InternalActorRefBase : Akka.Actor.ActorRefBase, Akka.Actor.IActorRef, Akka.Actor.IActorRefScope, Akka.Actor.ICanTell, Akka.Actor.IInternalActorRef, Akka.Util.ISurrogated, System.IComparable, System.IComparable<Akka.Actor.IActorRef>, System.IEquatable<Akka.Actor.IActorRef>
    {
        protected InternalActorRefBase() { }
        public abstract bool IsLocal { get; }
        public abstract bool IsTerminated { get; }
        public abstract Akka.Actor.IInternalActorRef Parent { get; }
        public abstract Akka.Actor.IActorRefProvider Provider { get; }
        public abstract Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name);
        public abstract void Restart(System.Exception cause);
        public abstract void Resume(System.Exception causedByFailure = null);
        [System.ObsoleteAttribute("Use SendSystemMessage(message) instead")]
        public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message, Akka.Actor.IActorRef sender) { }
        public abstract void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message);
        public abstract void Start();
        public abstract void Stop();
        public abstract void Suspend();
    }
    public class InvalidActorNameException : Akka.Actor.AkkaException
    {
        public InvalidActorNameException(string message) { }
        public InvalidActorNameException(string message, System.Exception innerException) { }
        protected InvalidActorNameException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class InvalidMessageException : Akka.Actor.AkkaException
    {
        public InvalidMessageException() { }
        public InvalidMessageException(string message) { }
        protected InvalidMessageException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public interface IPossiblyHarmful { }
    public interface IRepointableRef : Akka.Actor.IActorRefScope
    {
        bool IsStarted { get; }
    }
    public interface IScheduler : Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider
    {
        Akka.Actor.IAdvancedScheduler Advanced { get; }
    }
    public interface IStash
    {
        System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> ClearStash();
        void Prepend(System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> envelopes);
        void Stash();
        void Unstash();
        void UnstashAll();
        void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate);
    }
    public interface ITellScheduler
    {
        void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender);
        void ScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
        void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender);
        void ScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
    }
    public interface ITimeProvider
    {
        System.TimeSpan HighResMonotonicClock { get; }
        System.TimeSpan MonotonicClock { get; }
        System.DateTimeOffset Now { get; }
    }
    public interface IUntypedActorContext : Akka.Actor.IActorContext, Akka.Actor.IActorRefFactory, Akka.Actor.ICanWatch
    {
        [System.ObsoleteAttribute("Use Become or BecomeStacked instead. This method will be removed in future versio" +
            "ns")]
        void Become(Akka.Actor.UntypedReceive receive, bool discardOld = True);
        void Become(Akka.Actor.UntypedReceive receive);
        void BecomeStacked(Akka.Actor.UntypedReceive receive);
    }
    [System.ObsoleteAttribute("Bounded stashing is not yet implemented. Unbounded stashing will be used instead")]
    public interface IWithBoundedStash : Akka.Actor.IActorStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics> { }
    public interface IWithUnboundedStash : Akka.Actor.IActorStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics> { }
    public sealed class Kill : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded
    {
        public static Akka.Actor.Kill Instance { get; }
        public override string ToString() { }
    }
    public class LocalActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope, Akka.Actor.ILocalRef
    {
        public LocalActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }
        public Akka.Actor.ActorCell Cell { get; }
        public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }
        protected Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        public override bool IsLocal { get; }
        public override bool IsTerminated { get; }
        protected Akka.Dispatch.MailboxType MailboxType { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.ActorPath Path { get; }
        protected Akka.Actor.Props Props { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        protected Akka.Actor.IInternalActorRef Supervisor { get; }
        protected Akka.Actor.ActorSystem System { get; }
        public override Akka.Actor.ICell Underlying { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        protected virtual Akka.Actor.ActorCell NewActorCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.IInternalActorRef self, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Actor.IInternalActorRef supervisor) { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class LocalActorRefProvider : Akka.Actor.IActorRefProvider
    {
        public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }
        public LocalActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream, Akka.Actor.Deployer deployer, System.Func<Akka.Actor.ActorPath, Akka.Actor.IInternalActorRef> deadLettersFactory) { }
        public Akka.Actor.IActorRef DeadLetters { get; }
        public Akka.Actor.Address DefaultAddress { get; }
        public Akka.Actor.Deployer Deployer { get; }
        public Akka.Event.EventStream EventStream { get; }
        public Akka.Actor.LocalActorRef Guardian { get; }
        public Akka.Event.ILoggingAdapter Log { get; }
        public Akka.Actor.IInternalActorRef RootGuardian { get; }
        public Akka.Actor.ActorPath RootPath { get; }
        public Akka.Actor.Settings Settings { get; }
        public Akka.Actor.LocalActorRef SystemGuardian { get; }
        public Akka.Actor.IInternalActorRef TempContainer { get; }
        public System.Threading.Tasks.Task TerminationTask { get; }
        public Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async) { }
        public Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address) { }
        public void Init(Akka.Actor.Internal.ActorSystemImpl system) { }
        public void RegisterExtraName(string name, Akka.Actor.IInternalActorRef actor) { }
        public void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path) { }
        public Akka.Actor.IActorRef ResolveActorRef(string path) { }
        public Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath path) { }
        public Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address) { }
        public Akka.Actor.ActorPath TempPath() { }
        public void UnregisterTempActor(Akka.Actor.ActorPath path) { }
    }
    public class LocalOnlyDecider : Akka.Actor.IDecider
    {
        public LocalOnlyDecider(System.Func<System.Exception, Akka.Actor.Directive> decider) { }
        public Akka.Actor.Directive Decide(System.Exception cause) { }
    }
    public class LocalScope : Akka.Actor.Scope, Akka.Util.ISurrogated
    {
        public static Akka.Actor.LocalScope Instance { get; }
        public override Akka.Actor.Scope Copy() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }
        public class LocalScopeSurrogate : Akka.Util.ISurrogate
        {
            public LocalScopeSurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class LoggerInitializationException : Akka.Actor.AkkaException
    {
        public LoggerInitializationException() { }
        public LoggerInitializationException(string message) { }
        public LoggerInitializationException(string message, System.Exception cause = null) { }
        protected LoggerInitializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public abstract class MinimalActorRef : Akka.Actor.InternalActorRefBase, Akka.Actor.IActorRefScope, Akka.Actor.ILocalRef
    {
        protected MinimalActorRef() { }
        public override bool IsLocal { get; }
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated>")]
        public override bool IsTerminated { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class NameAndUid
    {
        public NameAndUid(string name, int uid) { }
        public string Name { get; }
        public int Uid { get; }
        public override string ToString() { }
    }
    public sealed class Nobody : Akka.Actor.MinimalActorRef
    {
        public static Akka.Actor.Nobody Instance;
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class NobodySurrogate : Akka.Util.ISurrogate
        {
            public NobodySurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class OneForOneStrategy : Akka.Actor.SupervisorStrategy, System.IEquatable<Akka.Actor.OneForOneStrategy>
    {
        public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public OneForOneStrategy(System.Nullable<int> maxNrOfRetries, System.Nullable<System.TimeSpan> withinTimeRange, Akka.Actor.IDecider decider) { }
        public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }
        public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Akka.Actor.IDecider decider, bool loggingEnabled = True) { }
        public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider) { }
        public OneForOneStrategy(System.Func<System.Exception, Akka.Actor.Directive> localOnlyDecider, bool loggingEnabled = True) { }
        public OneForOneStrategy(Akka.Actor.IDecider decider) { }
        protected OneForOneStrategy() { }
        public override Akka.Actor.IDecider Decider { get; }
        public int MaxNumberOfRetries { get; }
        public int WithinTimeRangeMilliseconds { get; }
        public bool Equals(Akka.Actor.OneForOneStrategy other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        protected override Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception x) { }
        public override void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children) { }
        [System.ObsoleteAttribute()]
        protected override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, System.Exception cause, Akka.Actor.Internal.ChildRestartStats failedChildStats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> allChildren) { }
        protected override void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public class OneForOneStrategySurrogate : Akka.Util.ISurrogate
        {
            public OneForOneStrategySurrogate() { }
            public Akka.Actor.IDecider Decider { get; set; }
            public bool LoggingEnabled { get; set; }
            public int MaxNumberOfRetries { get; set; }
            public int WithinTimeRangeMilliseconds { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class static PipeToSupport
    {
        public static System.Threading.Tasks.Task PipeTo<T>(this System.Threading.Tasks.Task<T> taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null, System.Func<T, object> success = null, System.Func<System.Exception, object> failure = null) { }
        public static System.Threading.Tasks.Task PipeTo(this System.Threading.Tasks.Task taskToPipe, Akka.Actor.ICanTell recipient, Akka.Actor.IActorRef sender = null) { }
    }
    public sealed class PoisonPill : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression
    {
        public static Akka.Actor.PoisonPill Instance { get; }
        public override string ToString() { }
    }
    public class PostRestartException : Akka.Actor.ActorInitializationException
    {
        public PostRestartException(Akka.Actor.IActorRef actor, System.Exception cause, System.Exception originalCause) { }
        protected PostRestartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public System.Exception OriginalCause { get; }
    }
    public class PreRestartException : Akka.Actor.AkkaException
    {
        public PreRestartException(Akka.Actor.IActorRef actor, System.Exception restartException, System.Exception cause, object optionalMessage) { }
        protected PreRestartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class Props : Akka.Util.ISurrogated, System.IEquatable<Akka.Actor.Props>
    {
        public static readonly Akka.Actor.Props None;
        protected Props() { }
        protected Props(Akka.Actor.Props copy) { }
        public Props(System.Type type, object[] args) { }
        public Props(System.Type type) { }
        public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, System.Collections.Generic.IEnumerable<object> args) { }
        public Props(System.Type type, Akka.Actor.SupervisorStrategy supervisorStrategy, params object[] args) { }
        public Props(Akka.Actor.Deploy deploy, System.Type type, System.Collections.Generic.IEnumerable<object> args) { }
        public Props(Akka.Actor.Deploy deploy, System.Type type, params object[] args) { }
        public object[] Arguments { get; }
        public Akka.Actor.Deploy Deploy { get; set; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public string Dispatcher { get; }
        public static Akka.Actor.Props Empty { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public string Mailbox { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public Akka.Routing.RouterConfig RouterConfig { get; }
        public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public System.Type Type { get; }
        public string TypeName { get; }
        protected virtual Akka.Actor.Props Copy() { }
        public static Akka.Actor.Props Create<TActor>(System.Linq.Expressions.Expression<System.Func<TActor>> factory, Akka.Actor.SupervisorStrategy supervisorStrategy = null)
            where TActor : Akka.Actor.ActorBase { }
        public static Akka.Actor.Props Create<TActor>(params object[] args)
            where TActor : Akka.Actor.ActorBase { }
        public static Akka.Actor.Props Create<TActor>(Akka.Actor.SupervisorStrategy supervisorStrategy)
            where TActor : Akka.Actor.ActorBase, new () { }
        public static Akka.Actor.Props Create(System.Type type, params object[] args) { }
        public static Akka.Actor.Props CreateBy<TProducer>(params object[] args)
            where TProducer :  class, Akka.Actor.IIndirectActorProducer { }
        public bool Equals(Akka.Actor.Props other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public virtual Akka.Actor.ActorBase NewActor() { }
        public Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Props WithDeploy(Akka.Actor.Deploy deploy) { }
        public Akka.Actor.Props WithDispatcher(string dispatcher) { }
        public Akka.Actor.Props WithMailbox(string mailbox) { }
        public Akka.Actor.Props WithRouter(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Actor.Props WithSupervisorStrategy(Akka.Actor.SupervisorStrategy supervisorStrategy) { }
        public class PropsSurrogate : Akka.Util.ISurrogate
        {
            public PropsSurrogate() { }
            public object[] Arguments { get; set; }
            public Akka.Actor.Deploy Deploy { get; set; }
            public System.Type Type { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public delegate bool Receive(object message);
    public abstract class ReceiveActor : Akka.Actor.UntypedActor, Akka.Actor.Internal.IInitializableActor
    {
        protected ReceiveActor() { }
        protected void Become(System.Action configure) { }
        [System.ObsoleteAttribute("Use Become or BecomeStacked instead. This method will be removed in future versio" +
            "ns")]
        protected void Become(System.Action configure, bool discardOld = True) { }
        protected void BecomeStacked(System.Action configure) { }
        protected virtual void OnReceive(object message) { }
        [System.ObsoleteAttribute("Use ReceiveAsync instead. This method will be removed in future versions")]
        protected void Receive<T>(System.Func<T, System.Threading.Tasks.Task> handler) { }
        protected void Receive<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null) { }
        protected void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T> handler) { }
        protected void Receive(System.Type messageType, System.Action<object> handler, System.Predicate<object> shouldHandle = null) { }
        protected void Receive(System.Type messageType, System.Predicate<object> shouldHandle, System.Action<object> handler) { }
        protected void Receive<T>(System.Func<T, bool> handler) { }
        protected void Receive(System.Type messageType, System.Func<object, bool> handler) { }
        protected void ReceiveAny(System.Action<object> handler) { }
        protected void ReceiveAnyAsync(System.Func<object, System.Threading.Tasks.Task> handler) { }
        protected void ReceiveAsync<T>(System.Func<T, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }
        protected void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, System.Threading.Tasks.Task> handler) { }
        protected void ReceiveAsync(System.Type messageType, System.Func<object, System.Threading.Tasks.Task> handler, System.Predicate<object> shouldHandle = null) { }
        protected void ReceiveAsync(System.Type messageType, System.Predicate<object> shouldHandle, System.Func<object, System.Threading.Tasks.Task> handler) { }
    }
    public class ReceiveTimeout : Akka.Actor.IPossiblyHarmful
    {
        public static Akka.Actor.ReceiveTimeout Instance { get; }
    }
    public class static RelativeActorPath
    {
        public static System.Collections.Generic.IEnumerable<string> Unapply(string addr) { }
    }
    public class RemoteScope : Akka.Actor.Scope, System.IEquatable<Akka.Actor.RemoteScope>
    {
        protected RemoteScope() { }
        public RemoteScope(Akka.Actor.Address address) { }
        public Akka.Actor.Address Address { get; set; }
        public override Akka.Actor.Scope Copy() { }
        public bool Equals(Akka.Actor.RemoteScope other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override Akka.Actor.Scope WithFallback(Akka.Actor.Scope other) { }
    }
    public class RepointableActorRef : Akka.Actor.ActorRefWithCell, Akka.Actor.IActorRefScope, Akka.Actor.IRepointableRef
    {
        protected readonly Akka.Actor.ActorPath _path;
        protected readonly Akka.Dispatch.MessageDispatcher Dispatcher;
        protected readonly Akka.Actor.Props Props;
        protected readonly Akka.Actor.IInternalActorRef Supervisor;
        protected readonly Akka.Actor.Internal.ActorSystemImpl System;
        public RepointableActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path) { }
        public override System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> Children { get; }
        public override bool IsLocal { get; }
        public bool IsStarted { get; }
        public override bool IsTerminated { get; }
        public Akka.Actor.ICell Lookup { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Actor.ICell Underlying { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public Akka.Actor.RepointableActorRef Initialize(bool async) { }
        protected virtual Akka.Actor.ActorCell NewCell() { }
        public void Point() { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        public void SwapUnderlying(Akka.Actor.ICell cell) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class RootActorPath : Akka.Actor.ActorPath
    {
        public RootActorPath(Akka.Actor.Address address, string name = "") { }
        public override Akka.Actor.ActorPath Parent { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public override Akka.Actor.ActorPath Root { get; }
        public override int CompareTo(Akka.Actor.ActorPath other) { }
        public override Akka.Actor.ActorPath WithUid(long uid) { }
    }
    public class RootGuardianActorRef : Akka.Actor.LocalActorRef
    {
        public RootGuardianActorRef(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Dispatch.MessageDispatcher dispatcher, Akka.Dispatch.MailboxType mailboxType, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef deadLetters, System.Collections.Generic.IReadOnlyDictionary<string, Akka.Actor.IInternalActorRef> extraNames) { }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public void SetTempContainer(Akka.Actor.IInternalActorRef tempContainer) { }
    }
    public class RootGuardianSupervisor : Akka.Actor.MinimalActorRef
    {
        public RootGuardianSupervisor(Akka.Actor.RootActorPath root, Akka.Actor.IActorRefProvider provider, System.Threading.Tasks.TaskCompletionSource<Akka.Actor.Status> terminationPromise, Akka.Event.ILoggingAdapter log) { }
        public System.Exception CauseOfTermination { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage systemMessage) { }
        public override void Stop() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class ScheduledWork
    {
        public ScheduledWork(long tickExpires, System.Action action, System.Threading.CancellationToken token) { }
        public System.Action Action { get; set; }
        public long TickExpires { get; set; }
        public System.Threading.CancellationToken Token { get; set; }
    }
    public abstract class SchedulerBase : Akka.Actor.IActionScheduler, Akka.Actor.IAdvancedScheduler, Akka.Actor.IScheduler, Akka.Actor.ITellScheduler, Akka.Actor.ITimeProvider
    {
        protected readonly Akka.Event.ILoggingAdapter Log;
        protected readonly Akka.Configuration.Config SchedulerConfig;
        protected SchedulerBase(Akka.Configuration.Config scheduler, Akka.Event.ILoggingAdapter log) { }
        public abstract System.TimeSpan HighResMonotonicClock { get; }
        public abstract System.TimeSpan MonotonicClock { get; }
        protected abstract System.DateTimeOffset TimeNow { get; }
        protected abstract void InternalScheduleOnce(System.TimeSpan delay, System.Action action, Akka.Actor.ICancelable cancelable);
        protected abstract void InternalScheduleRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action, Akka.Actor.ICancelable cancelable);
        protected abstract void InternalScheduleTellOnce(System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
        protected abstract void InternalScheduleTellRepeatedly(System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable);
        protected static void ValidateDelay(System.TimeSpan delay, string parameterName) { }
        protected static void ValidateInterval(System.TimeSpan interval, string parameterName) { }
    }
    public sealed class SchedulerException : Akka.Actor.AkkaException
    {
        public SchedulerException(string message) { }
    }
    public class static SchedulerExtensions
    {
        public static void ScheduleOnce(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan delay, System.Action action) { }
        public static Akka.Actor.ICancelable ScheduleOnceCancelable(this Akka.Actor.IActionScheduler scheduler, int millisecondsDelay, System.Action action) { }
        public static void ScheduleRepeatedly(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, System.Action action) { }
        public static Akka.Actor.ICancelable ScheduleRepeatedlyCancelable(this Akka.Actor.IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, System.Action action) { }
        public static void ScheduleTellOnce(this Akka.Actor.ITellScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan delay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
        public static Akka.Actor.ICancelable ScheduleTellOnceCancelable(this Akka.Actor.IScheduler scheduler, int millisecondsDelay, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
        public static void ScheduleTellRepeatedly(this Akka.Actor.ITellScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender, Akka.Actor.ICancelable cancelable = null) { }
        public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, System.TimeSpan initialDelay, System.TimeSpan interval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
        public static Akka.Actor.ICancelable ScheduleTellRepeatedlyCancelable(this Akka.Actor.IScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Akka.Actor.ICanTell receiver, object message, Akka.Actor.IActorRef sender) { }
    }
    public abstract class Scope : System.IEquatable<Akka.Actor.Scope>
    {
        public static readonly Akka.Actor.LocalScope Local;
        protected Scope() { }
        public abstract Akka.Actor.Scope Copy();
        public virtual bool Equals(Akka.Actor.Scope other) { }
        public abstract Akka.Actor.Scope WithFallback(Akka.Actor.Scope other);
    }
    public class SelectChildName : Akka.Actor.SelectionPathElement
    {
        public SelectChildName(string name) { }
        public string Name { get; }
        public override string ToString() { }
    }
    public class SelectChildPattern : Akka.Actor.SelectionPathElement
    {
        public SelectChildPattern(string patternStr) { }
        public string PatternStr { get; }
        public override string ToString() { }
    }
    public abstract class SelectionPathElement
    {
        protected SelectionPathElement() { }
    }
    public class SelectParent : Akka.Actor.SelectionPathElement
    {
        public SelectParent() { }
        public override string ToString() { }
    }
    public class Settings
    {
        public Settings(Akka.Actor.ActorSystem system, Akka.Configuration.Config config) { }
        public bool AddLoggingReceive { get; }
        public System.TimeSpan AskTimeout { get; }
        public Akka.Configuration.Config Config { get; }
        public string ConfigVersion { get; }
        public System.TimeSpan CreationTimeout { get; }
        public bool DebugAutoReceive { get; }
        public bool DebugEventStream { get; }
        public bool DebugLifecycle { get; }
        public bool DebugRouterMisconfiguration { get; }
        public bool DebugUnhandledMessage { get; }
        public int DefaultVirtualNodesFactor { get; }
        public bool FsmDebugEvent { get; }
        public string Home { get; }
        public bool LogConfigOnStart { get; }
        public int LogDeadLetters { get; }
        public bool LogDeadLettersDuringShutdown { get; }
        public System.Collections.Generic.IList<string> Loggers { get; }
        public string LoggersDispatcher { get; }
        public System.TimeSpan LoggerStartTimeout { get; }
        public string LogLevel { get; }
        public string ProviderClass { get; }
        public string SchedulerClass { get; }
        public System.TimeSpan SchedulerShutdownTimeout { get; }
        public bool SerializeAllCreators { get; }
        public bool SerializeAllMessages { get; }
        public string StdoutLogLevel { get; }
        public string SupervisorStrategyClass { get; }
        public Akka.Actor.ActorSystem System { get; }
        public System.TimeSpan UnstartedPushTimeout { get; }
        public void InjectTopLevelFallback(Akka.Configuration.Config config) { }
        public override string ToString() { }
    }
    public class static StashFactory
    {
        public static Akka.Actor.IStash CreateStash<T>(this Akka.Actor.IActorContext context)
            where T : Akka.Actor.ActorBase { }
        public static Akka.Actor.IStash CreateStash(this Akka.Actor.IActorContext context, Akka.Actor.IActorStash actorInstance) { }
        public static Akka.Actor.IStash CreateStash(this Akka.Actor.IActorContext context, System.Type actorType) { }
    }
    public class StashOverflowException : Akka.Actor.AkkaException
    {
        public StashOverflowException(string message, System.Exception cause = null) { }
        protected StashOverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public abstract class Status
    {
        protected Status() { }
        public class Failure : Akka.Actor.Status
        {
            public readonly System.Exception Cause;
            public Failure(System.Exception cause) { }
            public override string ToString() { }
        }
        public class Success : Akka.Actor.Status
        {
            public readonly object Status;
            public Success(object status) { }
        }
    }
    public class StoppingSupervisorStrategy : Akka.Actor.SupervisorStrategyConfigurator
    {
        public StoppingSupervisorStrategy() { }
        public override Akka.Actor.SupervisorStrategy Create() { }
    }
    public abstract class SupervisorStrategy : Akka.Util.ISurrogated
    {
        public static Akka.Actor.IDecider DefaultDecider;
        public static readonly Akka.Actor.SupervisorStrategy DefaultStrategy;
        public static readonly Akka.Actor.OneForOneStrategy StoppingStrategy;
        protected SupervisorStrategy() { }
        public abstract Akka.Actor.IDecider Decider { get; }
        protected bool LoggingEnabled { get; set; }
        protected abstract Akka.Actor.Directive Handle(Akka.Actor.IActorRef child, System.Exception x);
        public abstract void HandleChildTerminated(Akka.Actor.IActorContext actorContext, Akka.Actor.IActorRef child, System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> children);
        [System.ObsoleteAttribute()]
        public bool HandleFailure(Akka.Actor.ActorCell actorCell, System.Exception cause, Akka.Actor.Internal.ChildRestartStats failedChildStats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> allChildren) { }
        public bool HandleFailure(Akka.Actor.ActorCell actorCell, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children) { }
        protected virtual void LogFailure(Akka.Actor.IActorContext context, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Directive directive) { }
        [System.ObsoleteAttribute()]
        protected abstract void ProcessFailure(Akka.Actor.IActorContext context, bool restart, System.Exception cause, Akka.Actor.Internal.ChildRestartStats failedChildStats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> allChildren);
        protected abstract void ProcessFailure(Akka.Actor.IActorContext context, bool restart, Akka.Actor.IActorRef child, System.Exception cause, Akka.Actor.Internal.ChildRestartStats stats, System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> children);
        protected void RestartChild(Akka.Actor.IActorRef child, System.Exception cause, bool suspendFirst) { }
        protected void ResumeChild(Akka.Actor.IActorRef child, System.Exception exception) { }
        public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);
    }
    public abstract class SupervisorStrategyConfigurator
    {
        protected SupervisorStrategyConfigurator() { }
        public abstract Akka.Actor.SupervisorStrategy Create();
        public static Akka.Actor.SupervisorStrategyConfigurator CreateConfigurator(string typeName) { }
    }
    public class SystemGuardianActor : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        public SystemGuardianActor(Akka.Actor.IActorRef userGuardian) { }
        protected override void PreRestart(System.Exception reason, object message) { }
        protected override bool Receive(object message) { }
    }
    public sealed class Terminated : Akka.Actor.IAutoReceivedMessage, Akka.Actor.INoSerializationVerificationNeeded, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression
    {
        public Terminated(Akka.Actor.IActorRef actorRef, bool existenceConfirmed, bool addressTerminated) { }
        public Akka.Actor.IActorRef ActorRef { get; }
        public bool AddressTerminated { get; }
        public bool ExistenceConfirmed { get; }
        public override string ToString() { }
    }
    public class TerminatedProps : Akka.Actor.Props
    {
        public TerminatedProps() { }
        public override Akka.Actor.ActorBase NewActor() { }
    }
    public abstract class TypedActor : Akka.Actor.ActorBase
    {
        protected TypedActor() { }
        protected virtual bool Receive(object message) { }
    }
    public class UnstartedCell : Akka.Actor.ICell
    {
        public UnstartedCell(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.RepointableActorRef self, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor) { }
        public Akka.Actor.Internal.IChildrenContainer ChildrenContainer { get; }
        public bool HasMessages { get; }
        public bool IsLocal { get; }
        public bool IsTerminated { get; }
        public int NumberOfMessages { get; }
        public Akka.Actor.IInternalActorRef Parent { get; }
        public Akka.Actor.Props Props { get; }
        public Akka.Actor.IActorRef Self { get; }
        public Akka.Actor.ActorSystem System { get; }
        public Akka.Actor.Internal.ActorSystemImpl SystemImpl { get; }
        public Akka.Actor.IInternalActorRef GetChildByName(string name) { }
        public System.Collections.Generic.IEnumerable<Akka.Actor.IInternalActorRef> GetChildren() { }
        public Akka.Actor.IInternalActorRef GetSingleChild(string name) { }
        public void ReplaceWith(Akka.Actor.ICell cell) { }
        public void Restart(System.Exception cause) { }
        public void Resume(System.Exception causedByFailure) { }
        public void SendMessage(Akka.Actor.IActorRef sender, object message) { }
        public void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public void Start() { }
        public void Stop() { }
        public void Suspend() { }
        public bool TryGetChildStatsByName(string name, out Akka.Actor.Internal.IChildStats child) { }
    }
    public abstract class UntypedActor : Akka.Actor.ActorBase
    {
        protected UntypedActor() { }
        protected static Akka.Actor.IUntypedActorContext Context { get; }
        [System.ObsoleteAttribute("Use Become or BecomeStacked instead. This method will be removed in future versio" +
            "ns")]
        protected void Become(Akka.Actor.UntypedReceive receive, bool discardOld = True) { }
        protected void Become(Akka.Actor.UntypedReceive receive) { }
        protected void BecomeStacked(Akka.Actor.UntypedReceive receive) { }
        protected abstract void OnReceive(object message);
        protected virtual bool Receive(object message) { }
        protected void RunTask(System.Action action) { }
        protected void RunTask(System.Func<System.Threading.Tasks.Task> action) { }
    }
    [System.ObsoleteAttribute("Inherit from UntypedActor and IWithBoundedStash instead. This class will be remov" +
        "ed in a future release.")]
    public abstract class UntypedActorWithBoundedStash : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithBoundedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics>
    {
        protected UntypedActorWithBoundedStash() { }
        public Akka.Actor.IStash CurrentStash { get; set; }
        protected override void PostStop() { }
        protected override void PreRestart(System.Exception reason, object message) { }
        public void Stash() { }
        public void Unstash() { }
        public void UnstashAll() { }
        public void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate) { }
    }
    [System.ObsoleteAttribute("Inherit from UntypedActor and IWithBoundedStash instead. This class will be remov" +
        "ed in a future release.")]
    public abstract class UntypedActorWithUnboundedStash : Akka.Actor.UntypedActor, Akka.Actor.IActorStash, Akka.Actor.IWithUnboundedStash, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics>
    {
        protected UntypedActorWithUnboundedStash() { }
        public Akka.Actor.IStash CurrentStash { get; set; }
        protected override void PostStop() { }
        protected override void PreRestart(System.Exception reason, object message) { }
        public void Stash() { }
        public void Unstash() { }
        public void UnstashAll() { }
        public void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate) { }
    }
    public delegate void UntypedReceive(object message);
}
namespace Akka.Actor.Dsl
{
    public sealed class Act : Akka.Actor.ReceiveActor, Akka.Actor.Dsl.IActorDsl
    {
        public Act(System.Action<Akka.Actor.Dsl.IActorDsl> config) { }
        public Act(System.Action<Akka.Actor.Dsl.IActorDsl, Akka.Actor.IActorContext> config) { }
        public System.Action<System.Exception, Akka.Actor.IActorContext> OnPostRestart { get; set; }
        public System.Action<Akka.Actor.IActorContext> OnPostStop { get; set; }
        public System.Action<System.Exception, object, Akka.Actor.IActorContext> OnPreRestart { get; set; }
        public System.Action<Akka.Actor.IActorContext> OnPreStart { get; set; }
        public Akka.Actor.SupervisorStrategy Strategy { get; set; }
        public Akka.Actor.IActorRef ActorOf(System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null) { }
        public void Become(System.Action<object, Akka.Actor.IActorContext> handler) { }
        public void BecomeStacked(System.Action<object, Akka.Actor.IActorContext> handler) { }
        public void DefaultPostRestart(System.Exception reason) { }
        public void DefaultPostStop() { }
        public void DefaultPreRestart(System.Exception reason, object message) { }
        public void DefaultPreStart() { }
        protected override void PostRestart(System.Exception reason) { }
        protected override void PostStop() { }
        protected override void PreRestart(System.Exception reason, object message) { }
        protected override void PreStart() { }
        public void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler) { }
        public void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle) { }
        public void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler) { }
        public void ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler) { }
        public void ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler) { }
        public void ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null) { }
        public void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler) { }
        protected override Akka.Actor.SupervisorStrategy SupervisorStrategy() { }
    }
    public class static ActExtensions
    {
        public static Akka.Actor.IActorRef ActorOf(this Akka.Actor.IActorRefFactory factory, System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null) { }
        public static Akka.Actor.IActorRef ActorOf(this Akka.Actor.IActorRefFactory factory, System.Action<Akka.Actor.Dsl.IActorDsl, Akka.Actor.IActorContext> config, string name = null) { }
    }
    public interface IActorDsl
    {
        System.Action<System.Exception, Akka.Actor.IActorContext> OnPostRestart { get; set; }
        System.Action<Akka.Actor.IActorContext> OnPostStop { get; set; }
        System.Action<System.Exception, object, Akka.Actor.IActorContext> OnPreRestart { get; set; }
        System.Action<Akka.Actor.IActorContext> OnPreStart { get; set; }
        Akka.Actor.SupervisorStrategy Strategy { get; set; }
        Akka.Actor.IActorRef ActorOf(System.Action<Akka.Actor.Dsl.IActorDsl> config, string name = null);
        void Become(System.Action<object, Akka.Actor.IActorContext> handler);
        void BecomeStacked(System.Action<object, Akka.Actor.IActorContext> handler);
        void DefaultPostRestart(System.Exception reason);
        void DefaultPostStop();
        void DefaultPreRestart(System.Exception reason, object message);
        void DefaultPreStart();
        void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler);
        void Receive<T>(System.Predicate<T> shouldHandle, System.Action<T, Akka.Actor.IActorContext> handler);
        void Receive<T>(System.Action<T, Akka.Actor.IActorContext> handler, System.Predicate<T> shouldHandle);
        void ReceiveAny(System.Action<object, Akka.Actor.IActorContext> handler);
        void ReceiveAnyAsync(System.Func<object, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);
        void ReceiveAsync<T>(System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler, System.Predicate<T> shouldHandle = null);
        void ReceiveAsync<T>(System.Predicate<T> shouldHandle, System.Func<T, Akka.Actor.IActorContext, System.Threading.Tasks.Task> handler);
        void UnbecomeStacked();
    }
}
namespace Akka.Actor.Internal
{
    public abstract class AbstractStash : Akka.Actor.IStash
    {
        protected AbstractStash(Akka.Actor.IActorContext context, int capacity = 100) { }
        public System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> ClearStash() { }
        public void Prepend(System.Collections.Generic.IEnumerable<Akka.Actor.Envelope> envelopes) { }
        public void Stash() { }
        public void Unstash() { }
        public void UnstashAll() { }
        public void UnstashAll(System.Func<Akka.Actor.Envelope, bool> predicate) { }
    }
    public class ActorSystemImpl : Akka.Actor.ExtendedActorSystem
    {
        public ActorSystemImpl(string name) { }
        public ActorSystemImpl(string name, Akka.Configuration.Config config) { }
        public override Akka.Actor.ActorProducerPipelineResolver ActorPipelineResolver { get; }
        public override Akka.Actor.IActorRef DeadLetters { get; }
        public override Akka.Dispatch.Dispatchers Dispatchers { get; }
        public override Akka.Event.EventStream EventStream { get; }
        public override Akka.Actor.IInternalActorRef Guardian { get; }
        public override Akka.Event.ILoggingAdapter Log { get; }
        public override Akka.Actor.IInternalActorRef LookupRoot { get; }
        public override Akka.Dispatch.Mailboxes Mailboxes { get; }
        public override string Name { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Actor.IScheduler Scheduler { get; }
        public override Akka.Serialization.Serialization Serialization { get; }
        public override Akka.Actor.Settings Settings { get; }
        public override Akka.Actor.IInternalActorRef SystemGuardian { get; }
        [System.ObsoleteAttribute("Use WhenTerminated instead. This property will be removed in future versions")]
        public override System.Threading.Tasks.Task TerminationTask { get; }
        public override System.Threading.Tasks.Task WhenTerminated { get; }
        public override void Abort() { }
        public override Akka.Actor.IActorRef ActorOf(Akka.Actor.Props props, string name = null) { }
        public override Akka.Actor.ActorSelection ActorSelection(Akka.Actor.ActorPath actorPath) { }
        public override Akka.Actor.ActorSelection ActorSelection(string actorPath) { }
        [System.ObsoleteAttribute("Use WhenTerminated instead. This method will be removed in future versions")]
        public override void AwaitTermination() { }
        [System.ObsoleteAttribute("Use WhenTerminated instead. This method will be removed in future versions")]
        public override bool AwaitTermination(System.TimeSpan timeout) { }
        [System.ObsoleteAttribute("Use WhenTerminated instead. This method will be removed in future versions")]
        public override bool AwaitTermination(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken) { }
        public override object GetExtension(Akka.Actor.IExtensionId extensionId) { }
        public override T GetExtension<T>()
            where T :  class, Akka.Actor.IExtension { }
        public override bool HasExtension(System.Type t) { }
        public override bool HasExtension<T>()
            where T :  class, Akka.Actor.IExtension { }
        public override object RegisterExtension(Akka.Actor.IExtensionId extension) { }
        public override void RegisterOnTermination(System.Action code) { }
        [System.ObsoleteAttribute("Use Terminate instead. This method will be removed in future versions")]
        public override void Shutdown() { }
        public void Start() { }
        public override void Stop(Akka.Actor.IActorRef actor) { }
        public override Akka.Actor.IActorRef SystemActorOf(Akka.Actor.Props props, string name = null) { }
        public override Akka.Actor.IActorRef SystemActorOf<TActor>(string name = null)
            where TActor : Akka.Actor.ActorBase, new () { }
        public override System.Threading.Tasks.Task Terminate() { }
        public override bool TryGetExtension(System.Type extensionType, out object extension) { }
        public override bool TryGetExtension<T>(out T extension)
            where T :  class, Akka.Actor.IExtension { }
    }
    public class BoundedStashImpl : Akka.Actor.Internal.AbstractStash
    {
        public BoundedStashImpl(Akka.Actor.IActorContext context, int capacity = 100) { }
    }
    public class ChildNameReserved : Akka.Actor.Internal.IChildStats
    {
        public static Akka.Actor.Internal.ChildNameReserved Instance { get; }
        public override string ToString() { }
    }
    public abstract class ChildrenContainerBase : Akka.Actor.Internal.IChildrenContainer
    {
        protected ChildrenContainerBase(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }
        protected System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> InternalChildren { get; }
        public virtual bool IsNormal { get; }
        public virtual bool IsTerminating { get; }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }
        public abstract Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);
        protected void ChildStatsAppender(System.Text.StringBuilder sb, System.Collections.Generic.KeyValuePair<string, Akka.Actor.Internal.IChildStats> kvp, int index) { }
        public bool Contains(Akka.Actor.IActorRef actor) { }
        public abstract Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);
        public abstract Akka.Actor.Internal.IChildrenContainer Reserve(string name);
        public abstract Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);
        public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }
        public bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }
        public abstract Akka.Actor.Internal.IChildrenContainer Unreserve(string name);
    }
    public class ChildRestartStats : Akka.Actor.Internal.IChildStats
    {
        public ChildRestartStats(Akka.Actor.IInternalActorRef child, uint maxNrOfRetriesCount = 0, long restartTimeWindowStartTicks = 0) { }
        public Akka.Actor.IInternalActorRef Child { get; }
        public uint MaxNrOfRetriesCount { get; }
        public long RestartTimeWindowStartTicks { get; }
        public long Uid { get; }
        public bool RequestRestartPermission(int maxNrOfRetries, int withinTimeMilliseconds) { }
    }
    public class EmptyChildrenContainer : Akka.Actor.Internal.IChildrenContainer
    {
        protected EmptyChildrenContainer() { }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }
        public static Akka.Actor.Internal.IChildrenContainer Instance { get; }
        public virtual bool IsNormal { get; }
        public virtual bool IsTerminating { get; }
        public System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }
        public virtual Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public bool Contains(Akka.Actor.IActorRef actor) { }
        public Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }
        public virtual Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }
        public override string ToString() { }
        public bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats) { }
        public bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats childRestartStats) { }
        public Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }
    }
    public interface IChildrenContainer
    {
        System.Collections.Generic.IReadOnlyCollection<Akka.Actor.IInternalActorRef> Children { get; }
        bool IsNormal { get; }
        bool IsTerminating { get; }
        System.Collections.Generic.IReadOnlyCollection<Akka.Actor.Internal.ChildRestartStats> Stats { get; }
        Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats);
        bool Contains(Akka.Actor.IActorRef actor);
        Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child);
        Akka.Actor.Internal.IChildrenContainer Reserve(string name);
        Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor);
        bool TryGetByName(string name, out Akka.Actor.Internal.IChildStats stats);
        bool TryGetByRef(Akka.Actor.IActorRef actor, out Akka.Actor.Internal.ChildRestartStats stats);
        Akka.Actor.Internal.IChildrenContainer Unreserve(string name);
    }
    public interface IChildStats { }
    public interface IInitializableActor
    {
        void Init();
    }
    public interface IInternalSupportsTestFSMRef<TState, TData>
    {
        bool IsStateTimerActive { get; }
        void ApplyState(Akka.Actor.FSMBase.State<TState, TData> upcomingState);
    }
    public class InternalActivateFsmLogging
    {
        public static Akka.Actor.Internal.InternalActivateFsmLogging Instance { get; }
    }
    public class static InternalCurrentActorCellKeeper
    {
        public static Akka.Actor.ActorCell Current { get; set; }
    }
    public class NormalChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase
    {
        public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public static Akka.Actor.Internal.IChildrenContainer Create(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children) { }
        public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }
        public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }
        public override string ToString() { }
        public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }
    }
    public abstract class SuspendReason
    {
        protected SuspendReason() { }
        public class Creation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren
        {
            public Creation() { }
        }
        public interface IWaitingForChildren { }
        public class Recreation : Akka.Actor.Internal.SuspendReason, Akka.Actor.Internal.SuspendReason.IWaitingForChildren
        {
            public Recreation(System.Exception cause) { }
            public System.Exception Cause { get; }
        }
        public class Termination : Akka.Actor.Internal.SuspendReason
        {
            public static Akka.Actor.Internal.SuspendReason.Termination Instance { get; }
        }
        public class UserRequest : Akka.Actor.Internal.SuspendReason
        {
            public static Akka.Actor.Internal.SuspendReason.UserRequest Instance { get; }
        }
    }
    public class TerminatedChildrenContainer : Akka.Actor.Internal.EmptyChildrenContainer
    {
        public new static Akka.Actor.Internal.IChildrenContainer Instance { get; }
        public override bool IsNormal { get; }
        public override bool IsTerminating { get; }
        public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public override string ToString() { }
    }
    public class TerminatingChildrenContainer : Akka.Actor.Internal.ChildrenContainerBase
    {
        public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, Akka.Actor.IActorRef toDie, Akka.Actor.Internal.SuspendReason reason) { }
        public TerminatingChildrenContainer(System.Collections.Immutable.IImmutableDictionary<string, Akka.Actor.Internal.IChildStats> children, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.IActorRef> toDie, Akka.Actor.Internal.SuspendReason reason) { }
        public override bool IsNormal { get; }
        public override bool IsTerminating { get; }
        public Akka.Actor.Internal.SuspendReason Reason { get; }
        public override Akka.Actor.Internal.IChildrenContainer Add(string name, Akka.Actor.Internal.ChildRestartStats stats) { }
        public Akka.Actor.Internal.IChildrenContainer CreateCopyWithReason(Akka.Actor.Internal.SuspendReason reason) { }
        public override Akka.Actor.Internal.IChildrenContainer Remove(Akka.Actor.IActorRef child) { }
        public override Akka.Actor.Internal.IChildrenContainer Reserve(string name) { }
        public override Akka.Actor.Internal.IChildrenContainer ShallDie(Akka.Actor.IActorRef actor) { }
        public override string ToString() { }
        public override Akka.Actor.Internal.IChildrenContainer Unreserve(string name) { }
    }
    public class UnboundedStashImpl : Akka.Actor.Internal.AbstractStash
    {
        public UnboundedStashImpl(Akka.Actor.IActorContext context) { }
    }
}
namespace Akka
{
    public class Case : Akka.IMatchResult
    {
        public Case(object message) { }
        public bool WasHandled { get; }
        public Akka.IMatchResult Default(System.Action<object> action) { }
        public Akka.Case With<TMessage>(System.Action action) { }
        public Akka.Case With<TMessage>(System.Action<TMessage> action) { }
    }
    public class Case<T> : Akka.IMatchResult
    {
        public Case(object message) { }
        public bool WasHandled { get; }
        public T ResultOrDefault(System.Func<object, T> function) { }
        public Akka.Case<T> With<TMessage>(System.Func<T> function) { }
        public Akka.Case<T> With<TMessage>(System.Func<TMessage, T> function) { }
    }
    public interface IMatchResult
    {
        bool WasHandled { get; }
    }
    public sealed class NotUsed : System.IComparable<Akka.NotUsed>, System.IEquatable<Akka.NotUsed>
    {
        public static readonly Akka.NotUsed Instance;
        public int CompareTo(Akka.NotUsed other) { }
        public override bool Equals(object obj) { }
        public bool Equals(Akka.NotUsed other) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class static PatternMatch
    {
        public static Akka.Case Match(this object target) { }
        public static Akka.Case<T> Match<T>(this object target) { }
    }
}
namespace Akka.Configuration
{
    public class Config
    {
        public static readonly Akka.Configuration.Config Empty;
        public Config() { }
        public Config(Akka.Configuration.Hocon.HoconRoot root) { }
        public Config(Akka.Configuration.Config source, Akka.Configuration.Config fallback) { }
        public Akka.Configuration.Config Fallback { get; }
        public virtual bool IsEmpty { get; }
        public Akka.Configuration.Hocon.HoconValue Root { get; }
        public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; set; }
        [System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(Akka.Configuration.Config.<AsEnumerable>d__46))]
        public virtual System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Akka.Configuration.Hocon.HoconValue>> AsEnumerable() { }
        protected Akka.Configuration.Config Copy(Akka.Configuration.Config fallback = null) { }
        public virtual bool GetBoolean(string path, bool default = False) { }
        public virtual System.Collections.Generic.IList<bool> GetBooleanList(string path) { }
        public virtual System.Collections.Generic.IList<byte> GetByteList(string path) { }
        public virtual System.Nullable<long> GetByteSize(string path) { }
        public virtual Akka.Configuration.Config GetConfig(string path) { }
        public virtual decimal GetDecimal(string path, [System.Runtime.CompilerServices.DecimalConstantAttribute(0, 0, 0u, 0u, 0u)] decimal @default) { }
        public virtual System.Collections.Generic.IList<decimal> GetDecimalList(string path) { }
        public virtual double GetDouble(string path, double default = 0) { }
        public virtual System.Collections.Generic.IList<double> GetDoubleList(string path) { }
        public virtual float GetFloat(string path, float default = 0) { }
        public virtual System.Collections.Generic.IList<float> GetFloatList(string path) { }
        public virtual int GetInt(string path, int default = 0) { }
        public virtual System.Collections.Generic.IList<int> GetIntList(string path) { }
        public virtual long GetLong(string path, long default = 0) { }
        public virtual System.Collections.Generic.IList<long> GetLongList(string path) { }
        [System.ObsoleteAttribute("Use GetTimeSpan to retrieve TimeSpan information. This method will be removed in " +
            "future versions.")]
        public System.TimeSpan GetMillisDuration(string path, System.Nullable<System.TimeSpan> default = null, bool allowInfinite = True) { }
        public virtual string GetString(string path, string default = null) { }
        public virtual System.Collections.Generic.IList<string> GetStringList(string path) { }
        public virtual System.TimeSpan GetTimeSpan(string path, System.Nullable<System.TimeSpan> default = null, bool allowInfinite = True) { }
        public Akka.Configuration.Hocon.HoconValue GetValue(string path) { }
        public virtual bool HasPath(string path) { }
        public override string ToString() { }
        public string ToString(bool includeFallback) { }
        public virtual Akka.Configuration.Config WithFallback(Akka.Configuration.Config fallback) { }
    }
    public class static ConfigExtensions
    {
        public static bool IsNullOrEmpty(this Akka.Configuration.Config config) { }
        public static Akka.Configuration.Config SafeWithFallback(this Akka.Configuration.Config config, Akka.Configuration.Config fallback) { }
    }
    public class ConfigurationException : Akka.Actor.AkkaException
    {
        public ConfigurationException(string message) { }
        public ConfigurationException(string message, System.Exception exception) { }
        protected ConfigurationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class ConfigurationFactory
    {
        public ConfigurationFactory() { }
        public static Akka.Configuration.Config Empty { get; }
        public static Akka.Configuration.Config Default() { }
        public static Akka.Configuration.Config FromObject(object source) { }
        public static Akka.Configuration.Config FromResource(string resourceName, object instanceInAssembly) { }
        public static Akka.Configuration.Config FromResource<TAssembly>(string resourceName) { }
        public static Akka.Configuration.Config FromResource(string resourceName, System.Reflection.Assembly assembly) { }
        public static Akka.Configuration.Config Load() { }
        public static Akka.Configuration.Config ParseString(string hocon, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }
        public static Akka.Configuration.Config ParseString(string hocon) { }
    }
}
namespace Akka.Configuration.Hocon
{
    public class AkkaConfigurationSection : System.Configuration.ConfigurationSection
    {
        public AkkaConfigurationSection() { }
        public Akka.Configuration.Config AkkaConfig { get; }
        [System.Configuration.ConfigurationPropertyAttribute("hocon", IsRequired=true)]
        public Akka.Configuration.Hocon.HoconConfigurationElement Hocon { get; set; }
    }
    public abstract class CDataConfigurationElement : System.Configuration.ConfigurationElement
    {
        protected const string ContentPropertyName = "content";
        protected CDataConfigurationElement() { }
        protected override void DeserializeElement(System.Xml.XmlReader reader, bool serializeCollectionKey) { }
    }
    public class HoconArray : System.Collections.Generic.List<Akka.Configuration.Hocon.HoconValue>, Akka.Configuration.Hocon.IHoconElement
    {
        public HoconArray() { }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsString() { }
        public override string ToString() { }
    }
    public class HoconConfigurationElement : Akka.Configuration.Hocon.CDataConfigurationElement
    {
        public HoconConfigurationElement() { }
        [System.Configuration.ConfigurationPropertyAttribute("content", IsKey=true, IsRequired=true)]
        public string Content { get; set; }
    }
    public class HoconLiteral : Akka.Configuration.Hocon.IHoconElement
    {
        public HoconLiteral() { }
        public string Value { get; set; }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsString() { }
        public override string ToString() { }
    }
    public class HoconObject : Akka.Configuration.Hocon.IHoconElement
    {
        public HoconObject() { }
        public System.Collections.Generic.Dictionary<string, Akka.Configuration.Hocon.HoconValue> Items { get; }
        [Newtonsoft.Json.JsonIgnoreAttribute()]
        public System.Collections.Generic.IDictionary<string, object> Unwrapped { get; }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public Akka.Configuration.Hocon.HoconValue GetKey(string key) { }
        public Akka.Configuration.Hocon.HoconValue GetOrCreateKey(string key) { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsString() { }
        public void Merge(Akka.Configuration.Hocon.HoconObject other) { }
        public override string ToString() { }
        public string ToString(int indent) { }
    }
    public class HoconRoot
    {
        protected HoconRoot() { }
        public HoconRoot(Akka.Configuration.Hocon.HoconValue value, System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> substitutions) { }
        public HoconRoot(Akka.Configuration.Hocon.HoconValue value) { }
        public System.Collections.Generic.IEnumerable<Akka.Configuration.Hocon.HoconSubstitution> Substitutions { get; }
        public Akka.Configuration.Hocon.HoconValue Value { get; }
    }
    public class HoconSubstitution : Akka.Configuration.Hocon.IHoconElement, Akka.Configuration.Hocon.IMightBeAHoconObject
    {
        protected HoconSubstitution() { }
        public HoconSubstitution(string path) { }
        public string Path { get; set; }
        public Akka.Configuration.Hocon.HoconValue ResolvedValue { get; set; }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public Akka.Configuration.Hocon.HoconObject GetObject() { }
        public string GetString() { }
        public bool IsArray() { }
        public bool IsObject() { }
        public bool IsString() { }
    }
    public class HoconTokenizer : Akka.Configuration.Hocon.Tokenizer
    {
        public HoconTokenizer(string text) { }
        public bool IsArrayEnd() { }
        public bool IsArrayStart() { }
        public bool IsAssignment() { }
        public bool IsComma() { }
        public bool IsDot() { }
        public bool IsEndOfObject() { }
        public bool IsInclude() { }
        public bool IsObjectStart() { }
        public bool IsSpaceOrTab() { }
        public bool IsStartOfComment() { }
        public bool IsStartOfQuotedText() { }
        public bool IsStartOfTripleQuotedText() { }
        public bool IsStartSimpleValue() { }
        public bool IsSubstitutionStart() { }
        public bool IsUnquotedKey() { }
        public bool IsUnquotedKeyStart() { }
        public bool IsWhitespace() { }
        public bool IsWhitespaceOrComment() { }
        public Akka.Configuration.Hocon.Token PullArrayEnd() { }
        public Akka.Configuration.Hocon.Token PullArrayStart() { }
        public Akka.Configuration.Hocon.Token PullAssignment() { }
        public Akka.Configuration.Hocon.Token PullComma() { }
        public Akka.Configuration.Hocon.Token PullComment() { }
        public Akka.Configuration.Hocon.Token PullDot() { }
        public Akka.Configuration.Hocon.Token PullEndOfObject() { }
        public Akka.Configuration.Hocon.Token PullInclude() { }
        public Akka.Configuration.Hocon.Token PullNext() { }
        public Akka.Configuration.Hocon.Token PullQuotedKey() { }
        public Akka.Configuration.Hocon.Token PullQuotedText() { }
        public string PullRestOfLine() { }
        public Akka.Configuration.Hocon.Token PullSimpleValue() { }
        public Akka.Configuration.Hocon.Token PullSpaceOrTab() { }
        public Akka.Configuration.Hocon.Token PullStartOfObject() { }
        public Akka.Configuration.Hocon.Token PullSubstitution() { }
        public Akka.Configuration.Hocon.Token PullTripleQuotedText() { }
        public Akka.Configuration.Hocon.Token PullUnquotedKey() { }
        public Akka.Configuration.Hocon.Token PullValue() { }
        public void PullWhitespaceAndComments() { }
    }
    public class HoconValue : Akka.Configuration.Hocon.IMightBeAHoconObject
    {
        public HoconValue() { }
        public HoconValue(System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> values, bool adoptedFromFallback = True) { }
        public bool IsEmpty { get; }
        public System.Collections.Generic.List<Akka.Configuration.Hocon.IHoconElement> Values { get; }
        public void AppendValue(Akka.Configuration.Hocon.IHoconElement value) { }
        public Akka.Configuration.Config AtKey(string key) { }
        public void Clear() { }
        public System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray() { }
        public bool GetBoolean() { }
        public System.Collections.Generic.IList<bool> GetBooleanList() { }
        public byte GetByte() { }
        public System.Collections.Generic.IList<byte> GetByteList() { }
        public System.Nullable<long> GetByteSize() { }
        public Akka.Configuration.Hocon.HoconValue GetChildObject(string key) { }
        public decimal GetDecimal() { }
        public System.Collections.Generic.IList<decimal> GetDecimalList() { }
        public double GetDouble() { }
        public System.Collections.Generic.IList<double> GetDoubleList() { }
        public float GetFloat() { }
        public System.Collections.Generic.IList<float> GetFloatList() { }
        public int GetInt() { }
        public System.Collections.Generic.IList<int> GetIntList() { }
        public long GetLong() { }
        public System.Collections.Generic.IList<long> GetLongList() { }
        [System.ObsoleteAttribute("Use GetTimeSpan to retrieve TimeSpan information. This method will be removed in " +
            "future versions.")]
        public System.TimeSpan GetMillisDuration(bool allowInfinite = True) { }
        public Akka.Configuration.Hocon.HoconObject GetObject() { }
        public string GetString() { }
        public System.Collections.Generic.IList<string> GetStringList() { }
        public System.TimeSpan GetTimeSpan(bool allowInfinite = True) { }
        public bool IsArray() { }
        public bool IsObject() { }
        public bool IsString() { }
        public void NewValue(Akka.Configuration.Hocon.IHoconElement value) { }
        public override string ToString() { }
        public virtual string ToString(int indent) { }
    }
    public interface IHoconElement
    {
        System.Collections.Generic.IList<Akka.Configuration.Hocon.HoconValue> GetArray();
        string GetString();
        bool IsArray();
        bool IsString();
    }
    public interface IMightBeAHoconObject
    {
        Akka.Configuration.Hocon.HoconObject GetObject();
        bool IsObject();
    }
    public class Parser
    {
        public Parser() { }
        public static Akka.Configuration.Hocon.HoconRoot Parse(string text, System.Func<string, Akka.Configuration.Hocon.HoconRoot> includeCallback) { }
        public Akka.Configuration.Hocon.HoconArray ParseArray(string currentPath) { }
        public void ParseValue(Akka.Configuration.Hocon.HoconValue owner, string currentPath) { }
    }
    public class Token
    {
        protected Token() { }
        public Token(Akka.Configuration.Hocon.TokenType type) { }
        public Token(string value) { }
        public Akka.Configuration.Hocon.TokenType Type { get; set; }
        public string Value { get; set; }
        public static Akka.Configuration.Hocon.Token Key(string key) { }
        public static Akka.Configuration.Hocon.Token LiteralValue(string value) { }
        public static Akka.Configuration.Hocon.Token Substitution(string path) { }
    }
    public class Tokenizer
    {
        public Tokenizer(string text) { }
        public bool EoF { get; }
        public bool Matches(string pattern) { }
        public bool Matches(params string[] patterns) { }
        public char Peek() { }
        public void Pop() { }
        public void PullWhitespace() { }
        public void Push() { }
        public string Take(int length) { }
        public char Take() { }
    }
    public enum TokenType
    {
        Comment = 0,
        Key = 1,
        LiteralValue = 2,
        Assign = 3,
        ObjectStart = 4,
        ObjectEnd = 5,
        Dot = 6,
        EoF = 7,
        ArrayStart = 8,
        ArrayEnd = 9,
        Comma = 10,
        Substitute = 11,
        Include = 12,
    }
}
namespace Akka.Dispatch
{
    public sealed class ActionRunnable : Akka.Dispatch.IRunnable
    {
        public ActionRunnable(System.Action action) { }
        public void Run() { }
    }
    public sealed class ActionWithStateRunnable : Akka.Dispatch.IRunnable
    {
        public ActionWithStateRunnable(System.Action<object> actionWithState, object state) { }
        public void Run() { }
    }
    public class ActorTaskScheduler : System.Threading.Tasks.TaskScheduler
    {
        public object CurrentMessage { get; }
        public override int MaximumConcurrencyLevel { get; }
        protected override System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks() { }
        protected override void QueueTask(System.Threading.Tasks.Task task) { }
        public static void RunTask(System.Action action) { }
        public static void RunTask(System.Func<System.Threading.Tasks.Task> asyncAction) { }
        protected override bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) { }
    }
    public sealed class BoundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue>
    {
        public BoundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int Capacity { get; }
        public System.TimeSpan PushTimeout { get; }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public sealed class BoundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.BoundedMessageQueue>
    {
        public BoundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int Capacity { get; }
        public System.TimeSpan PushTimeout { get; }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public sealed class CurrentSynchronizationContextDispatcher : Akka.Dispatch.Dispatcher
    {
        public CurrentSynchronizationContextDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }
    }
    public sealed class DefaultDispatcherPrerequisites : Akka.Dispatch.IDispatcherPrerequisites
    {
        public DefaultDispatcherPrerequisites(Akka.Event.EventStream eventStream, Akka.Actor.IScheduler scheduler, Akka.Actor.Settings settings, Akka.Dispatch.Mailboxes mailboxes) { }
        public Akka.Event.EventStream EventStream { get; }
        public Akka.Dispatch.Mailboxes Mailboxes { get; }
        public Akka.Actor.IScheduler Scheduler { get; }
        public Akka.Actor.Settings Settings { get; }
    }
    public class Dispatcher : Akka.Dispatch.MessageDispatcher
    {
        public Dispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }
        protected override void ExecuteTask(Akka.Dispatch.IRunnable run) { }
        protected override void Shutdown() { }
    }
    public sealed class DispatcherConfigurator : Akka.Dispatch.MessageDispatcherConfigurator
    {
        public DispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public override Akka.Dispatch.MessageDispatcher Dispatcher() { }
    }
    public sealed class Dispatchers
    {
        public static readonly string DefaultDispatcherId;
        public static readonly string SynchronizedDispatcherId;
        public Dispatchers(Akka.Actor.ActorSystem system, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public Akka.Configuration.Config DefaultDispatcherConfig { get; }
        public Akka.Dispatch.MessageDispatcher DefaultGlobalDispatcher { get; }
        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }
        public bool HasDispatcher(string id) { }
        public Akka.Dispatch.MessageDispatcher Lookup(string dispatcherName) { }
        public bool RegisterConfigurator(string id, Akka.Dispatch.MessageDispatcherConfigurator configurator) { }
    }
    public abstract class ExecutorService
    {
        protected ExecutorService(string id) { }
        public string Id { get; }
        public abstract void Execute(Akka.Dispatch.IRunnable run);
        public abstract void Shutdown();
    }
    public abstract class ExecutorServiceConfigurator : Akka.Dispatch.ExecutorServiceFactory
    {
        protected ExecutorServiceConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public Akka.Configuration.Config Config { get; }
        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }
    }
    public abstract class ExecutorServiceFactory
    {
        protected ExecutorServiceFactory() { }
        public abstract Akka.Dispatch.ExecutorService Produce(string id);
    }
    public class FutureActor : Akka.Actor.ActorBase
    {
        public FutureActor() { }
        public FutureActor(System.Threading.Tasks.TaskCompletionSource<object> completionSource, Akka.Actor.IActorRef respondTo) { }
        protected override bool Receive(object message) { }
    }
    public interface IBlockingMessageQueueSemantics : Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics
    {
        System.TimeSpan BlockTimeOut { get; set; }
    }
    public interface IBoundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics { }
    public interface IBoundedMessageQueueSemantics : Akka.Dispatch.ISemantics
    {
        System.TimeSpan PushTimeOut { get; }
    }
    public interface IDequeBasedMessageQueueSemantics : Akka.Dispatch.ISemantics
    {
        void EnqueueFirst(Akka.Actor.Envelope envelope);
    }
    public interface IDispatcherPrerequisites
    {
        Akka.Event.EventStream EventStream { get; }
        Akka.Dispatch.Mailboxes Mailboxes { get; }
        Akka.Actor.IScheduler Scheduler { get; }
        Akka.Actor.Settings Settings { get; }
    }
    public interface IMultipleConsumerSemantics : Akka.Dispatch.ISemantics { }
    public interface IProducesMessageQueue<TQueue>
        where TQueue : Akka.Dispatch.MessageQueues.IMessageQueue { }
    public interface IRequiresMessageQueue<T>
        where T : Akka.Dispatch.ISemantics { }
    public interface IRunnable
    {
        void Run();
    }
    public interface ISemantics { }
    public interface IUnboundedDequeBasedMessageQueueSemantics : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics { }
    public interface IUnboundedMessageQueueSemantics : Akka.Dispatch.ISemantics { }
    public class Mailbox : Akka.Dispatch.IRunnable
    {
        public Mailbox(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }
        public Akka.Dispatch.MessageDispatcher Dispatcher { get; }
        public Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue { get; }
        public virtual void CleanUp() { }
        [System.Diagnostics.ConditionalAttribute("MAILBOXDEBUG")]
        public static void DebugPrint(string message, params object[] args) { }
        public void Run() { }
        public virtual void SetActor(Akka.Actor.ActorCell actorCell) { }
    }
    public class Mailboxes
    {
        public static readonly string DefaultMailboxId;
        public static readonly string NoMailboxRequirement;
        public Mailboxes(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.DeadLetterMailbox DeadLetterMailbox { get; }
        public System.Type FromConfig(string path) { }
        public Akka.Dispatch.MailboxType GetMailboxType(Akka.Actor.Props props, Akka.Configuration.Config dispatcherConfig) { }
        public System.Type GetRequiredType(System.Type actorType) { }
        public bool HasRequiredType(System.Type actorType) { }
        public Akka.Dispatch.MailboxType Lookup(string id) { }
        public Akka.Dispatch.MailboxType LookupByQueueType(System.Type queueType) { }
        public bool ProducesMessageQueue(System.Type mailboxType) { }
    }
    public abstract class MailboxType
    {
        protected readonly Akka.Configuration.Config Config;
        protected readonly Akka.Actor.Settings Settings;
        protected MailboxType(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public abstract Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system);
    }
    public abstract class MessageDispatcher
    {
        public const int DefaultThroughput = 100;
        protected MessageDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator) { }
        public Akka.Dispatch.MessageDispatcherConfigurator Configurator { get; }
        public Akka.Event.EventStream EventStream { get; }
        public string Id { get; set; }
        protected long Inhabitants { get; }
        public Akka.Dispatch.Mailboxes Mailboxes { get; }
        public System.TimeSpan ShutdownTimeout { get; set; }
        public int Throughput { get; set; }
        public System.Nullable<long> ThroughputDeadlineTime { get; set; }
        public virtual void Attach(Akka.Actor.ActorCell cell) { }
        public virtual void Detach(Akka.Actor.ActorCell cell) { }
        public virtual void Dispatch(Akka.Actor.ActorCell cell, Akka.Actor.Envelope envelope) { }
        protected abstract void ExecuteTask(Akka.Dispatch.IRunnable run);
        protected void ReportFailure(System.Exception ex) { }
        public void Schedule(System.Action run) { }
        public void Schedule(Akka.Dispatch.IRunnable run) { }
        protected abstract void Shutdown();
        public virtual void SystemDispatch(Akka.Actor.ActorCell cell, Akka.Dispatch.SysMsg.SystemMessage message) { }
    }
    public abstract class MessageDispatcherConfigurator
    {
        protected MessageDispatcherConfigurator(Akka.Configuration.Config config, Akka.Dispatch.IDispatcherPrerequisites prerequisites) { }
        public Akka.Configuration.Config Config { get; }
        public Akka.Dispatch.IDispatcherPrerequisites Prerequisites { get; }
        protected Akka.Dispatch.ExecutorServiceConfigurator ConfigureExecutor() { }
        public abstract Akka.Dispatch.MessageDispatcher Dispatcher();
    }
    public sealed class PinnedDispatcher : Akka.Dispatch.Dispatcher
    {
        public PinnedDispatcher(Akka.Dispatch.MessageDispatcherConfigurator configurator, string id, int throughput, System.Nullable<long> throughputDeadlineTime, Akka.Dispatch.ExecutorServiceFactory executorServiceFactory, System.TimeSpan shutdownTimeout) { }
    }
    public class RejectedExecutionException : Akka.Actor.AkkaException
    {
        public RejectedExecutionException(string message = null, System.Exception inner = null) { }
    }
    public class ThreadPoolConfig
    {
        public ThreadPoolConfig(Akka.Configuration.Config config) { }
        public double PoolSizeFactor { get; }
        public int PoolSizeMax { get; }
        public int PoolSizeMin { get; }
        public static int ScaledPoolSize(int floor, double scalar, int ceiling) { }
    }
    public sealed class UnboundedDequeBasedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue>
    {
        public UnboundedDequeBasedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public sealed class UnboundedMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedMessageQueue>
    {
        public UnboundedMailbox() { }
        public UnboundedMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public override Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public abstract class UnboundedPriorityMailbox : Akka.Dispatch.MailboxType, Akka.Dispatch.IProducesMessageQueue<Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue>
    {
        public const int DefaultCapacity = 11;
        protected UnboundedPriorityMailbox(Akka.Actor.Settings settings, Akka.Configuration.Config config) { }
        public int InitialCapacity { get; }
        public virtual Akka.Dispatch.MessageQueues.IMessageQueue Create(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
        protected abstract int PriorityGenerator(object message);
    }
}
namespace Akka.Dispatch.MessageQueues
{
    public abstract class BlockingMessageQueue : Akka.Dispatch.IBlockingMessageQueueSemantics, Akka.Dispatch.IMultipleConsumerSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        protected BlockingMessageQueue() { }
        public System.TimeSpan BlockTimeOut { get; set; }
        public int Count { get; }
        public bool HasMessages { get; }
        protected abstract int LockedCount { get; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        protected abstract void LockedEnqueue(Akka.Actor.Envelope envelope);
        protected abstract bool LockedTryDequeue(out Akka.Actor.Envelope envelope);
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class BoundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics
    {
        public BoundedDequeMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }
        public System.TimeSpan PushTimeOut { get; }
    }
    public class BoundedMessageQueue : Akka.Dispatch.IBoundedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        public BoundedMessageQueue(Akka.Configuration.Config config) { }
        public BoundedMessageQueue(int boundedCapacity, System.TimeSpan pushTimeOut) { }
        public int Count { get; }
        public bool HasMessages { get; }
        public System.TimeSpan PushTimeOut { get; set; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class DequeWrapperMessageQueue : Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        protected readonly Akka.Dispatch.MessageQueues.IMessageQueue MessageQueue;
        public DequeWrapperMessageQueue(Akka.Dispatch.MessageQueues.IMessageQueue messageQueue) { }
        public int Count { get; }
        public bool HasMessages { get; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        public void EnqueueFirst(Akka.Actor.Envelope envelope) { }
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public interface IMessageQueue
    {
        int Count { get; }
        bool HasMessages { get; }
        void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters);
        void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope);
        bool TryDequeue(out Akka.Actor.Envelope envelope);
    }
    public class UnboundedDequeMessageQueue : Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue, Akka.Dispatch.IDequeBasedMessageQueueSemantics, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics
    {
        public UnboundedDequeMessageQueue() { }
    }
    public class UnboundedMessageQueue : Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue
    {
        public UnboundedMessageQueue() { }
        public int Count { get; }
        public bool HasMessages { get; }
        public void CleanUp(Akka.Actor.IActorRef owner, Akka.Dispatch.MessageQueues.IMessageQueue deadletters) { }
        public void Enqueue(Akka.Actor.IActorRef receiver, Akka.Actor.Envelope envelope) { }
        public bool TryDequeue(out Akka.Actor.Envelope envelope) { }
    }
    public class UnboundedPriorityMessageQueue : Akka.Dispatch.MessageQueues.BlockingMessageQueue
    {
        [System.ObsoleteAttribute("Use UnboundedPriorityMessageQueue(Func<object, int> priorityGenerator, int initia" +
            "lCapacity) instead.")]
        public UnboundedPriorityMessageQueue(int initialCapacity) { }
        public UnboundedPriorityMessageQueue(System.Func<object, int> priorityGenerator, int initialCapacity) { }
        protected override int LockedCount { get; }
        protected override void LockedEnqueue(Akka.Actor.Envelope envelope) { }
        protected override bool LockedTryDequeue(out Akka.Actor.Envelope envelope) { }
    }
}
namespace Akka.Dispatch.SysMsg
{
    public sealed class ActorTask : Akka.Dispatch.SysMsg.SystemMessage
    {
        public ActorTask(System.Threading.Tasks.Task task) { }
        public System.Threading.Tasks.Task Task { get; }
    }
    public sealed class Create : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Create(Akka.Actor.ActorInitializationException failure = null) { }
        public Akka.Actor.ActorInitializationException Failure { get; }
        public override string ToString() { }
    }
    public sealed class DeathWatchNotification : Akka.Dispatch.SysMsg.SystemMessage, Akka.Event.IDeadLetterSuppression
    {
        public DeathWatchNotification(Akka.Actor.IActorRef actor, bool existenceConfirmed, bool addressTerminated) { }
        public Akka.Actor.IActorRef Actor { get; }
        public bool AddressTerminated { get; }
        public bool ExistenceConfirmed { get; }
        public override string ToString() { }
    }
    public sealed class Escalate : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Escalate(System.Exception reason) { }
        public System.Exception Reason { get; }
        public override string ToString() { }
    }
    public sealed class Failed : Akka.Dispatch.SysMsg.SystemMessage, Akka.Dispatch.SysMsg.IStashWhenFailed
    {
        public Failed(Akka.Actor.IActorRef child, System.Exception cause, long uid) { }
        public System.Exception Cause { get; }
        public Akka.Actor.IActorRef Child { get; }
        public long Uid { get; }
        public override string ToString() { }
    }
    public interface ISystemMessage : Akka.Actor.INoSerializationVerificationNeeded { }
    public sealed class NoMessage : Akka.Dispatch.SysMsg.SystemMessage
    {
        public NoMessage() { }
        public override string ToString() { }
    }
    public sealed class Recreate : Akka.Dispatch.SysMsg.SystemMessage, Akka.Dispatch.SysMsg.IStashWhenWaitingForChildren
    {
        public Recreate(System.Exception cause) { }
        public System.Exception Cause { get; }
        public override string ToString() { }
    }
    public sealed class RegisterTerminationHook
    {
        public static Akka.Dispatch.SysMsg.RegisterTerminationHook Instance { get; }
        public override string ToString() { }
    }
    public sealed class Resume : Akka.Dispatch.SysMsg.SystemMessage, Akka.Dispatch.SysMsg.IStashWhenWaitingForChildren
    {
        public Resume(System.Exception causedByFailure) { }
        public System.Exception CausedByFailure { get; set; }
        public override string ToString() { }
    }
    public sealed class Stop : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Stop() { }
        public override string ToString() { }
    }
    public sealed class StopChild
    {
        public StopChild(Akka.Actor.IActorRef child) { }
        public Akka.Actor.IActorRef Child { get; }
        public override string ToString() { }
    }
    public sealed class Supervise : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Supervise(Akka.Actor.IActorRef child, bool async) { }
        public bool Async { get; }
        public Akka.Actor.IActorRef Child { get; }
        public override string ToString() { }
    }
    public sealed class Suspend : Akka.Dispatch.SysMsg.SystemMessage, Akka.Dispatch.SysMsg.IStashWhenWaitingForChildren
    {
        public Suspend() { }
        public override string ToString() { }
    }
    public abstract class SystemMessage : Akka.Actor.INoSerializationVerificationNeeded, Akka.Dispatch.SysMsg.ISystemMessage
    {
        protected SystemMessage() { }
        public bool Unlinked { get; }
        public void Unlink() { }
    }
    public sealed class Terminate : Akka.Dispatch.SysMsg.SystemMessage, Akka.Actor.IPossiblyHarmful, Akka.Event.IDeadLetterSuppression
    {
        public Terminate() { }
        public override string ToString() { }
    }
    public sealed class TerminationHook
    {
        public static Akka.Dispatch.SysMsg.TerminationHook Instance { get; }
        public override string ToString() { }
    }
    public sealed class TerminationHookDone
    {
        public static Akka.Dispatch.SysMsg.TerminationHookDone Instance { get; }
        public override string ToString() { }
    }
    public sealed class Unwatch : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Unwatch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        public Akka.Actor.IInternalActorRef Watchee { get; }
        public Akka.Actor.IInternalActorRef Watcher { get; }
        public override string ToString() { }
    }
    public class Watch : Akka.Dispatch.SysMsg.SystemMessage
    {
        public Watch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        public Akka.Actor.IInternalActorRef Watchee { get; }
        public Akka.Actor.IInternalActorRef Watcher { get; }
        public override string ToString() { }
    }
}
namespace Akka.Event
{
    public abstract class ActorEventBus<TEvent, TClassifier> : Akka.Event.EventBus<TEvent, TClassifier, Akka.Actor.IActorRef>
    {
        protected ActorEventBus() { }
    }
    public abstract class AllDeadLetters
    {
        protected AllDeadLetters(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
        public object Message { get; }
        public Akka.Actor.IActorRef Recipient { get; }
        public Akka.Actor.IActorRef Sender { get; }
        public override string ToString() { }
    }
    public class BusLogging : Akka.Event.LoggingAdapterBase
    {
        public BusLogging(Akka.Event.LoggingBus bus, string logSource, System.Type logClass, Akka.Event.ILogMessageFormatter logMessageFormatter) { }
        public override bool IsDebugEnabled { get; }
        public override bool IsErrorEnabled { get; }
        public override bool IsInfoEnabled { get; }
        public override bool IsWarningEnabled { get; }
        protected override void NotifyDebug(object message) { }
        protected override void NotifyError(object message) { }
        protected override void NotifyError(System.Exception cause, object message) { }
        protected override void NotifyInfo(object message) { }
        protected override void NotifyWarning(object message) { }
    }
    public sealed class DeadLetter : Akka.Event.AllDeadLetters
    {
        public DeadLetter(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
    }
    public class DeadLetterListener : Akka.Actor.ActorBase
    {
        public DeadLetterListener() { }
        protected override void PostRestart(System.Exception reason) { }
        protected override void PostStop() { }
        protected override void PreStart() { }
        protected override bool Receive(object message) { }
    }
    public class Debug : Akka.Event.LogEvent
    {
        public Debug(string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public class DefaultLogger : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Event.ILoggerMessageQueueSemantics>
    {
        public DefaultLogger() { }
        protected virtual void Print(Akka.Event.LogEvent logEvent) { }
        protected override bool Receive(object message) { }
    }
    public class DefaultLogMessageFormatter : Akka.Event.ILogMessageFormatter
    {
        public DefaultLogMessageFormatter() { }
        public string Format(string format, params object[] args) { }
    }
    public class DummyClassForStringSources
    {
        public DummyClassForStringSources() { }
    }
    public class Error : Akka.Event.LogEvent
    {
        public Error(System.Exception cause, string logSource, System.Type logClass, object message) { }
        public System.Exception Cause { get; }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
    public abstract class EventBus<TEvent, TClassifier, TSubscriber>
    {
        protected EventBus() { }
        protected abstract bool Classify(TEvent @event, TClassifier classifier);
        protected abstract TClassifier GetClassifier(TEvent @event);
        protected abstract bool IsSubClassification(TClassifier parent, TClassifier child);
        protected abstract void Publish(TEvent @event, TSubscriber subscriber);
        public virtual void Publish(TEvent @event) { }
        protected string SimpleName(object source) { }
        protected string SimpleName(System.Type source) { }
        public virtual bool Subscribe(TSubscriber subscriber, TClassifier classifier) { }
        public virtual bool Unsubscribe(TSubscriber subscriber) { }
        public virtual bool Unsubscribe(TSubscriber subscriber, TClassifier classifier) { }
    }
    public class EventStream : Akka.Event.LoggingBus
    {
        public EventStream(bool debug) { }
        public bool InitUnsubscriber(Akka.Actor.IActorRef unsubscriber, Akka.Actor.ActorSystem system) { }
        public void StartUnsubscriber(Akka.Actor.Internal.ActorSystemImpl system) { }
        public override bool Subscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }
        public override bool Unsubscribe(Akka.Actor.IActorRef subscriber, System.Type channel) { }
        public override bool Unsubscribe(Akka.Actor.IActorRef subscriber) { }
    }
    public class static EventStreamExtensions
    {
        public static bool Subscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }
        public static bool Unsubscribe<TChannel>(this Akka.Event.EventStream eventStream, Akka.Actor.IActorRef subscriber) { }
    }
    public interface IDeadLetterSuppression { }
    public interface ILoggerMessageQueueSemantics : Akka.Dispatch.ISemantics { }
    public interface ILoggingAdapter
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarningEnabled { get; }
        void Debug(string format, params object[] args);
        void Error(string format, params object[] args);
        void Error(System.Exception cause, string format, params object[] args);
        void Info(string format, params object[] args);
        bool IsEnabled(Akka.Event.LogLevel logLevel);
        void Log(Akka.Event.LogLevel logLevel, string format, params object[] args);
        [System.ObsoleteAttribute("Use Warning instead!")]
        void Warn(string format, params object[] args);
        void Warning(string format, params object[] args);
    }
    public interface ILogMessageFormatter
    {
        string Format(string format, params object[] args);
    }
    public class Info : Akka.Event.LogEvent
    {
        public Info(string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public class InitializeLogger : Akka.Actor.INoSerializationVerificationNeeded
    {
        public InitializeLogger(Akka.Event.LoggingBus loggingBus) { }
        public Akka.Event.LoggingBus LoggingBus { get; }
    }
    public abstract class LogEvent : Akka.Actor.INoSerializationVerificationNeeded
    {
        protected LogEvent() { }
        public System.Type LogClass { get; set; }
        public string LogSource { get; set; }
        public object Message { get; set; }
        public System.Threading.Thread Thread { get; }
        public System.DateTime Timestamp { get; }
        public abstract Akka.Event.LogLevel LogLevel();
        public override string ToString() { }
    }
    public class LoggerInitialized : Akka.Actor.INoSerializationVerificationNeeded
    {
        public LoggerInitialized() { }
    }
    public class LoggerMailbox : Akka.Dispatch.Mailbox, Akka.Dispatch.ISemantics, Akka.Dispatch.IUnboundedMessageQueueSemantics, Akka.Dispatch.MessageQueues.IMessageQueue, Akka.Event.ILoggerMessageQueueSemantics
    {
        public LoggerMailbox(Akka.Actor.IActorRef owner, Akka.Actor.ActorSystem system) { }
    }
    public class static Logging
    {
        public static readonly Akka.Event.StandardOutLogger StandardOutLogger;
        public static System.Type ClassFor(this Akka.Event.LogLevel logLevel) { }
        public static Akka.Event.ILoggingAdapter GetLogger(this Akka.Actor.IActorContext context, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }
        public static Akka.Event.ILoggingAdapter GetLogger(Akka.Actor.ActorSystem system, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }
        public static Akka.Event.ILoggingAdapter GetLogger(Akka.Event.LoggingBus loggingBus, object logSourceObj, Akka.Event.ILogMessageFormatter logMessageFormatter = null) { }
        public static Akka.Event.LogLevel LogLevelFor(string logLevel) { }
        public static Akka.Event.LogLevel LogLevelFor<T>()
            where T : Akka.Event.LogEvent { }
        public static string StringFor(this Akka.Event.LogLevel logLevel) { }
    }
    public abstract class LoggingAdapterBase : Akka.Event.ILoggingAdapter
    {
        protected LoggingAdapterBase(Akka.Event.ILogMessageFormatter logMessageFormatter) { }
        public abstract bool IsDebugEnabled { get; }
        public abstract bool IsErrorEnabled { get; }
        public abstract bool IsInfoEnabled { get; }
        public abstract bool IsWarningEnabled { get; }
        public void Debug(string format, params object[] args) { }
        public void Error(System.Exception cause, string format, params object[] args) { }
        public void Error(string format, params object[] args) { }
        public void Info(string format, params object[] args) { }
        public bool IsEnabled(Akka.Event.LogLevel logLevel) { }
        public void Log(Akka.Event.LogLevel logLevel, string format, params object[] args) { }
        protected abstract void NotifyDebug(object message);
        protected abstract void NotifyError(object message);
        protected abstract void NotifyError(System.Exception cause, object message);
        protected abstract void NotifyInfo(object message);
        protected void NotifyLog(Akka.Event.LogLevel logLevel, object message) { }
        protected abstract void NotifyWarning(object message);
        public void Warn(string format, params object[] args) { }
        public void Warning(string format, params object[] args) { }
    }
    public class LoggingBus : Akka.Event.ActorEventBus<object, System.Type>
    {
        public LoggingBus() { }
        public Akka.Event.LogLevel LogLevel { get; }
        protected override bool Classify(object @event, System.Type classifier) { }
        protected override System.Type GetClassifier(object @event) { }
        protected override bool IsSubClassification(System.Type parent, System.Type child) { }
        protected override void Publish(object @event, Akka.Actor.IActorRef subscriber) { }
        public void SetLogLevel(Akka.Event.LogLevel logLevel) { }
        public void StartStdoutLogger(Akka.Actor.Settings config) { }
    }
    public enum LogLevel
    {
        DebugLevel = 0,
        InfoLevel = 1,
        WarningLevel = 2,
        ErrorLevel = 3,
    }
    public class LogMessage
    {
        public LogMessage(Akka.Event.ILogMessageFormatter formatter, string format, params object[] args) { }
        public object[] Args { get; }
        public string Format { get; }
        public override string ToString() { }
    }
    public sealed class NoLogger : Akka.Event.ILoggingAdapter
    {
        public static readonly Akka.Event.ILoggingAdapter Instance;
        public bool IsDebugEnabled { get; }
        public bool IsErrorEnabled { get; }
        public bool IsInfoEnabled { get; }
        public bool IsWarningEnabled { get; }
        public void Debug(string format, params object[] args) { }
        public void Error(string format, params object[] args) { }
        public void Error(System.Exception cause, string format, params object[] args) { }
        public void Info(string format, params object[] args) { }
        public bool IsEnabled(Akka.Event.LogLevel logLevel) { }
        public void Log(Akka.Event.LogLevel logLevel, string format, params object[] args) { }
        public void Warn(string format, params object[] args) { }
        public void Warning(string format, params object[] args) { }
    }
    public class StandardOutLogger : Akka.Actor.MinimalActorRef
    {
        public StandardOutLogger() { }
        public static System.ConsoleColor DebugColor { get; set; }
        public static System.ConsoleColor ErrorColor { get; set; }
        public static System.ConsoleColor InfoColor { get; set; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public static bool UseColors { get; set; }
        public static System.ConsoleColor WarningColor { get; set; }
        public static void PrintLogEvent(Akka.Event.LogEvent logEvent) { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    public class Subscription<TSubscriber, TClassifier>
    {
        public Subscription(TSubscriber subscriber, System.Collections.Generic.IEnumerable<TClassifier> unsubscriptions) { }
        public Subscription(TSubscriber subscriber) { }
        public TSubscriber Subscriber { get; }
        public System.Collections.Generic.ISet<TClassifier> Unsubscriptions { get; }
    }
    public sealed class SuppressedDeadLetter : Akka.Event.AllDeadLetters
    {
        public SuppressedDeadLetter(Akka.Event.IDeadLetterSuppression message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
    }
    public class TraceLogger : Akka.Actor.UntypedActor
    {
        public TraceLogger() { }
        protected override void OnReceive(object message) { }
    }
    public sealed class UnhandledMessage
    {
        public UnhandledMessage(object message, Akka.Actor.IActorRef sender, Akka.Actor.IActorRef recipient) { }
        public object Message { get; }
        public Akka.Actor.IActorRef Recipient { get; }
        public Akka.Actor.IActorRef Sender { get; }
    }
    public class Warning : Akka.Event.LogEvent
    {
        public Warning(string logSource, System.Type logClass, object message) { }
        public override Akka.Event.LogLevel LogLevel() { }
    }
}
namespace Akka.IO
{
    public class ByteBuffer
    {
        public ByteBuffer(byte[] array) { }
        public ByteBuffer(byte[] array, int offset, int length) { }
        public bool HasRemaining { get; }
        public int Remaining { get; }
        public static Akka.IO.ByteBuffer Allocate(int capacity) { }
        public byte[] Array() { }
        public void Clear() { }
        public void Flip() { }
        public void Get(byte[] ar, int offset, int length) { }
        public void Get(byte[] ar) { }
        public void Limit(int maxBufferSize) { }
        public void Order(Akka.IO.ByteOrder byteOrder) { }
        public void Put(byte[] src) { }
        public void Put(byte[] array, int from, int copyLength) { }
        public void Put(Akka.IO.ByteBuffer src, int length) { }
        public static Akka.IO.ByteBuffer Wrap(byte[] array, int start, int len) { }
        public static Akka.IO.ByteBuffer Wrap(byte[] array) { }
    }
    public enum ByteOrder
    {
        BigEndian = 0,
        LittleEndian = 1,
    }
    public abstract class ByteString : System.Collections.Generic.IEnumerable<byte>, System.Collections.Generic.IReadOnlyCollection<byte>, System.Collections.Generic.IReadOnlyList<byte>, System.Collections.IEnumerable, System.IEquatable<Akka.IO.ByteString>
    {
        public static readonly Akka.IO.ByteString Empty;
        protected ByteString() { }
        public abstract int Count { get; }
        public byte Head { get; }
        public virtual bool IsEmpty { get; }
        public abstract byte this[int index] { get; }
        public byte Last { get; }
        public bool NonEmpty { get; }
        public abstract Akka.IO.ByteBuffer AsByteBuffer();
        public abstract Akka.IO.CompactByteString Compact();
        public abstract Akka.IO.ByteString Concat(Akka.IO.ByteString that);
        public int CopyToBuffer(Akka.IO.ByteBuffer buffer) { }
        public static Akka.IO.ByteString Create(Akka.IO.ByteBuffer buffer) { }
        public static Akka.IO.ByteString Create(byte[] buffer, int offset, int length) { }
        public static Akka.IO.ByteString Create(byte[] buffer) { }
        public string DecodeString() { }
        public abstract string DecodeString(System.Text.Encoding charset);
        public Akka.IO.ByteString Drop(int n) { }
        public Akka.IO.ByteString DropRight(int n) { }
        public Akka.IO.ByteString DropWhile(System.Func<byte, bool> p) { }
        public bool Equals(Akka.IO.ByteString other) { }
        public override bool Equals(object obj) { }
        public Akka.IO.ByteString FromArray(byte[] array) { }
        public Akka.IO.ByteString FromArray(byte[] array, int offset, int length) { }
        public static Akka.IO.ByteString FromByteBuffer(Akka.IO.ByteBuffer buffer) { }
        public static Akka.IO.ByteString FromString(string str) { }
        public static Akka.IO.ByteString FromString(string str, System.Text.Encoding encoding) { }
        public virtual System.Collections.Generic.IEnumerator<byte> GetEnumerator() { }
        public int IndexOf(byte elem) { }
        public int IndexWhere(System.Func<byte, bool> p) { }
        public Akka.IO.ByteString Init() { }
        public abstract bool IsCompact();
        public abstract Akka.Util.ByteIterator Iterator();
        protected virtual Akka.IO.ByteStringBuilder newBuilder() { }
        public static Akka.IO.ByteStringBuilder NewBuilder() { }
        public virtual Akka.IO.ByteString Slice(int from, int until) { }
        public System.Tuple<Akka.IO.ByteString, Akka.IO.ByteString> Span(System.Func<byte, bool> p) { }
        public System.Tuple<Akka.IO.ByteString, Akka.IO.ByteString> SplitAt(int n) { }
        public Akka.IO.ByteString Tail() { }
        public Akka.IO.ByteString Take(int n) { }
        public Akka.IO.ByteString TakeRight(int n) { }
        public Akka.IO.ByteString TakeWhile(System.Func<byte, bool> p) { }
        public byte[] ToArray() { }
    }
    public class ByteStringBuilder
    {
        public ByteStringBuilder() { }
        public int Length { get; }
        public Akka.IO.ByteStringBuilder Append(System.Collections.Generic.IEnumerable<byte> xs) { }
        protected System.Func<System.Action<byte[], int>, Akka.IO.ByteStringBuilder> FillArray(int len) { }
        protected Akka.IO.ByteStringBuilder FillByteBuffer(int len, Akka.IO.ByteOrder byteOrder, System.Action<Akka.IO.ByteBuffer> fill) { }
        public Akka.IO.ByteStringBuilder PutByte(byte x) { }
        public Akka.IO.ByteStringBuilder PutBytes(byte[] array) { }
        public Akka.IO.ByteStringBuilder PutBytes(byte[] array, int start, int len) { }
        public Akka.IO.ByteStringBuilder PutInt(int x, Akka.IO.ByteOrder byteOrder) { }
        public Akka.IO.ByteStringBuilder PutShort(int x, Akka.IO.ByteOrder byteOrder) { }
        public Akka.IO.ByteString Result() { }
        public void SizeHint(int len) { }
    }
    public abstract class CompactByteString : Akka.IO.ByteString
    {
        protected CompactByteString() { }
        public override Akka.IO.CompactByteString Compact() { }
        public new static Akka.IO.ByteString FromArray(byte[] array, int offset, int length) { }
        public static Akka.IO.CompactByteString FromString(string str, System.Text.Encoding encoding) { }
        public override bool IsCompact() { }
    }
    public class DatagramChannel : Akka.IO.SocketChannel
    {
        public override bool IsOpen() { }
        public static Akka.IO.DatagramChannel Open() { }
        public System.Net.EndPoint Receive(Akka.IO.ByteBuffer buffer) { }
        public int Send(Akka.IO.ByteBuffer buffer, System.Net.EndPoint target) { }
    }
    public class Dns : Akka.Actor.ExtensionIdProvider<Akka.IO.DnsExt>
    {
        public static readonly Akka.IO.Dns Instance;
        public Dns() { }
        public static Akka.IO.Dns.Resolved Cached(string name, Akka.Actor.ActorSystem system) { }
        public override Akka.IO.DnsExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.IO.Dns.Resolved ResolveName(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }
        public abstract class Command
        {
            protected Command() { }
        }
        public class Resolve : Akka.IO.Dns.Command, Akka.Routing.IConsistentHashable
        {
            public Resolve(string name) { }
            public object ConsistentHashKey { get; }
            public string Name { get; }
        }
        public class Resolved : Akka.IO.Dns.Command
        {
            public Resolved(string name, System.Collections.Generic.IEnumerable<System.Net.IPAddress> ipv4, System.Collections.Generic.IEnumerable<System.Net.IPAddress> ipv6) { }
            public System.Net.IPAddress Addr { get; }
            public System.Collections.Generic.IEnumerable<System.Net.IPAddress> Ipv4 { get; }
            public System.Collections.Generic.IEnumerable<System.Net.IPAddress> Ipv6 { get; }
            public string Name { get; }
            public static Akka.IO.Dns.Resolved Create(string name, System.Collections.Generic.IEnumerable<System.Net.IPAddress> addresses) { }
        }
    }
    public abstract class DnsBase
    {
        protected DnsBase() { }
        public virtual Akka.IO.Dns.Resolved Cached(string name) { }
        public virtual Akka.IO.Dns.Resolved Resolve(string name, Akka.Actor.ActorSystem system, Akka.Actor.IActorRef sender) { }
    }
    public class DnsExt : Akka.IO.IOExtension
    {
        public DnsExt(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.IO.DnsBase Cache { get; }
        public override Akka.Actor.IActorRef Manager { get; }
        public Akka.IO.IDnsProvider Provider { get; }
        public Akka.IO.DnsExt.DnsSettings Settings { get; }
        public Akka.Actor.IActorRef GetResolver() { }
        public class DnsSettings
        {
            public DnsSettings(Akka.Configuration.Config config) { }
            public string Dispatcher { get; }
            public string ProviderObjectName { get; }
            public string Resolver { get; }
            public Akka.Configuration.Config ResolverConfig { get; }
        }
    }
    public interface IBufferPool
    {
        Akka.IO.ByteBuffer Acquire();
        void Release(Akka.IO.ByteBuffer buf);
    }
    public interface IDnsProvider
    {
        System.Type ActorClass { get; }
        Akka.IO.DnsBase Cache { get; }
        System.Type ManagerClass { get; }
    }
    public class Inet
    {
        public Inet() { }
        public abstract class AbstractSocketOption : Akka.IO.Inet.SocketOption
        {
            protected AbstractSocketOption() { }
        }
        public abstract class AbstractSocketOptionV2 : Akka.IO.Inet.SocketOptionV2
        {
            protected AbstractSocketOptionV2() { }
        }
        public class DatagramChannelCreator : Akka.IO.Inet.SocketOption
        {
            public DatagramChannelCreator() { }
            public virtual Akka.IO.DatagramChannel Create() { }
        }
        public class static SO
        {
            public class ReceiveBufferSize : Akka.IO.Inet.SocketOption
            {
                public ReceiveBufferSize(int size) { }
                public override void BeforeConnect(System.Net.Sockets.Socket s) { }
                public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }
                public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }
            }
            public class ReuseAddress : Akka.IO.Inet.SocketOption
            {
                public ReuseAddress(bool on) { }
                public override void BeforeConnect(System.Net.Sockets.Socket s) { }
                public override void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }
                public override void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }
            }
            public class SendBufferSize : Akka.IO.Inet.SocketOption
            {
                public SendBufferSize(int size) { }
                public override void AfterConnect(System.Net.Sockets.Socket s) { }
            }
            public class TrafficClass : Akka.IO.Inet.SocketOption
            {
                public TrafficClass(int tc) { }
                public override void AfterConnect(System.Net.Sockets.Socket s) { }
            }
        }
        public abstract class SocketOption
        {
            protected SocketOption() { }
            public virtual void AfterConnect(System.Net.Sockets.Socket s) { }
            public virtual void BeforeConnect(System.Net.Sockets.Socket s) { }
            public virtual void BeforeDatagramBind(System.Net.Sockets.Socket ds) { }
            public virtual void BeforeServerSocketBind(System.Net.Sockets.Socket ss) { }
        }
        public abstract class SocketOptionV2 : Akka.IO.Inet.SocketOption
        {
            protected SocketOptionV2() { }
            public virtual void AfterBind(System.Net.Sockets.Socket s) { }
        }
        public abstract class SoForwarders
        {
            protected SoForwarders() { }
        }
    }
    public class InetAddressDnsProvider : Akka.IO.IDnsProvider
    {
        public InetAddressDnsProvider() { }
        public System.Type ActorClass { get; }
        public Akka.IO.DnsBase Cache { get; }
        public System.Type ManagerClass { get; }
    }
    public class InetAddressDnsResolver : Akka.Actor.ActorBase
    {
        public InetAddressDnsResolver(Akka.IO.SimpleDnsCache cache, Akka.Configuration.Config config) { }
        protected override bool Receive(object message) { }
    }
    public abstract class IOExtension : Akka.Actor.IExtension
    {
        protected IOExtension() { }
        public abstract Akka.Actor.IActorRef Manager { get; }
    }
    public abstract class SelectionHandlerSettings
    {
        protected SelectionHandlerSettings(Akka.Configuration.Config config) { }
        public int MaxChannels { get; }
        public int MaxChannelsPerSelector { get; set; }
        public int SelectorAssociationRetries { get; }
        public string SelectorDispatcher { get; }
        public bool TraceLogging { get; }
        public string WorkerDispatcher { get; }
    }
    public class SimpleDnsCache : Akka.IO.DnsBase, Akka.IO.IPeriodicCacheCleanup
    {
        public SimpleDnsCache() { }
        public override Akka.IO.Dns.Resolved Cached(string name) { }
        public void CleanUp() { }
        protected virtual long Clock() { }
    }
    public class SimpleDnsManager : Akka.Actor.ActorBase, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        public SimpleDnsManager(Akka.IO.DnsExt ext) { }
        protected override void PostStop() { }
        protected override bool Receive(object message) { }
    }
    public class SocketAsyncEventArgsPool
    {
        public SocketAsyncEventArgsPool(int capacity, System.Action<System.Net.Sockets.SocketAsyncEventArgs> select) { }
        public int BufferSize { get; }
        public System.Net.Sockets.SocketAsyncEventArgs Request(object token) { }
        public void Return(System.Net.Sockets.SocketAsyncEventArgs saea) { }
    }
    public class SocketChannel
    {
        public SocketChannel(System.Net.Sockets.Socket socket) { }
        public System.Net.Sockets.Socket Socket { get; }
        public Akka.IO.SocketChannel Accept() { }
        public void Close() { }
        public Akka.IO.SocketChannel ConfigureBlocking(bool block) { }
        public bool Connect(System.Net.EndPoint address) { }
        public bool FinishConnect() { }
        public virtual bool IsOpen() { }
        public static Akka.IO.SocketChannel Open() { }
        public int Read(Akka.IO.ByteBuffer buffer) { }
        public void Register(Akka.Actor.IActorRef connection, System.Nullable<System.Net.Sockets.SocketAsyncOperation> initialOps) { }
        public int Write(Akka.IO.ByteBuffer buffer) { }
    }
    public class Tcp : Akka.Actor.ExtensionIdProvider<Akka.IO.TcpExt>
    {
        public static readonly Akka.IO.Tcp Instance;
        public Tcp() { }
        public override Akka.IO.TcpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }
        public class Abort : Akka.IO.Tcp.CloseCommand
        {
            public static readonly Akka.IO.Tcp.Abort Instance;
            public override Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public class Aborted : Akka.IO.Tcp.ConnectionClosed
        {
            public static Akka.IO.Tcp.Aborted Instance;
            public override bool IsAborted { get; }
        }
        public class Bind : Akka.IO.Tcp.Command
        {
            public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, int backlog = 100, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, bool pullMode = False) { }
            public int Backlog { get; set; }
            public Akka.Actor.IActorRef Handler { get; set; }
            public System.Net.EndPoint LocalAddress { get; set; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; set; }
            public bool PullMode { get; set; }
        }
        public class Bound : Akka.IO.Tcp.Event
        {
            public Bound(System.Net.EndPoint localAddress) { }
            public System.Net.EndPoint LocalAddress { get; }
        }
        public class Close : Akka.IO.Tcp.CloseCommand
        {
            public static readonly Akka.IO.Tcp.Close Instance;
            public override Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public abstract class CloseCommand : Akka.IO.Tcp.Command, Akka.Event.IDeadLetterSuppression
        {
            protected CloseCommand() { }
            public abstract Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public class Closed : Akka.IO.Tcp.ConnectionClosed
        {
            public static readonly Akka.IO.Tcp.Closed Instance;
        }
        public class Command : Akka.IO.Tcp.Message, Akka.IO.SelectionHandler.IHasFailureMessage
        {
            public Command() { }
            public Akka.IO.Tcp.CommandFailed FailureMessage { get; }
        }
        public sealed class CommandFailed : Akka.IO.Tcp.Event
        {
            public CommandFailed(Akka.IO.Tcp.Command cmd) { }
            public Akka.IO.Tcp.Command Cmd { get; }
        }
        public class CompoundWrite : Akka.IO.Tcp.WriteCommand, System.Collections.Generic.IEnumerable<Akka.IO.Tcp.SimpleWriteCommand>, System.Collections.IEnumerable
        {
            public CompoundWrite(Akka.IO.Tcp.SimpleWriteCommand head, Akka.IO.Tcp.WriteCommand tailCommand) { }
            public Akka.IO.Tcp.SimpleWriteCommand Head { get; }
            public Akka.IO.Tcp.WriteCommand TailCommand { get; }
            public System.Collections.Generic.IEnumerator<Akka.IO.Tcp.SimpleWriteCommand> GetEnumerator() { }
        }
        public class ConfirmedClose : Akka.IO.Tcp.CloseCommand
        {
            public static readonly Akka.IO.Tcp.ConfirmedClose Instance;
            public override Akka.IO.Tcp.ConnectionClosed Event { get; }
        }
        public class ConfirmedClosed : Akka.IO.Tcp.ConnectionClosed
        {
            public static Akka.IO.Tcp.ConfirmedClosed Instance;
            public override bool IsConfirmed { get; }
        }
        public class Connect : Akka.IO.Tcp.Command
        {
            public Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null, System.Nullable<System.TimeSpan> timeout = null, bool pullMode = False) { }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
            public bool PullMode { get; }
            public System.Net.EndPoint RemoteAddress { get; }
            public System.Nullable<System.TimeSpan> Timeout { get; }
        }
        public sealed class Connected : Akka.IO.Tcp.Event
        {
            public Connected(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress) { }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Net.EndPoint RemoteAddress { get; }
        }
        public class ConnectionClosed : Akka.IO.Tcp.Event, Akka.Event.IDeadLetterSuppression
        {
            public ConnectionClosed() { }
            public virtual bool IsAborted { get; }
            public virtual bool IsConfirmed { get; }
            public virtual bool IsErrorClosed { get; }
            public virtual bool IsPeerClosed { get; }
            public virtual string GetErrorCause() { }
        }
        public class ErrorClosed : Akka.IO.Tcp.ConnectionClosed
        {
            public ErrorClosed(string cause) { }
            public override bool IsErrorClosed { get; }
            public override string GetErrorCause() { }
        }
        public class Event : Akka.IO.Tcp.Message
        {
            public Event() { }
        }
        public class Message : Akka.Actor.INoSerializationVerificationNeeded
        {
            public Message() { }
        }
        public class NoAck : Akka.IO.Tcp.Event
        {
            public static readonly Akka.IO.Tcp.NoAck Instance;
            public NoAck(object token) { }
            public object Token { get; }
        }
        public class PeerClosed : Akka.IO.Tcp.ConnectionClosed
        {
            public static Akka.IO.Tcp.PeerClosed Instance;
            public override bool IsPeerClosed { get; }
        }
        public sealed class Received : Akka.IO.Tcp.Event
        {
            public Received(Akka.IO.ByteString data) { }
            public Akka.IO.ByteString Data { get; }
        }
        public class Register : Akka.IO.Tcp.Command
        {
            public Register(Akka.Actor.IActorRef handler, bool keepOpenonPeerClosed = False, bool useResumeWriting = True) { }
            public Akka.Actor.IActorRef Handler { get; }
            public bool KeepOpenonPeerClosed { get; }
            public bool UseResumeWriting { get; }
        }
        public class ResumeAccepting : Akka.IO.Tcp.Command
        {
            public ResumeAccepting(int batchSize) { }
            public int BatchSize { get; }
        }
        public class ResumeReading : Akka.IO.Tcp.Command
        {
            public static Akka.IO.Tcp.ResumeReading Instance;
        }
        public class ResumeWriting : Akka.IO.Tcp.Command
        {
            public static readonly Akka.IO.Tcp.ResumeWriting Instance;
            public ResumeWriting() { }
        }
        public abstract class SimpleWriteCommand : Akka.IO.Tcp.WriteCommand
        {
            protected SimpleWriteCommand() { }
            public abstract Akka.IO.Tcp.Event Ack { get; }
            public bool WantsAck { get; }
            public Akka.IO.Tcp.CompoundWrite Append(Akka.IO.Tcp.WriteCommand that) { }
        }
        public class SuspendReading : Akka.IO.Tcp.Command
        {
            public static Akka.IO.Tcp.SuspendReading Instance;
        }
        public class Unbind : Akka.IO.Tcp.Command
        {
            public static readonly Akka.IO.Tcp.Unbind Instance;
        }
        public class Unbound : Akka.IO.Tcp.Event
        {
            public static Akka.IO.Tcp.Unbound Instance;
            public Unbound() { }
        }
        public class Write : Akka.IO.Tcp.SimpleWriteCommand
        {
            public static readonly Akka.IO.Tcp.Write Empty;
            public override Akka.IO.Tcp.Event Ack { get; }
            public Akka.IO.ByteString Data { get; }
            public static Akka.IO.Tcp.Write Create(Akka.IO.ByteString data) { }
            public static Akka.IO.Tcp.Write Create(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack) { }
        }
        public abstract class WriteCommand : Akka.IO.Tcp.Command
        {
            protected WriteCommand() { }
            public static Akka.IO.Tcp.WriteCommand Create(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }
            public static Akka.IO.Tcp.WriteCommand Create(params WriteCommand[] writes) { }
            public Akka.IO.Tcp.CompoundWrite Prepend(Akka.IO.Tcp.SimpleWriteCommand other) { }
            public Akka.IO.Tcp.WriteCommand Prepend(System.Collections.Generic.IEnumerable<Akka.IO.Tcp.WriteCommand> writes) { }
        }
        public class WriteFile : Akka.IO.Tcp.SimpleWriteCommand
        {
            public WriteFile(string filePath, long position, long count, Akka.IO.Tcp.Event ack) { }
            public override Akka.IO.Tcp.Event Ack { get; }
            public long Count { get; }
            public string FilePath { get; }
            public long Position { get; }
        }
        public class WritingResumed : Akka.IO.Tcp.Event
        {
            public static Akka.IO.Tcp.WritingResumed Instance;
            public WritingResumed() { }
        }
    }
    public class TcpExt : Akka.IO.IOExtension
    {
        public TcpExt(Akka.Actor.ExtendedActorSystem system) { }
        public override Akka.Actor.IActorRef Manager { get; }
        public Akka.IO.TcpExt.TcpSettings Settings { get; }
        public Akka.Actor.IActorRef GetManager() { }
        public class TcpSettings : Akka.IO.SelectionHandlerSettings
        {
            public TcpSettings(Akka.Configuration.Config config) { }
            public int BatchAcceptLimit { get; }
            public int DirectBufferSize { get; }
            public string FileIODispatcher { get; }
            public int FinishConnectRetries { get; }
            public string ManagementDispatcher { get; }
            public int MaxDirectBufferPoolSize { get; }
            public int NrOfSelectors { get; }
            public int ReceivedMessageSizeLimit { get; }
            public System.Nullable<System.TimeSpan> RegisterTimeout { get; }
            public int TransferToLimit { get; set; }
        }
    }
    public class static TcpExtensions
    {
        public static Akka.Actor.IActorRef Tcp(this Akka.Actor.ActorSystem system) { }
    }
    public class TcpMessage
    {
        public TcpMessage() { }
        public static Akka.IO.Tcp.Command Abort() { }
        public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, bool pullMode) { }
        public static Akka.IO.Tcp.Command Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint endpoint, int backlog) { }
        public static Akka.IO.Tcp.Command Close() { }
        public static Akka.IO.Tcp.Command ConfirmedClose() { }
        public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options, System.Nullable<System.TimeSpan> timeout, bool pullMode) { }
        public static Akka.IO.Tcp.Command Connect(System.Net.EndPoint remoteAddress) { }
        public static Akka.IO.Tcp.NoAck NoAck(object token = null) { }
        public static Akka.IO.Tcp.Command Register(Akka.Actor.IActorRef handler, bool keepOpenOnPeerClosed = False, bool useResumeWriting = True) { }
        public static Akka.IO.Tcp.Command ResumeAccepting(int batchSize) { }
        public static Akka.IO.Tcp.Command ResumeReading() { }
        public static Akka.IO.Tcp.Command ResumeWriting() { }
        public static Akka.IO.Tcp.Command SuspendReading() { }
        public static Akka.IO.Tcp.Command Unbind() { }
        public static Akka.IO.Tcp.Command Write(Akka.IO.ByteString data, Akka.IO.Tcp.Event ack = null) { }
    }
    public class Udp : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpExt>
    {
        public static readonly Akka.IO.Udp Instance;
        public Udp() { }
        public override Akka.IO.UdpExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static Akka.Actor.IActorRef Manager(Akka.Actor.ActorSystem system) { }
        public sealed class Bind : Akka.IO.Udp.Command
        {
            public Bind(Akka.Actor.IActorRef handler, System.Net.EndPoint localAddress, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }
            public Akka.Actor.IActorRef Handler { get; }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
        }
        public sealed class Bound : Akka.IO.Udp.Event
        {
            public Bound(System.Net.EndPoint localAddress) { }
            public System.Net.EndPoint LocalAddress { get; }
        }
        public abstract class Command : Akka.IO.Udp.Message, Akka.IO.SelectionHandler.IHasFailureMessage
        {
            protected Command() { }
            public object FailureMessage { get; }
        }
        public sealed class CommandFailed : Akka.IO.Udp.Event
        {
            public CommandFailed(Akka.IO.Udp.Command cmd) { }
            public Akka.IO.Udp.Command Cmd { get; }
        }
        public abstract class Event : Akka.IO.Udp.Message
        {
            protected Event() { }
        }
        public abstract class Message
        {
            protected Message() { }
        }
        public class NoAck : Akka.IO.Udp.Event
        {
            public static readonly Akka.IO.Udp.NoAck Instance;
            public NoAck(object token) { }
            public object Token { get; }
        }
        public sealed class Received : Akka.IO.Udp.Event
        {
            public Received(Akka.IO.ByteString data, System.Net.EndPoint sender) { }
            public Akka.IO.ByteString Data { get; }
            public System.Net.EndPoint Sender { get; }
        }
        public class ResumeReading : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.ResumeReading Instance;
        }
        public sealed class Send : Akka.IO.Udp.Command
        {
            public Send(Akka.IO.ByteString payload, System.Net.EndPoint target, Akka.IO.Udp.Event ack) { }
            public Akka.IO.Udp.Event Ack { get; }
            public Akka.IO.ByteString Payload { get; }
            public System.Net.EndPoint Target { get; }
            public bool WantsAck { get; }
            public static Akka.IO.Udp.Send Create(Akka.IO.ByteString data, System.Net.EndPoint target) { }
        }
        public class SimpleSender : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.SimpleSender Instance;
            public SimpleSender(System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
        }
        public sealed class SimpleSenderReady : Akka.IO.Udp.Event
        {
            public static readonly Akka.IO.Udp.SimpleSenderReady Instance;
        }
        public class SO : Akka.IO.Inet.SoForwarders
        {
            public SO() { }
            public sealed class Broadcast : Akka.IO.Inet.SocketOption
            {
                public Broadcast(bool on) { }
                public bool On { get; }
                public override void BeforeDatagramBind(System.Net.Sockets.Socket s) { }
            }
        }
        public class SuspendReading : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.SuspendReading Instance;
        }
        public class Unbind : Akka.IO.Udp.Command
        {
            public static readonly Akka.IO.Udp.Unbind Instance;
        }
        public class Unbound
        {
            public static readonly Akka.IO.Udp.Unbound Instance;
        }
    }
    public class UdpConnected : Akka.Actor.ExtensionIdProvider<Akka.IO.UdpConnectedExt>
    {
        public static readonly Akka.IO.UdpConnected Instance;
        public UdpConnected() { }
        public override Akka.IO.UdpConnectedExt CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public abstract class Command : Akka.IO.UdpConnected.Message, Akka.IO.SelectionHandler.IHasFailureMessage
        {
            protected Command() { }
            public object FailureMessage { get; }
        }
        public sealed class CommandFailed : Akka.IO.UdpConnected.Event
        {
            public CommandFailed(Akka.IO.UdpConnected.Command cmd) { }
            public Akka.IO.UdpConnected.Command Cmd { get; }
        }
        public sealed class Connect : Akka.IO.UdpConnected.Command
        {
            public Connect(Akka.Actor.IActorRef handler, System.Net.EndPoint remoteAddress, System.Net.EndPoint localAddress = null, System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> options = null) { }
            public Akka.Actor.IActorRef Handler { get; }
            public System.Net.EndPoint LocalAddress { get; }
            public System.Collections.Generic.IEnumerable<Akka.IO.Inet.SocketOption> Options { get; }
            public System.Net.EndPoint RemoteAddress { get; }
        }
        public class Connected : Akka.IO.UdpConnected.Event
        {
            public static readonly Akka.IO.UdpConnected.Connected Instance;
        }
        public class Disconnect : Akka.IO.UdpConnected.Command
        {
            public static readonly Akka.IO.UdpConnected.Disconnect Instance;
        }
        public class Disconnected : Akka.IO.UdpConnected.Event
        {
            public static readonly Akka.IO.UdpConnected.Disconnected Instance;
        }
        public abstract class Event : Akka.IO.UdpConnected.Message
        {
            protected Event() { }
        }
        public abstract class Message
        {
            protected Message() { }
        }
        public class NoAck : Akka.IO.UdpConnected.Event
        {
            public static readonly Akka.IO.UdpConnected.NoAck Instance;
            public NoAck(object token) { }
            public object Token { get; }
        }
        public sealed class Received : Akka.IO.UdpConnected.Event
        {
            public Received(Akka.IO.ByteString data) { }
            public Akka.IO.ByteString Data { get; }
        }
        public class ResumeReading : Akka.IO.UdpConnected.Command
        {
            public static readonly Akka.IO.UdpConnected.ResumeReading Instance;
        }
        public sealed class Send : Akka.IO.UdpConnected.Command
        {
            public Send(Akka.IO.ByteString payload, object ack) { }
            public object Ack { get; }
            public Akka.IO.ByteString Payload { get; }
            public bool WantsAck { get; }
            public static Akka.IO.UdpConnected.Send Create(Akka.IO.ByteString data) { }
        }
        public class SuspendReading : Akka.IO.UdpConnected.Command
        {
            public static readonly Akka.IO.UdpConnected.SuspendReading Instance;
        }
    }
    public class UdpConnectedExt : Akka.IO.IOExtension
    {
        public UdpConnectedExt(Akka.Actor.ExtendedActorSystem system) { }
        public override Akka.Actor.IActorRef Manager { get; }
    }
    public class UdpExt : Akka.IO.IOExtension
    {
        public UdpExt(Akka.Actor.ExtendedActorSystem system) { }
        public override Akka.Actor.IActorRef Manager { get; }
    }
    public class static UdpExtensions
    {
        public static Akka.Actor.IActorRef Udp(this Akka.Actor.ActorSystem system) { }
    }
}
namespace Akka.Pattern
{
    public class BackoffSupervisor : Akka.Actor.UntypedActor
    {
        public BackoffSupervisor(Akka.Actor.Props childProps, string childName, System.TimeSpan minBackoff, System.TimeSpan maxBackoff, double randomFactor) { }
        protected override void OnReceive(object message) { }
        protected override void PreStart() { }
        public sealed class CurrentChild
        {
            public readonly Akka.Actor.IActorRef Ref;
            public CurrentChild(Akka.Actor.IActorRef @ref) { }
        }
        public sealed class GetCurrentChild
        {
            public static readonly Akka.Pattern.BackoffSupervisor.GetCurrentChild Instance;
        }
        public sealed class ResetRestartCount : Akka.Event.IDeadLetterSuppression
        {
            public readonly int Current;
            public ResetRestartCount(int current) { }
        }
        public sealed class StartChild : Akka.Event.IDeadLetterSuppression
        {
            public static readonly Akka.Pattern.BackoffSupervisor.StartChild Instance;
        }
    }
    public class CircuitBreaker
    {
        public CircuitBreaker(int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }
        public System.TimeSpan CallTimeout { get; }
        public long CurrentFailureCount { get; }
        public int MaxFailures { get; }
        public System.TimeSpan ResetTimeout { get; }
        public static Akka.Pattern.CircuitBreaker Create(int maxFailures, System.TimeSpan callTimeout, System.TimeSpan resetTimeout) { }
        public Akka.Pattern.CircuitBreaker OnClose(System.Action callback) { }
        public Akka.Pattern.CircuitBreaker OnHalfOpen(System.Action callback) { }
        public Akka.Pattern.CircuitBreaker OnOpen(System.Action callback) { }
        public async System.Threading.Tasks.Task<T> WithCircuitBreaker<T>(System.Func<System.Threading.Tasks.Task<T>> body) { }
        public async System.Threading.Tasks.Task WithCircuitBreaker(System.Func<System.Threading.Tasks.Task> body) { }
        public void WithSyncCircuitBreaker(System.Action body) { }
        public T WithSyncCircuitBreaker<T>(System.Func<T> body) { }
    }
    public class IllegalStateException : Akka.Actor.AkkaException
    {
        public IllegalStateException(string message) { }
        public IllegalStateException(string message, System.Exception innerEx) { }
        protected IllegalStateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class OpenCircuitException : Akka.Actor.AkkaException
    {
        public OpenCircuitException() { }
        public OpenCircuitException(string message) { }
        public OpenCircuitException(string message, System.Exception cause) { }
        protected OpenCircuitException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
}
namespace Akka.Routing
{
    public class ActorRefRoutee : Akka.Routing.Routee
    {
        public ActorRefRoutee(Akka.Actor.IActorRef actor) { }
        public Akka.Actor.IActorRef Actor { get; }
        public override System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Routing.ActorRefRoutee other) { }
        public override int GetHashCode() { }
        public override void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public class ActorSelectionRoutee : Akka.Routing.Routee
    {
        public ActorSelectionRoutee(Akka.Actor.ActorSelection actor) { }
        public Akka.Actor.ActorSelection Selection { get; }
        public override System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Routing.ActorSelectionRoutee other) { }
        public override int GetHashCode() { }
        public override void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class AddRoutee : Akka.Routing.RouterManagementMessage
    {
        public AddRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Routee Routee { get; }
    }
    public sealed class AdjustPoolSize : Akka.Routing.RouterManagementMessage
    {
        public AdjustPoolSize(int change) { }
        public int Change { get; }
    }
    public class Broadcast : Akka.Routing.RouterEnvelope
    {
        public Broadcast(object message) { }
    }
    public sealed class BroadcastGroup : Akka.Routing.Group
    {
        public BroadcastGroup(Akka.Configuration.Config config) { }
        public BroadcastGroup(params string[] paths) { }
        public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        [System.ObsoleteAttribute("Use new BroadcastGroup(actorRefs.Select(c => c.Path.ToString())) instead")]
        public BroadcastGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees) { }
        public BroadcastGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.Group WithDispatcher(string dispatcher) { }
        public class BroadcastGroupSurrogate : Akka.Util.ISurrogate
        {
            public BroadcastGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class BroadcastPool : Akka.Routing.Pool
    {
        public BroadcastPool(int nrOfInstances) { }
        public BroadcastPool(Akka.Configuration.Config config) { }
        public BroadcastPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.BroadcastPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.BroadcastPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.BroadcastPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class BroadcastPoolSurrogate : Akka.Util.ISurrogate
        {
            public BroadcastPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class BroadcastRoutingLogic : Akka.Routing.RoutingLogic
    {
        public BroadcastRoutingLogic() { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public class static ConsistentHash
    {
        public static Akka.Routing.ConsistentHash<T> Create<T>(System.Collections.Generic.IEnumerable<T> nodes, int virtualNodesFactor) { }
        public class ConsistentHashingPoolSurrogate : Akka.Util.ISurrogate
        {
            public ConsistentHashingPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class ConsistentHash<T>
    {
        public ConsistentHash(System.Collections.Generic.SortedDictionary<int, T> nodes, int virtualNodesFactor) { }
        public bool IsEmpty { get; }
        public Akka.Routing.ConsistentHash<T> Add(T node) { }
        public T NodeFor(byte[] key) { }
        public T NodeFor(string key) { }
        public Akka.Routing.ConsistentHash<T> Remove(T node) { }
        public class ConsistentHashingGroupSurrogate<T> : Akka.Util.ISurrogate
        {
            public ConsistentHashingGroupSurrogate() { }
            public string[] Paths { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ConsistentHashableEnvelope : Akka.Routing.RouterEnvelope, Akka.Routing.IConsistentHashable
    {
        public ConsistentHashableEnvelope(object message, object hashKey) { }
        public object ConsistentHashKey { get; }
        public object HashKey { get; }
    }
    public sealed class ConsistentHashingGroup : Akka.Routing.Group
    {
        public ConsistentHashingGroup(Akka.Configuration.Config config) { }
        public ConsistentHashingGroup(params string[] paths) { }
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        [System.ObsoleteAttribute("Use new ConsistentHashingGroup(actorRefs.Select(c => c.Path.ToString())) instead")]
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees) { }
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<string> paths, Akka.Routing.ConsistentHashMapping hashMapping) { }
        public ConsistentHashingGroup(System.Collections.Generic.IEnumerable<string> paths, int virtualNodesFactor, Akka.Routing.ConsistentHashMapping hashMapping, string routerDispatcher) { }
        public int VirtualNodesFactor { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ConsistentHashingGroup WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.ConsistentHashingGroup WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }
        public Akka.Routing.ConsistentHashingGroup WithVirtualNodesFactor(int vnodes) { }
        public class ConsistentHashingGroupSurrogate : Akka.Util.ISurrogate
        {
            public ConsistentHashingGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ConsistentHashingPool : Akka.Routing.Pool
    {
        public ConsistentHashingPool(int nrOfInstances) { }
        public ConsistentHashingPool(Akka.Configuration.Config config) { }
        public ConsistentHashingPool(int nrOfInstances, Akka.Routing.ConsistentHashMapping hashMapping) { }
        public ConsistentHashingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False, int virtualNodesFactor = 0, Akka.Routing.ConsistentHashMapping hashMapping = null) { }
        public int VirtualNodesFactor { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ConsistentHashingPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.ConsistentHashingPool WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }
        public Akka.Routing.ConsistentHashingPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.ConsistentHashingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public Akka.Routing.ConsistentHashingPool WithVirtualNodesFactor(int vnodes) { }
        public class ConsistentHashingPoolSurrogate : Akka.Util.ISurrogate
        {
            public ConsistentHashingPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ConsistentHashingRoutingLogic : Akka.Routing.RoutingLogic
    {
        public ConsistentHashingRoutingLogic(Akka.Actor.ActorSystem system) { }
        public ConsistentHashingRoutingLogic(Akka.Actor.ActorSystem system, int virtualNodesFactor, Akka.Routing.ConsistentHashMapping hashMapping) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
        public Akka.Routing.ConsistentHashingRoutingLogic WithHashMapping(Akka.Routing.ConsistentHashMapping mapping) { }
    }
    public delegate object ConsistentHashMapping(object msg);
    public abstract class CustomRouterConfig : Akka.Routing.RouterConfig
    {
        protected CustomRouterConfig() { }
        protected CustomRouterConfig(string routerDispatcher) { }
    }
    public class Deafen : Akka.Routing.ListenerMessage
    {
        public Deafen(Akka.Actor.IActorRef listener) { }
        public Akka.Actor.IActorRef Listener { get; }
    }
    public class DefaultResizer : Akka.Routing.Resizer, System.IEquatable<Akka.Routing.DefaultResizer>
    {
        public DefaultResizer(int lower, int upper, int pressureThreshold = 1, double rampupRate = 0.2, double backoffThreshold = 0.3, double backoffRate = 0.1, int messagesPerResize = 10) { }
        public double BackoffRate { get; }
        public double BackoffThreshold { get; }
        public int LowerBound { get; set; }
        public int MessagesPerResize { get; }
        public int PressureThreshold { get; }
        public double RampupRate { get; }
        public int UpperBound { get; set; }
        public int Backoff(int pressure, int capacity) { }
        public int Capacity(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }
        public bool Equals(Akka.Routing.DefaultResizer other) { }
        public override bool Equals(object obj) { }
        public int Filter(int pressure, int capacity) { }
        public static Akka.Routing.DefaultResizer FromConfig(Akka.Configuration.Config resizerConfig) { }
        public override int GetHashCode() { }
        public override bool IsTimeForResize(long messageCounter) { }
        public int Pressure(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }
        public int Rampup(int pressure, int capacity) { }
        public override int Resize(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees) { }
    }
    public class FromConfig : Akka.Routing.Pool
    {
        protected FromConfig() { }
        protected FromConfig(Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher) { }
        public static Akka.Routing.FromConfig Instance { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem sys) { }
        public Akka.Actor.Props Props() { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override void VerifyConfig(Akka.Actor.ActorPath path) { }
        public Akka.Routing.FromConfig WithDispatcher(string dispatcherId) { }
        public Akka.Routing.FromConfig WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.FromConfig WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class FromConfigSurrogate : Akka.Util.ISurrogate
        {
            public FromConfigSurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class GetRoutees : Akka.Routing.RouterManagementMessage
    {
        public GetRoutees() { }
    }
    public abstract class Group : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Group>
    {
        protected Group(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public System.Collections.Generic.IEnumerable<string> Paths { get; }
        public bool Equals(Akka.Routing.Group other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public abstract System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system);
        public Akka.Actor.Props Props() { }
    }
    public interface IConsistentHashable
    {
        object ConsistentHashKey { get; }
    }
    public interface IListeners
    {
        Akka.Routing.ListenerSupport Listeners { get; }
    }
    public class Listen : Akka.Routing.ListenerMessage
    {
        public Listen(Akka.Actor.IActorRef listener) { }
        public Akka.Actor.IActorRef Listener { get; }
    }
    public abstract class ListenerMessage
    {
        protected ListenerMessage() { }
    }
    public class ListenerSupport
    {
        protected readonly System.Collections.Generic.HashSet<Akka.Actor.IActorRef> Listeners;
        public ListenerSupport() { }
        public Akka.Actor.Receive ListenerReceive { get; }
        public void Add(Akka.Actor.IActorRef actor) { }
        public void Gossip(object message) { }
        public void Gossip(object message, Akka.Actor.IActorRef sender) { }
        public void Remove(Akka.Actor.IActorRef actor) { }
    }
    public class NoRouter : Akka.Routing.RouterConfig
    {
        protected NoRouter() { }
        public static Akka.Routing.NoRouter Instance { get; }
        public override string RouterDispatcher { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public class NoRouterSurrogate : Akka.Util.ISurrogate
        {
            public NoRouterSurrogate() { }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public abstract class Pool : Akka.Routing.RouterConfig, System.IEquatable<Akka.Routing.Pool>
    {
        protected Pool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher) { }
        public static Akka.Actor.SupervisorStrategy DefaultSupervisorStrategy { get; }
        public int NrOfInstances { get; }
        public virtual Akka.Routing.Resizer Resizer { get; }
        public override bool StopRouterWhenAllRouteesRemoved { get; }
        public virtual Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }
        public virtual bool UsePoolDispatcher { get; }
        public bool Equals(Akka.Routing.Pool other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public abstract int GetNrOfInstances(Akka.Actor.ActorSystem system);
        public Akka.Actor.Props Props(Akka.Actor.Props routeeProps) { }
    }
    public sealed class RandomGroup : Akka.Routing.Group
    {
        public RandomGroup(Akka.Configuration.Config config) { }
        public RandomGroup(params string[] paths) { }
        public RandomGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        public RandomGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.RandomGroup WithDispatcher(string dispatcher) { }
        public class RandomGroupSurrogate : Akka.Util.ISurrogate
        {
            public RandomGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RandomLogic : Akka.Routing.RoutingLogic
    {
        public RandomLogic() { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public sealed class RandomPool : Akka.Routing.Pool
    {
        public RandomPool(Akka.Configuration.Config config) { }
        public RandomPool(int nrOfInstances) { }
        public RandomPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.RandomPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.RandomPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.RandomPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class RandomPoolSurrogate : Akka.Util.ISurrogate
        {
            public RandomPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RemoveRoutee : Akka.Routing.RouterManagementMessage
    {
        public RemoveRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Routee Routee { get; }
    }
    public class Resize : Akka.Routing.RouterManagementMessage
    {
        public Resize() { }
    }
    public abstract class Resizer
    {
        protected Resizer() { }
        public static Akka.Routing.Resizer FromConfig(Akka.Configuration.Config parentConfig) { }
        public abstract bool IsTimeForResize(long messageCounter);
        public abstract int Resize(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> currentRoutees);
    }
    public sealed class RoundRobinGroup : Akka.Routing.Group
    {
        public RoundRobinGroup(Akka.Configuration.Config config) { }
        public RoundRobinGroup(params string[] paths) { }
        public RoundRobinGroup(System.Collections.Generic.IEnumerable<string> paths) { }
        [System.ObsoleteAttribute("Use RoundRobinGroup constructor with IEnumerable<string> parameter")]
        public RoundRobinGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees) { }
        public RoundRobinGroup(System.Collections.Generic.IEnumerable<string> paths, string routerDispatcher) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.Group WithDispatcher(string dispatcherId) { }
        public class RoundRobinGroupSurrogate : Akka.Util.ISurrogate
        {
            public RoundRobinGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RoundRobinPool : Akka.Routing.Pool
    {
        public RoundRobinPool(Akka.Configuration.Config config) { }
        public RoundRobinPool(int nrOfInstances) { }
        public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer) { }
        public RoundRobinPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem sys) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.RoundRobinPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.RoundRobinPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.RoundRobinPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class RoundRobinPoolSurrogate : Akka.Util.ISurrogate
        {
            public RoundRobinPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class RoundRobinRoutingLogic : Akka.Routing.RoutingLogic
    {
        public RoundRobinRoutingLogic() { }
        public RoundRobinRoutingLogic(int next) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public class Routee
    {
        public static readonly Akka.Routing.Routee NoRoutee;
        public Routee() { }
        public virtual System.Threading.Tasks.Task<object> Ask(object message, System.Nullable<System.TimeSpan> timeout) { }
        public static Akka.Routing.Routee FromActorRef(Akka.Actor.IActorRef actorRef) { }
        public virtual void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class Routees
    {
        public Routees(System.Collections.Generic.IEnumerable<Akka.Routing.Routee> routees) { }
        public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Members { get; }
    }
    public class Router
    {
        public Router(Akka.Routing.RoutingLogic logic, Akka.Actor.IActorRef routee, params Akka.Actor.IActorRef[] routees) { }
        public Router(Akka.Routing.RoutingLogic logic, params Akka.Routing.Routee[] routees) { }
        public System.Collections.Generic.IEnumerable<Akka.Routing.Routee> Routees { get; }
        public Akka.Routing.RoutingLogic RoutingLogic { get; }
        public Akka.Routing.Router AddRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Router AddRoutee(Akka.Actor.IActorRef routee) { }
        public Akka.Routing.Router AddRoutee(Akka.Actor.ActorSelection routee) { }
        public Akka.Routing.Router RemoveRoutee(Akka.Routing.Routee routee) { }
        public Akka.Routing.Router RemoveRoutee(Akka.Actor.IActorRef routee) { }
        public Akka.Routing.Router RemoveRoutee(Akka.Actor.ActorSelection routee) { }
        public void Route(object message, Akka.Actor.IActorRef sender) { }
        protected virtual void Send(Akka.Routing.Routee routee, object message, Akka.Actor.IActorRef sender) { }
        public Akka.Routing.Router WithRoutees(params Akka.Routing.Routee[] routees) { }
    }
    public abstract class RouterConfig : Akka.Util.ISurrogated, System.IEquatable<Akka.Routing.RouterConfig>
    {
        protected RouterConfig() { }
        protected RouterConfig(string routerDispatcher) { }
        [System.ObsoleteAttribute("Use NoRouter.Instance instead")]
        public static Akka.Routing.RouterConfig NoRouter { get; }
        public virtual string RouterDispatcher { get; }
        public virtual bool StopRouterWhenAllRouteesRemoved { get; }
        public abstract Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system);
        public bool Equals(Akka.Routing.RouterConfig other) { }
        public override bool Equals(object obj) { }
        public virtual bool IsManagementMessage(object message) { }
        public virtual Akka.Actor.Props RoutingLogicController(Akka.Routing.RoutingLogic routingLogic) { }
        public abstract Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);
        public virtual void VerifyConfig(Akka.Actor.ActorPath path) { }
        public virtual Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
    }
    public class RouterEnvelope
    {
        public RouterEnvelope(object message) { }
        public object Message { get; }
    }
    public abstract class RouterManagementMessage
    {
        protected RouterManagementMessage() { }
    }
    public class static RouterMessage
    {
        public static readonly Akka.Routing.GetRoutees GetRoutees;
    }
    public abstract class RoutingLogic
    {
        protected RoutingLogic() { }
        public abstract Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees);
    }
    public sealed class ScatterGatherFirstCompletedGroup : Akka.Routing.Group
    {
        public ScatterGatherFirstCompletedGroup(Akka.Configuration.Config config) { }
        public ScatterGatherFirstCompletedGroup(System.TimeSpan within, params string[] paths) { }
        public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within) { }
        [System.ObsoleteAttribute("Use new ScatterGatherFirstCompletedGroup(actorRefs.Select(c => c.Path.ToString())" +
            ", within) instead")]
        public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<Akka.Actor.IActorRef> routees, System.TimeSpan within) { }
        public ScatterGatherFirstCompletedGroup(System.Collections.Generic.IEnumerable<string> paths, System.TimeSpan within, string routerDispatcher) { }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ScatterGatherFirstCompletedGroup WithDispatcher(string dispatcher) { }
        public class ScatterGatherFirstCompletedGroupSurrogate : Akka.Util.ISurrogate
        {
            public ScatterGatherFirstCompletedGroupSurrogate() { }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ScatterGatherFirstCompletedPool : Akka.Routing.Pool
    {
        public ScatterGatherFirstCompletedPool(Akka.Configuration.Config config) { }
        public ScatterGatherFirstCompletedPool(int nrOfInstances) { }
        public ScatterGatherFirstCompletedPool(int nrOfInstances, System.TimeSpan within) { }
        public ScatterGatherFirstCompletedPool(int nrOfInstances, Akka.Routing.Resizer resizer, System.TimeSpan within, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.ScatterGatherFirstCompletedPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.ScatterGatherFirstCompletedPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.ScatterGatherFirstCompletedPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class ScatterGatherFirstCompletedPoolSurrogate : Akka.Util.ISurrogate
        {
            public ScatterGatherFirstCompletedPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class ScatterGatherFirstCompletedRoutingLogic : Akka.Routing.RoutingLogic
    {
        public ScatterGatherFirstCompletedRoutingLogic(System.TimeSpan within) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public class SeveralRoutees : Akka.Routing.Routee
    {
        public SeveralRoutees(Akka.Routing.Routee[] routees) { }
        public override void Send(object message, Akka.Actor.IActorRef sender) { }
    }
    public sealed class SmallestMailboxPool : Akka.Routing.Pool
    {
        public SmallestMailboxPool(Akka.Configuration.Config config) { }
        public SmallestMailboxPool(int nrOfInstances) { }
        public SmallestMailboxPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher = False) { }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.SmallestMailboxPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.SmallestMailboxPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.SmallestMailboxPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class SmallestMailboxPoolSurrogate : Akka.Util.ISurrogate
        {
            public SmallestMailboxPoolSurrogate() { }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class SmallestMailboxRoutingLogic : Akka.Routing.RoutingLogic
    {
        public SmallestMailboxRoutingLogic() { }
        public SmallestMailboxRoutingLogic(int next) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public sealed class TailChopping : Akka.Routing.RoutingLogic
    {
        public TailChopping(Akka.Actor.IScheduler scheduler, System.TimeSpan within, System.TimeSpan interval) { }
        public override Akka.Routing.Routee Select(object message, Akka.Routing.Routee[] routees) { }
    }
    public sealed class TailChoppingGroup : Akka.Routing.Group
    {
        public TailChoppingGroup(Akka.Configuration.Config config) { }
        public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval) { }
        public TailChoppingGroup(System.Collections.Generic.IEnumerable<string> routeePaths, System.TimeSpan within, System.TimeSpan interval, string routerDispatcher) { }
        public System.TimeSpan Interval { get; }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override System.Collections.Generic.IEnumerable<string> GetPaths(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.TailChoppingGroup WithDispatcher(string dispatcher) { }
        public class TailChoppingGroupSurrogate : Akka.Util.ISurrogate
        {
            public TailChoppingGroupSurrogate() { }
            public System.TimeSpan Interval { get; set; }
            public System.Collections.Generic.IEnumerable<string> Paths { get; set; }
            public string RouterDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public sealed class TailChoppingPool : Akka.Routing.Pool
    {
        public TailChoppingPool(Akka.Configuration.Config config) { }
        public TailChoppingPool(int nrOfInstances, System.TimeSpan within, System.TimeSpan interval) { }
        public TailChoppingPool(int nrOfInstances, Akka.Routing.Resizer resizer, Akka.Actor.SupervisorStrategy supervisorStrategy, string routerDispatcher, System.TimeSpan within, System.TimeSpan interval, bool usePoolDispatcher = False) { }
        public System.TimeSpan Interval { get; }
        public System.TimeSpan Within { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public Akka.Routing.TailChoppingPool WithDispatcher(string dispatcher) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public Akka.Routing.TailChoppingPool WithResizer(Akka.Routing.Resizer resizer) { }
        public Akka.Routing.TailChoppingPool WithSupervisorStrategy(Akka.Actor.SupervisorStrategy strategy) { }
        public class TailChoppingPoolSurrogate : Akka.Util.ISurrogate
        {
            public TailChoppingPoolSurrogate() { }
            public System.TimeSpan Interval { get; set; }
            public int NrOfInstances { get; set; }
            public Akka.Routing.Resizer Resizer { get; set; }
            public string RouterDispatcher { get; set; }
            public Akka.Actor.SupervisorStrategy SupervisorStrategy { get; set; }
            public bool UsePoolDispatcher { get; set; }
            public System.TimeSpan Within { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
    public class WithListeners : Akka.Routing.ListenerMessage
    {
        public WithListeners(System.Action<Akka.Actor.IActorRef> listenerFunction) { }
        public System.Action<Akka.Actor.IActorRef> ListenerFunction { get; }
    }
}
namespace Akka.Serialization
{
    public class ByteArraySerializer : Akka.Serialization.Serializer
    {
        public ByteArraySerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override int Identifier { get; }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public class Information
    {
        public Information() { }
        public Akka.Actor.Address Address { get; set; }
        public Akka.Actor.ActorSystem System { get; set; }
    }
    public class JavaSerializer : Akka.Serialization.Serializer
    {
        public JavaSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override int Identifier { get; }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public class NewtonSoftJsonSerializer : Akka.Serialization.Serializer
    {
        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Configuration.Config config) { }
        public NewtonSoftJsonSerializer(Akka.Actor.ExtendedActorSystem system, Akka.Serialization.NewtonSoftJsonSerializerSettings settings) { }
        public override int Identifier { get; }
        public override bool IncludeManifest { get; }
        public object Serializer { get; }
        public Newtonsoft.Json.JsonSerializerSettings Settings { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
        public class AkkaContractResolver : Newtonsoft.Json.Serialization.DefaultContractResolver
        {
            public AkkaContractResolver() { }
            protected override Newtonsoft.Json.Serialization.JsonProperty CreateProperty(System.Reflection.MemberInfo member, Newtonsoft.Json.MemberSerialization memberSerialization) { }
        }
        public class SurrogateConverter : Newtonsoft.Json.JsonConverter
        {
            public SurrogateConverter(Akka.Serialization.NewtonSoftJsonSerializer parent) { }
            public override bool CanConvert(System.Type objectType) { }
            public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) { }
            public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) { }
        }
    }
    public sealed class NewtonSoftJsonSerializerSettings
    {
        public static readonly Akka.Serialization.NewtonSoftJsonSerializerSettings Default;
        public NewtonSoftJsonSerializerSettings(bool encodeTypeNames, bool preverveObjectReferences, System.Collections.Generic.IEnumerable<System.Type> converters) { }
        public System.Collections.Generic.IEnumerable<System.Type> Converters { get; }
        public bool EncodeTypeNames { get; }
        public bool PreserveObjectReferences { get; }
        public static Akka.Serialization.NewtonSoftJsonSerializerSettings Create(Akka.Configuration.Config config) { }
    }
    public class NullSerializer : Akka.Serialization.Serializer
    {
        public NullSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override int Identifier { get; }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public class Serialization
    {
        public Serialization(Akka.Actor.ExtendedActorSystem system) { }
        public Akka.Actor.ActorSystem System { get; }
        public void AddSerializationMap(System.Type type, Akka.Serialization.Serializer serializer) { }
        public void AddSerializer(Akka.Serialization.Serializer serializer) { }
        public object Deserialize(byte[] bytes, int serializerId, System.Type type) { }
        public object Deserialize(byte[] bytes, int serializerId, string manifest) { }
        public Akka.Serialization.Serializer FindSerializerFor(object obj) { }
        public Akka.Serialization.Serializer FindSerializerForType(System.Type objectType) { }
        public Akka.Serialization.Serializer GetSerializerById(int serializerId) { }
        public static string SerializedActorPath(Akka.Actor.IActorRef actorRef) { }
        public static T SerializeWithTransport<T>(Akka.Actor.ActorSystem system, Akka.Actor.Address address, System.Func<T> action) { }
    }
    public abstract class Serializer
    {
        protected readonly Akka.Actor.ExtendedActorSystem system;
        public Serializer(Akka.Actor.ExtendedActorSystem system) { }
        public virtual int Identifier { get; }
        public abstract bool IncludeManifest { get; }
        public abstract object FromBinary(byte[] bytes, System.Type type);
        public abstract byte[] ToBinary(object obj);
        public byte[] ToBinaryWithAddress(Akka.Actor.Address address, object obj) { }
        protected static string TypeQualifiedNameForManifest(System.Type type) { }
    }
    public class static SerializerIdentifierHelper
    {
        public const string SerializationIdentifiers = "akka.actor.serialization-identifiers";
        public static int GetSerializerIdentifierFromConfig(System.Type type, Akka.Actor.ExtendedActorSystem system) { }
    }
    public abstract class SerializerWithStringManifest : Akka.Serialization.Serializer
    {
        protected SerializerWithStringManifest(Akka.Actor.ExtendedActorSystem system) { }
        public virtual bool IncludeManifest { get; }
        public virtual object FromBinary(byte[] bytes, System.Type type) { }
        public abstract object FromBinary(byte[] binary, string manifest);
        public abstract string Manifest(object o);
    }
}
namespace Akka.Tools.MatchHandler
{
    public class Argument
    {
        public Argument(Akka.Tools.MatchHandler.PredicateAndHandler predicateAndHandler, object value, bool valueIsActionOrFunc) { }
        public Akka.Tools.MatchHandler.PredicateAndHandler PredicateAndHandler { get; }
        public object Value { get; }
        public bool ValueIsActionOrFunc { get; }
    }
    public class CachedMatchCompiler<T> : Akka.Tools.MatchHandler.IMatchCompiler<T>
    {
        public static readonly Akka.Tools.MatchHandler.CachedMatchCompiler<T> Instance;
        public CachedMatchCompiler(Akka.Tools.MatchHandler.IMatchExpressionBuilder expressionBuilder, Akka.Tools.MatchHandler.IPartialActionBuilder actionBuilder, Akka.Tools.MatchHandler.ILambdaExpressionCompiler expressionCompiler) { }
        public Akka.Tools.MatchHandler.PartialAction<T> Compile(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.TypeHandler> handlers, System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> capturedArguments, Akka.Tools.MatchHandler.MatchBuilderSignature signature) { }
        public void CompileToMethod(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.TypeHandler> handlers, System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> capturedArguments, Akka.Tools.MatchHandler.MatchBuilderSignature signature, System.Reflection.Emit.TypeBuilder typeBuilder, string methodName, System.Reflection.MethodAttributes methodAttributes = 22) { }
    }
    public class CompiledMatchHandlerWithArguments
    {
        public CompiledMatchHandlerWithArguments(System.Delegate compiledDelegate, object[] delegateArguments) { }
        public System.Delegate CompiledDelegate { get; }
        public object[] DelegateArguments { get; }
    }
    public enum HandlerKind
    {
        Action = 0,
        ActionWithPredicate = 1,
        Func = 2,
    }
    public interface ILambdaExpressionCompiler
    {
        System.Delegate Compile(System.Linq.Expressions.LambdaExpression expression);
        void CompileToMethod(System.Linq.Expressions.LambdaExpression expression, System.Reflection.Emit.MethodBuilder method);
    }
    public interface IMatchCompiler<in T>
    {
        Akka.Tools.MatchHandler.PartialAction<T> Compile(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.TypeHandler> handlers, System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> capturedArguments, Akka.Tools.MatchHandler.MatchBuilderSignature signature);
        void CompileToMethod(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.TypeHandler> handlers, System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> capturedArguments, Akka.Tools.MatchHandler.MatchBuilderSignature signature, System.Reflection.Emit.TypeBuilder typeBuilder, string methodName, System.Reflection.MethodAttributes methodAttributes = 22);
    }
    public interface IMatchExpressionBuilder
    {
        Akka.Tools.MatchHandler.MatchExpressionBuilderResult BuildLambdaExpression(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.TypeHandler> typeHandlers);
        object[] CreateArgumentValuesArray(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> arguments);
    }
    public interface IPartialActionBuilder
    {
        Akka.Tools.MatchHandler.PartialAction<T> Build<T>(Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments handlerAndArgs);
    }
    public interface IPartialHandlerArgumentsCapture<T>
    {
        bool Handle(T message);
        void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments);
    }
    public class LambdaExpressionCompiler : Akka.Tools.MatchHandler.ILambdaExpressionCompiler
    {
        public LambdaExpressionCompiler() { }
        public System.Delegate Compile(System.Linq.Expressions.LambdaExpression expression) { }
        public void CompileToMethod(System.Linq.Expressions.LambdaExpression expression, System.Reflection.Emit.MethodBuilder method) { }
    }
    public class MatchBuilder : Akka.Tools.MatchHandler.MatchBuilder<object>
    {
        public MatchBuilder(Akka.Tools.MatchHandler.IMatchCompiler<object> compiler) { }
    }
    public class MatchBuilder<TItem>
    {
        public MatchBuilder(Akka.Tools.MatchHandler.IMatchCompiler<TItem> compiler) { }
        public Akka.Tools.MatchHandler.PartialAction<TItem> Build() { }
        public void BuildToMethod(System.Reflection.Emit.TypeBuilder typeBuilder, string methodName, System.Reflection.MethodAttributes attributes = 22) { }
        public void Match<T>(System.Action<T> handler, System.Predicate<T> shouldHandle = null)
            where T : TItem { }
        public void Match(System.Type handlesType, System.Action<TItem> handler, System.Predicate<TItem> shouldHandle = null) { }
        public void Match<T>(System.Func<T, bool> handler)
            where T : TItem { }
        public void Match(System.Type handlesType, System.Func<TItem, bool> handler) { }
        public void MatchAny(System.Action<TItem> handler) { }
    }
    public class MatchBuilderSignature : System.IEquatable<Akka.Tools.MatchHandler.MatchBuilderSignature>
    {
        public MatchBuilderSignature(System.Collections.Generic.IReadOnlyList<object> signature) { }
        public bool Equals(Akka.Tools.MatchHandler.MatchBuilderSignature other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class MatchExpressionBuilder<T> : Akka.Tools.MatchHandler.IMatchExpressionBuilder
    {
        public MatchExpressionBuilder() { }
        public Akka.Tools.MatchHandler.MatchExpressionBuilderResult BuildLambdaExpression(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.TypeHandler> typeHandlers) { }
        public object[] CreateArgumentValuesArray(System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> arguments) { }
    }
    public class MatchExpressionBuilderResult
    {
        public MatchExpressionBuilderResult(System.Linq.Expressions.LambdaExpression lambdaExpression, object[] arguments) { }
        public object[] Arguments { get; }
        public System.Linq.Expressions.LambdaExpression LambdaExpression { get; }
    }
    public delegate bool PartialAction<in T>(T item);
    public class PartialActionBuilder : Akka.Tools.MatchHandler.IPartialActionBuilder
    {
        public const int MaxNumberOfArguments = 15;
        public PartialActionBuilder() { }
        public Akka.Tools.MatchHandler.PartialAction<T> Build<T>(Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments handlerAndArgs) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public sealed class PartialHandlerArgumentsCapture<T, T1, T2, T3, T4, T5, T6, T7, T8> : Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture<T>
    {
        public PartialHandlerArgumentsCapture() { }
        public bool Handle(T value) { }
        public void Initialize(System.Delegate handler, System.Collections.Generic.IReadOnlyList<object> arguments) { }
    }
    public class PredicateAndHandler
    {
        public System.Linq.Expressions.Expression ActionOrFuncExpression { get; set; }
        public System.Collections.Generic.IReadOnlyList<Akka.Tools.MatchHandler.Argument> Arguments { get; }
        public bool HandlerFirstArgumentShouldBeBaseType { get; }
        public Akka.Tools.MatchHandler.HandlerKind HandlerKind { get; }
        public System.Linq.Expressions.Expression PredicateExpression { get; set; }
        public static Akka.Tools.MatchHandler.PredicateAndHandler CreateAction(object action, object predicate = null, bool handlerFirstArgumentShouldBeBaseType = False) { }
        public static Akka.Tools.MatchHandler.PredicateAndHandler CreateFunc(object func, bool handlerFirstArgumentShouldBeBaseType = False) { }
    }
    public class TypeHandler
    {
        public TypeHandler(System.Type handlesType) { }
        public System.Collections.Generic.List<Akka.Tools.MatchHandler.PredicateAndHandler> Handlers { get; }
        public System.Type HandlesType { get; }
        public System.Collections.Generic.IEnumerable<Akka.Tools.MatchHandler.Argument> GetArguments() { }
    }
}
namespace Akka.Util
{
    public class ArrayLinearSeq<T> : Akka.Util.ILinearSeq<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        public ArrayLinearSeq(T[] array) { }
        public T Head { get; }
        public bool IsEmpty { get; }
        public System.Collections.Generic.IEnumerator<T> GetEnumerator() { }
        public Akka.Util.ILinearSeq<T> Tail() { }
    }
    public class AtomicBoolean
    {
        public AtomicBoolean(bool initialValue = False) { }
        public bool Value { get; set; }
        public bool CompareAndSet(bool expected, bool newValue) { }
        public bool GetAndSet(bool newValue) { }
    }
    public class AtomicReference<T>
        where T :  class
    {
        protected T atomicValue;
        public AtomicReference(T originalValue) { }
        public AtomicReference() { }
        public T Value { get; set; }
        public bool CompareAndSet(T expected, T newValue) { }
        public T GetAndSet(T newValue) { }
    }
    public class static Base64Encoding
    {
        public const string Base64Chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+~";
        public static string Base64Encode(this long value) { }
        public static string Base64Encode(this string s) { }
    }
    public class static BitArrayHelpers
    {
        public static byte[] ToBytes(this System.Collections.BitArray arr) { }
    }
    public abstract class ByteIterator
    {
        protected ByteIterator() { }
        public abstract bool HasNext { get; }
        public abstract byte Head { get; }
        public abstract int Len { get; }
        protected abstract void Clear();
        public virtual Akka.Util.ByteIterator Clone() { }
        public abstract int CopyToBuffer(Akka.IO.ByteBuffer buffer);
        public abstract Akka.Util.ByteIterator Drop(int n);
        public virtual Akka.Util.ByteIterator DropWhile(System.Func<byte, bool> p) { }
        public System.Tuple<Akka.Util.ByteIterator, Akka.Util.ByteIterator> Duplicate() { }
        public virtual T FoldLeft<T>(T z, System.Func<T, byte, T> op) { }
        public virtual void ForEach(System.Action<byte> f) { }
        public virtual byte GetByte() { }
        public abstract Akka.Util.ByteIterator GetBytes(byte[] xs, int offset, int n);
        public byte[] GetBytes(int n) { }
        public int GetInt(Akka.IO.ByteOrder byteOrder = 0) { }
        public long GetLong(Akka.IO.ByteOrder byteOrder = 0) { }
        public short GetShort(Akka.IO.ByteOrder byteOrder = 0) { }
        public virtual int IndexOf(byte elem) { }
        public virtual int IndexWhere(System.Func<byte, bool> p) { }
        public abstract byte Next();
        public virtual Akka.Util.ByteIterator Slice(int from, int until) { }
        public virtual System.Tuple<Akka.Util.ByteIterator, Akka.Util.ByteIterator> Span(System.Func<byte, bool> p) { }
        public abstract Akka.Util.ByteIterator Take(int n);
        public virtual Akka.Util.ByteIterator TakeWhile(System.Func<byte, bool> p) { }
        public abstract byte[] ToArray();
        public abstract Akka.IO.ByteString ToByteString();
    }
    public class ConcurrentSet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        public ConcurrentSet() { }
        public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection) { }
        public ConcurrentSet(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public ConcurrentSet(System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public ConcurrentSet(int concurrencyLevel, int capacity) { }
        public ConcurrentSet(int concurrencyLevel, System.Collections.Generic.IEnumerable<T> collection, System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public ConcurrentSet(int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public int Count { get; }
        public bool IsEmpty { get; }
        public void Clear() { }
        public bool Contains(T item) { }
        public bool TryAdd(T item) { }
        public bool TryRemove(T item) { }
    }
    public class static Either
    {
        public static Akka.Util.Left<T> Left<T>(T value) { }
        public static Akka.Util.Right<T> Right<T>(T value) { }
    }
    public abstract class Either<TA, TB>
    {
        protected Either(TA left, TB right) { }
        public abstract bool IsLeft { get; }
        public abstract bool IsRight { get; }
        protected TA Left { get; }
        protected TB Right { get; }
        public object Value { get; }
        public TRes Fold<TRes>(System.Func<TA, TRes> left, System.Func<TB, TRes> right) { }
        public Akka.Util.Either<TRes1, TRes2> Map<TRes1, TRes2>(System.Func<TA, TRes1> map1, System.Func<TB, TRes2> map2) { }
        public Akka.Util.Either<TRes, TB> MapLeft<TRes>(System.Func<TA, TRes> map) { }
        public Akka.Util.Either<TA, TRes> MapRight<TRes>(System.Func<TB, TRes> map) { }
        public Akka.Util.Left<TA, TB> ToLeft() { }
        public Akka.Util.Right<TA, TB> ToRight() { }
    }
    public sealed class FastLazy<T>
    {
        public FastLazy(System.Func<T> producer) { }
        public bool IsValueCreated { get; }
        public T Value { get; }
    }
    public interface ILinearSeq<out T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        T Head { get; }
        bool IsEmpty { get; }
        Akka.Util.ILinearSeq<T> Tail();
    }
    public class Index<TKey, TValue>
        where TValue : System.IComparable<>
    {
        public Index() { }
        public bool IsEmpty { get; }
        public System.Collections.Generic.IEnumerable<TValue> this[TKey index] { get; }
        public System.Collections.Generic.ICollection<TKey> Keys { get; }
        public System.Collections.Generic.HashSet<TValue> Values { get; }
        public void Clear() { }
        public TValue FindValue(TKey key, System.Func<TValue, bool> predicate) { }
        public void ForEach(System.Action<TKey, TValue> fun) { }
        public bool Put(TKey key, TValue value) { }
        public bool Remove(TKey key, TValue value) { }
        public System.Collections.Generic.IEnumerable<TValue> Remove(TKey key) { }
        public void RemoveValue(TValue value) { }
    }
    public interface IResolver
    {
        T Resolve<T>(object[] args);
    }
    public interface ISurrogate
    {
        Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system);
    }
    public interface ISurrogated
    {
        Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system);
    }
    public class Left<T>
    {
        public Left(T value) { }
        public bool IsLeft { get; }
        public bool IsRight { get; }
        public T Value { get; }
    }
    public class Left<TA, TB> : Akka.Util.Either<TA, TB>
    {
        public Left(TA a) { }
        public override bool IsLeft { get; }
        public override bool IsRight { get; }
        public TA Value { get; }
    }
    public sealed class ListPriorityQueue
    {
        [System.ObsoleteAttribute("Use ListPriorityQueue(initialCapacity, priorityCalculator) instead")]
        public ListPriorityQueue(int initialCapacity) { }
        public ListPriorityQueue(int initialCapacity, System.Func<object, int> priorityCalculator) { }
        public int Count() { }
        public Akka.Actor.Envelope Dequeue() { }
        public void Enqueue(Akka.Actor.Envelope item) { }
        public bool IsConsistent() { }
        public Akka.Actor.Envelope Peek() { }
        [System.ObsoleteAttribute("Use the constructor to set the priority calculator instead.")]
        public void SetPriorityCalculator(System.Func<object, int> priorityCalculator) { }
        public override string ToString() { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("Count={Count}")]
    public class MonoConcurrentQueue<T> : System.Collections.Concurrent.IProducerConsumerCollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.ICollection, System.Collections.IEnumerable
    {
        public MonoConcurrentQueue() { }
        public MonoConcurrentQueue(System.Collections.Generic.IEnumerable<T> collection) { }
        public int Count { get; }
        public bool IsEmpty { get; }
        public void CopyTo(T[] array, int index) { }
        public void Enqueue(T item) { }
        public System.Collections.Generic.IEnumerator<T> GetEnumerator() { }
        public T[] ToArray() { }
        public bool TryDequeue(out T result) { }
        public bool TryPeek(out T result) { }
    }
    public class static MurmurHash
    {
        public const uint StartMagicA = 2505324423u;
        public const uint StartMagicB = 718793509u;
        public static int ArrayHash<T>(T[] a) { }
        public static int ByteHash(byte[] b) { }
        public static uint ExtendHash(uint hash, uint value, uint magicA, uint magicB) { }
        public static uint FinalizeHash(uint hash) { }
        public static uint NextMagicA(uint magicA) { }
        public static uint NextMagicB(uint magicB) { }
        public static uint StartHash(uint seed) { }
        public static int StringHash(string s) { }
        public static int SymmetricHash<T>(System.Collections.Generic.IEnumerable<T> xs, uint seed) { }
    }
    public abstract class Resolve : Akka.Actor.IIndirectActorProducer
    {
        protected Resolve() { }
        public abstract System.Type ActorType { get; }
        protected static Akka.Util.IResolver Resolver { get; }
        public abstract Akka.Actor.ActorBase Produce();
        public void Release(Akka.Actor.ActorBase actor) { }
        public static void SetResolver(Akka.Util.IResolver resolver) { }
    }
    public class Resolve<TActor> : Akka.Util.Resolve
        where TActor : Akka.Actor.ActorBase
    {
        public Resolve(params object[] args) { }
        public override System.Type ActorType { get; }
        public object[] Arguments { get; }
        public override Akka.Actor.ActorBase Produce() { }
    }
    public class static Result
    {
        public static Akka.Util.Result<T> Failure<T>(System.Exception exception) { }
        public static Akka.Util.Result<T> From<T>(System.Func<T> func) { }
        public static Akka.Util.Result<T> FromTask<T>(System.Threading.Tasks.Task<T> task) { }
        public static Akka.Util.Result<T> Success<T>(T value) { }
    }
    public struct Result<T> : System.IEquatable<Akka.Util.Result<T>>
    {
        public readonly System.Exception Exception;
        public readonly bool IsSuccess;
        public readonly T Value;
        public Result(T value) { }
        public Result(System.Exception exception) { }
        public bool Equals(Akka.Util.Result<T> other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public class Right<T>
    {
        public Right(T value) { }
        public bool IsLeft { get; }
        public bool IsRight { get; }
        public T Value { get; }
    }
    public class Right<TA, TB> : Akka.Util.Either<TA, TB>
    {
        public Right(TB b) { }
        public override bool IsLeft { get; }
        public override bool IsRight { get; }
        public TB Value { get; }
    }
    public class static RuntimeDetector
    {
        public static readonly bool IsMono;
    }
    public class static StandardOutWriter
    {
        public static void Write(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }
        public static void WriteLine(string message, System.Nullable<System.ConsoleColor> foregroundColor = null, System.Nullable<System.ConsoleColor> backgroundColor = null) { }
    }
    public class static StringFormat
    {
        public static string SafeJoin(string separator, params object[] args) { }
    }
    public class Switch
    {
        public Switch(bool startAsOn = False) { }
        public bool IsOff { get; }
        public bool IsOn { get; }
        public bool IfOff(System.Action action) { }
        public bool IfOn(System.Action action) { }
        public void Locked(System.Action action) { }
        public bool SwitchOff(System.Action action) { }
        public bool SwitchOff() { }
        public bool SwitchOn(System.Action action) { }
        public bool SwitchOn() { }
        protected bool TranscendFrom(bool from, System.Action action) { }
        public bool WhileOff(System.Action action) { }
        public bool WhileOn(System.Action action) { }
    }
    public class static ThreadLocalRandom
    {
        public static System.Random Current { get; }
    }
    public sealed class TickTimeTokenBucket : Akka.Util.TokenBucket
    {
        public TickTimeTokenBucket(long capacity, long period) { }
        public override long CurrentTime { get; }
    }
    public abstract class TokenBucket
    {
        protected TokenBucket(long capacity, long ticksBetweenTokens) { }
        public abstract long CurrentTime { get; }
        public void Init() { }
        public long Offer(long cost) { }
    }
    public class static TypeExtensions
    {
        public static bool Implements<T>(this System.Type type) { }
        public static bool Implements(this System.Type type, System.Type moreGeneralType) { }
        public static string TypeQualifiedName(this System.Type type) { }
    }
    public class static Vector
    {
        public static System.Func<System.Func<T>, System.Collections.Generic.IList<T>> Fill<T>(int number) { }
    }
    public class static WildcardMatch
    {
        public static bool Like(this string text, string pattern, bool caseSensitive = False) { }
    }
    public sealed class WildcardTree<T>
        where T :  class
    {
        public static readonly Akka.Util.WildcardTree<T> Empty;
        public WildcardTree() { }
        public WildcardTree(T data, System.Collections.Generic.IDictionary<string, Akka.Util.WildcardTree<T>> children) { }
        public System.Collections.Generic.IDictionary<string, Akka.Util.WildcardTree<T>> Children { get; }
        public T Data { get; }
        public override bool Equals(object obj) { }
        public Akka.Util.WildcardTree<T> Find(System.Collections.Generic.IEnumerator<string> elements) { }
        public override int GetHashCode() { }
        public Akka.Util.WildcardTree<T> Insert(System.Collections.Generic.IEnumerator<string> elements, T data) { }
    }
}
namespace Akka.Util.Internal
{
    public class AtomicCounter : Akka.Util.Internal.IAtomicCounter<int>
    {
        public AtomicCounter(int initialValue) { }
        public AtomicCounter() { }
        public int Current { get; }
        public int AddAndGet(int amount) { }
        public bool CompareAndSet(int expected, int newValue) { }
        public int Decrement() { }
        public int DecrementAndGet() { }
        public int GetAndAdd(int amount) { }
        public int GetAndDecrement() { }
        public int GetAndIncrement() { }
        public int GetAndSet(int value) { }
        public int IncrementAndGet() { }
        public int Next() { }
        public void Reset() { }
    }
    public class AtomicCounterLong : Akka.Util.Internal.IAtomicCounter<long>
    {
        public AtomicCounterLong(long value) { }
        public AtomicCounterLong() { }
        public long Current { get; }
        public long AddAndGet(long amount) { }
        public bool CompareAndSet(long expected, long newValue) { }
        public long DecrementAndGet() { }
        public long GetAndAdd(long amount) { }
        public long GetAndIncrement() { }
        public long GetAndSet(long value) { }
        public long IncrementAndGet() { }
        public long Next() { }
        public void Reset() { }
        public override string ToString() { }
    }
    public class static DictionaryExtensions
    {
        public static void Put<TKey, TVal>(this System.Collections.Generic.IDictionary<TKey, TVal> dict, TKey key, TVal value) { }
        public static bool TryAdd<TKey, TVal>(this System.Collections.Generic.IDictionary<TKey, TVal> dict, TKey key, TVal value) { }
    }
    public class static Extensions
    {
        public static System.Collections.Generic.IDictionary<TKey, TValue> AddAndReturn<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }
        public static void AddOrSet<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue value) { }
        public static System.Collections.Generic.IEnumerable<TOut> AlternateSelectMany<TIn, TOut>(this System.Collections.Generic.IEnumerable<TIn> self, System.Func<TIn, System.Collections.Generic.IEnumerable<TOut>> evenSelector, System.Func<TIn, System.Collections.Generic.IEnumerable<TOut>> oddSelector) { }
        public static T AsInstanceOf<T>(this object self) { }
        public static string BetweenDoubleQuotes(this string self) { }
        public static System.Collections.Generic.IEnumerable<T> Concat<T>(this System.Collections.Generic.IEnumerable<T> enumerable, T item) { }
        public static System.Collections.Generic.IEnumerable<T> Drop<T>(this System.Collections.Generic.IEnumerable<T> self, int count) { }
        public static void ForEach<T>(this System.Collections.Generic.IEnumerable<T> enumerable, System.Action<T> action) { }
        public static TValue GetOrElse<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> hash, TKey key, TValue elseValue) { }
        public static T GetOrElse<T>(this T obj, T elseValue) { }
        public static T Head<T>(this System.Collections.Generic.IEnumerable<T> self) { }
        public static string Join(this System.Collections.Generic.IEnumerable<string> self, string separator) { }
        public static System.TimeSpan Max(this System.TimeSpan @this, System.TimeSpan other) { }
        public static System.TimeSpan Min(this System.TimeSpan @this, System.TimeSpan other) { }
        public static System.Collections.Generic.IEnumerable<string> SplitDottedPathHonouringQuotes(this string path) { }
        public static System.Collections.Generic.IEnumerable<T> TakeRight<T>(this System.Collections.Generic.IEnumerable<T> self, int n) { }
    }
    public interface IAtomicCounter<T>
    {
        T Current { get; }
        T AddAndGet(T amount);
        T GetAndAdd(T amount);
        T GetAndIncrement();
        T IncrementAndGet();
        T Next();
        void Reset();
    }
    public interface IAtomicState
    {
        bool HasListeners { get; }
        void AddListener(System.Action listener);
        void Enter();
        System.Threading.Tasks.Task<T> Invoke<T>(System.Func<System.Threading.Tasks.Task<T>> body);
    }
    public class static InterlockedSpin
    {
        public static TReturn ConditionallySwap<T, TReturn>(ref T reference, System.Func<T, System.Tuple<bool, T, TReturn>> updateIfTrue)
            where T :  class { }
        public static T Swap<T>(ref T reference, System.Func<T, T> updater)
            where T :  class { }
    }
    public class static StringBuilderExtensions
    {
        public static System.Text.StringBuilder AppendJoin<T>(this System.Text.StringBuilder sb, string separator, System.Collections.Generic.IEnumerable<T> values) { }
        public static System.Text.StringBuilder AppendJoin<T>(this System.Text.StringBuilder sb, string separator, System.Collections.Generic.IEnumerable<T> values, System.Action<System.Text.StringBuilder, T, int> valueAppender) { }
    }
    public class static TaskExtensions
    {
        public static System.Threading.Tasks.Task<TResult> CastTask<TTask, TResult>(this System.Threading.Tasks.Task<TTask> task) { }
    }
}
namespace Akka.Util.Internal.Collections
{
    public class static EnumeratorExtensions
    {
        public static Akka.Util.Internal.Collections.Iterator<T> Iterator<T>(this System.Collections.Generic.IEnumerable<T> enumerable) { }
    }
    public interface IBinaryTreeNode<out TKey, out TValue> : Akka.Util.Internal.Collections.IKeyValuePair<TKey, TValue>
    {
        Akka.Util.Internal.Collections.IBinaryTreeNode<TKey, TValue> Left { get; }
        Akka.Util.Internal.Collections.IBinaryTreeNode<TKey, TValue> Right { get; }
    }
    public interface IKeyValuePair<out TKey, out TValue>
    {
        TKey Key { get; }
        TValue Value { get; }
    }
    public class Iterator<T>
    {
        public Iterator(System.Collections.Generic.IEnumerable<T> enumerator) { }
        public bool IsEmpty() { }
        public T Next() { }
        public System.Collections.Generic.IEnumerable<T> ToVector() { }
    }
}
namespace Akka.Util.Reflection
{
    public class static ExpressionExtensions
    {
        public static System.Collections.Generic.IEnumerable<object> GetArguments(this System.Linq.Expressions.NewExpression newExpression) { }
    }
    public class static TypeCache
    {
        public static System.Type GetType(string typeName) { }
    }
}