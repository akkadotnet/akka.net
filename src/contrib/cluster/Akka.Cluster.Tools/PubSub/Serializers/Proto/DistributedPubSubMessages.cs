// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Akka.Cluster.PubSub.Serializers.Proto {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class DistributedPubSubMessages {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Status__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Status, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Builder> internal__static_Status__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Status_Version__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.Builder> internal__static_Status_Version__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Delta__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Builder> internal__static_Delta__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Delta_Entry__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.Builder> internal__static_Delta_Entry__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Delta_Bucket__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.Builder> internal__static_Delta_Bucket__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Address__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Address, global::Akka.Cluster.PubSub.Serializers.Proto.Address.Builder> internal__static_Address__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Send__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Send, global::Akka.Cluster.PubSub.Serializers.Proto.Send.Builder> internal__static_Send__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_SendToAll__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll, global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll.Builder> internal__static_SendToAll__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Publish__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Publish, global::Akka.Cluster.PubSub.Serializers.Proto.Publish.Builder> internal__static_Publish__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Payload__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Payload, global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder> internal__static_Payload__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static DistributedPubSubMessages() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Ch9EaXN0cmlidXRlZFB1YlN1Yk1lc3NhZ2VzLnByb3RvImQKBlN0YXR1cxIh" + 
          "Cgh2ZXJzaW9ucxgBIAMoCzIPLlN0YXR1cy5WZXJzaW9uGjcKB1ZlcnNpb24S" + 
          "GQoHYWRkcmVzcxgBIAIoCzIILkFkZHJlc3MSEQoJdGltZXN0YW1wGAIgAigD" + 
          "Iq4BCgVEZWx0YRIeCgdidWNrZXRzGAEgAygLMg0uRGVsdGEuQnVja2V0GjIK" + 
          "BUVudHJ5EgsKA2tleRgBIAIoCRIPCgd2ZXJzaW9uGAIgAigDEgsKA3JlZhgD" + 
          "IAEoCRpRCgZCdWNrZXQSFwoFb3duZXIYASACKAsyCC5BZGRyZXNzEg8KB3Zl" + 
          "cnNpb24YAiACKAMSHQoHY29udGVudBgDIAMoCzIMLkRlbHRhLkVudHJ5IksK" + 
          "B0FkZHJlc3MSDgoGc3lzdGVtGAEgAigJEhAKCGhvc3RuYW1lGAIgAigJEgwK" + 
          "BHBvcnQYAyACKA0SEAoIcHJvdG9jb2wYBCABKAkiRgoEU2VuZBIMCgRwYXRo" + 
          "GAEgAigJEhUKDWxvY2FsQWZmaW5pdHkYAiACKAgSGQoHcGF5bG9hZBgDIAIo" + 
          "CzIILlBheWxvYWQiSAoJU2VuZFRvQWxsEgwKBHBhdGgYASACKAkSEgoKYWxs" + 
          "QnV0U2VsZhgCIAIoCBIZCgdwYXlsb2FkGAMgAigLMgguUGF5bG9hZCIzCgdQ" + 
          "dWJsaXNoEg0KBXRvcGljGAEgAigJEhkKB3BheWxvYWQYAyACKAsyCC5QYXls" + 
          "b2FkIlEKB1BheWxvYWQSFwoPZW5jbG9zZWRNZXNzYWdlGAEgAigMEhQKDHNl" + 
          "cmlhbGl6ZXJJZBgCIAIoBRIXCg9tZXNzYWdlTWFuaWZlc3QYBCABKAxCAkgB");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Status__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Status__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Status, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Builder>(internal__static_Status__Descriptor,
                new string[] { "Versions", });
        internal__static_Status_Version__Descriptor = internal__static_Status__Descriptor.NestedTypes[0];
        internal__static_Status_Version__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.Builder>(internal__static_Status_Version__Descriptor,
                new string[] { "Address", "Timestamp", });
        internal__static_Delta__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Delta__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Builder>(internal__static_Delta__Descriptor,
                new string[] { "Buckets", });
        internal__static_Delta_Entry__Descriptor = internal__static_Delta__Descriptor.NestedTypes[0];
        internal__static_Delta_Entry__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.Builder>(internal__static_Delta_Entry__Descriptor,
                new string[] { "Key", "Version", "Ref", });
        internal__static_Delta_Bucket__Descriptor = internal__static_Delta__Descriptor.NestedTypes[1];
        internal__static_Delta_Bucket__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.Builder>(internal__static_Delta_Bucket__Descriptor,
                new string[] { "Owner", "Version", "Content", });
        internal__static_Address__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Address__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Address, global::Akka.Cluster.PubSub.Serializers.Proto.Address.Builder>(internal__static_Address__Descriptor,
                new string[] { "System", "Hostname", "Port", "Protocol", });
        internal__static_Send__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Send__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Send, global::Akka.Cluster.PubSub.Serializers.Proto.Send.Builder>(internal__static_Send__Descriptor,
                new string[] { "Path", "LocalAffinity", "Payload", });
        internal__static_SendToAll__Descriptor = Descriptor.MessageTypes[4];
        internal__static_SendToAll__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll, global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll.Builder>(internal__static_SendToAll__Descriptor,
                new string[] { "Path", "AllButSelf", "Payload", });
        internal__static_Publish__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Publish__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Publish, global::Akka.Cluster.PubSub.Serializers.Proto.Publish.Builder>(internal__static_Publish__Descriptor,
                new string[] { "Topic", "Payload", });
        internal__static_Payload__Descriptor = Descriptor.MessageTypes[6];
        internal__static_Payload__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Akka.Cluster.PubSub.Serializers.Proto.Payload, global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder>(internal__static_Payload__Descriptor,
                new string[] { "EnclosedMessage", "SerializerId", "MessageManifest", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Status : pb::GeneratedMessage<Status, Status.Builder> {
    private Status() { }
    private static readonly Status defaultInstance = new Status().MakeReadOnly();
    private static readonly string[] _statusFieldNames = new string[] { "versions" };
    private static readonly uint[] _statusFieldTags = new uint[] { 10 };
    public static Status DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Status DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Status ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Status__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Status, Status.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Status__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Version : pb::GeneratedMessage<Version, Version.Builder> {
        private Version() { }
        private static readonly Version defaultInstance = new Version().MakeReadOnly();
        private static readonly string[] _versionFieldNames = new string[] { "address", "timestamp" };
        private static readonly uint[] _versionFieldTags = new uint[] { 10, 16 };
        public static Version DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Version DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Version ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Status_Version__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<Version, Version.Builder> InternalFieldAccessors {
          get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Status_Version__FieldAccessorTable; }
        }
        
        public const int AddressFieldNumber = 1;
        private bool hasAddress;
        private global::Akka.Cluster.PubSub.Serializers.Proto.Address address_;
        public bool HasAddress {
          get { return hasAddress; }
        }
        public global::Akka.Cluster.PubSub.Serializers.Proto.Address Address {
          get { return address_ ?? global::Akka.Cluster.PubSub.Serializers.Proto.Address.DefaultInstance; }
        }
        
        public const int TimestampFieldNumber = 2;
        private bool hasTimestamp;
        private long timestamp_;
        public bool HasTimestamp {
          get { return hasTimestamp; }
        }
        public long Timestamp {
          get { return timestamp_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasAddress) return false;
            if (!hasTimestamp) return false;
            if (!Address.IsInitialized) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _versionFieldNames;
          if (hasAddress) {
            output.WriteMessage(1, field_names[0], Address);
          }
          if (hasTimestamp) {
            output.WriteInt64(2, field_names[1], Timestamp);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasAddress) {
              size += pb::CodedOutputStream.ComputeMessageSize(1, Address);
            }
            if (hasTimestamp) {
              size += pb::CodedOutputStream.ComputeInt64Size(2, Timestamp);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        public static Version ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Version ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Version ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Version ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Version ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Version ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Version ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Version ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Version ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Version ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Version MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Version prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<Version, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Version cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Version result;
          
          private Version PrepareBuilder() {
            if (resultIsReadOnly) {
              Version original = result;
              result = new Version();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Version MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.Descriptor; }
          }
          
          public override Version DefaultInstanceForType {
            get { return global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.DefaultInstance; }
          }
          
          public override Version BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is Version) {
              return MergeFrom((Version) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Version other) {
            if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasAddress) {
              MergeAddress(other.Address);
            }
            if (other.HasTimestamp) {
              Timestamp = other.Timestamp;
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_versionFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _versionFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  global::Akka.Cluster.PubSub.Serializers.Proto.Address.Builder subBuilder = global::Akka.Cluster.PubSub.Serializers.Proto.Address.CreateBuilder();
                  if (result.hasAddress) {
                    subBuilder.MergeFrom(Address);
                  }
                  input.ReadMessage(subBuilder, extensionRegistry);
                  Address = subBuilder.BuildPartial();
                  break;
                }
                case 16: {
                  result.hasTimestamp = input.ReadInt64(ref result.timestamp_);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public bool HasAddress {
           get { return result.hasAddress; }
          }
          public global::Akka.Cluster.PubSub.Serializers.Proto.Address Address {
            get { return result.Address; }
            set { SetAddress(value); }
          }
          public Builder SetAddress(global::Akka.Cluster.PubSub.Serializers.Proto.Address value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasAddress = true;
            result.address_ = value;
            return this;
          }
          public Builder SetAddress(global::Akka.Cluster.PubSub.Serializers.Proto.Address.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.hasAddress = true;
            result.address_ = builderForValue.Build();
            return this;
          }
          public Builder MergeAddress(global::Akka.Cluster.PubSub.Serializers.Proto.Address value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            if (result.hasAddress &&
                result.address_ != global::Akka.Cluster.PubSub.Serializers.Proto.Address.DefaultInstance) {
                result.address_ = global::Akka.Cluster.PubSub.Serializers.Proto.Address.CreateBuilder(result.address_).MergeFrom(value).BuildPartial();
            } else {
              result.address_ = value;
            }
            result.hasAddress = true;
            return this;
          }
          public Builder ClearAddress() {
            PrepareBuilder();
            result.hasAddress = false;
            result.address_ = null;
            return this;
          }
          
          public bool HasTimestamp {
            get { return result.hasTimestamp; }
          }
          public long Timestamp {
            get { return result.Timestamp; }
            set { SetTimestamp(value); }
          }
          public Builder SetTimestamp(long value) {
            PrepareBuilder();
            result.hasTimestamp = true;
            result.timestamp_ = value;
            return this;
          }
          public Builder ClearTimestamp() {
            PrepareBuilder();
            result.hasTimestamp = false;
            result.timestamp_ = 0L;
            return this;
          }
        }
        static Version() {
          object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int VersionsFieldNumber = 1;
    private pbc::PopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version> versions_ = new pbc::PopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version>();
    public scg::IList<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version> VersionsList {
      get { return versions_; }
    }
    public int VersionsCount {
      get { return versions_.Count; }
    }
    public global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version GetVersions(int index) {
      return versions_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version element in VersionsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _statusFieldNames;
      if (versions_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], versions_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version element in VersionsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Status ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Status ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Status ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Status ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Status ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Status ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Status ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Status ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Status ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Status ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Status MakeReadOnly() {
      versions_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Status prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Status, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Status cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Status result;
      
      private Status PrepareBuilder() {
        if (resultIsReadOnly) {
          Status original = result;
          result = new Status();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Status MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Status.Descriptor; }
      }
      
      public override Status DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Status.DefaultInstance; }
      }
      
      public override Status BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Status) {
          return MergeFrom((Status) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Status other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Status.DefaultInstance) return this;
        PrepareBuilder();
        if (other.versions_.Count != 0) {
          result.versions_.Add(other.versions_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_statusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _statusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.versions_, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version> VersionsList {
        get { return PrepareBuilder().versions_; }
      }
      public int VersionsCount {
        get { return result.VersionsCount; }
      }
      public global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version GetVersions(int index) {
        return result.GetVersions(index);
      }
      public Builder SetVersions(int index, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.versions_[index] = value;
        return this;
      }
      public Builder SetVersions(int index, global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.versions_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddVersions(global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.versions_.Add(value);
        return this;
      }
      public Builder AddVersions(global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.versions_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeVersions(scg::IEnumerable<global::Akka.Cluster.PubSub.Serializers.Proto.Status.Types.Version> values) {
        PrepareBuilder();
        result.versions_.Add(values);
        return this;
      }
      public Builder ClearVersions() {
        PrepareBuilder();
        result.versions_.Clear();
        return this;
      }
    }
    static Status() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Delta : pb::GeneratedMessage<Delta, Delta.Builder> {
    private Delta() { }
    private static readonly Delta defaultInstance = new Delta().MakeReadOnly();
    private static readonly string[] _deltaFieldNames = new string[] { "buckets" };
    private static readonly uint[] _deltaFieldTags = new uint[] { 10 };
    public static Delta DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Delta DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Delta ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Delta__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Delta, Delta.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Delta__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Entry : pb::GeneratedMessage<Entry, Entry.Builder> {
        private Entry() { }
        private static readonly Entry defaultInstance = new Entry().MakeReadOnly();
        private static readonly string[] _entryFieldNames = new string[] { "key", "ref", "version" };
        private static readonly uint[] _entryFieldTags = new uint[] { 10, 26, 16 };
        public static Entry DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Entry DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Entry ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Delta_Entry__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<Entry, Entry.Builder> InternalFieldAccessors {
          get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Delta_Entry__FieldAccessorTable; }
        }
        
        public const int KeyFieldNumber = 1;
        private bool hasKey;
        private string key_ = "";
        public bool HasKey {
          get { return hasKey; }
        }
        public string Key {
          get { return key_; }
        }
        
        public const int VersionFieldNumber = 2;
        private bool hasVersion;
        private long version_;
        public bool HasVersion {
          get { return hasVersion; }
        }
        public long Version {
          get { return version_; }
        }
        
        public const int RefFieldNumber = 3;
        private bool hasRef;
        private string ref_ = "";
        public bool HasRef {
          get { return hasRef; }
        }
        public string Ref {
          get { return ref_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasKey) return false;
            if (!hasVersion) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _entryFieldNames;
          if (hasKey) {
            output.WriteString(1, field_names[0], Key);
          }
          if (hasVersion) {
            output.WriteInt64(2, field_names[2], Version);
          }
          if (hasRef) {
            output.WriteString(3, field_names[1], Ref);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasKey) {
              size += pb::CodedOutputStream.ComputeStringSize(1, Key);
            }
            if (hasVersion) {
              size += pb::CodedOutputStream.ComputeInt64Size(2, Version);
            }
            if (hasRef) {
              size += pb::CodedOutputStream.ComputeStringSize(3, Ref);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        public static Entry ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Entry ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Entry ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Entry ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Entry ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Entry ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Entry ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Entry ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Entry ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Entry ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Entry MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Entry prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<Entry, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Entry cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Entry result;
          
          private Entry PrepareBuilder() {
            if (resultIsReadOnly) {
              Entry original = result;
              result = new Entry();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Entry MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.Descriptor; }
          }
          
          public override Entry DefaultInstanceForType {
            get { return global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.DefaultInstance; }
          }
          
          public override Entry BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is Entry) {
              return MergeFrom((Entry) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Entry other) {
            if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasKey) {
              Key = other.Key;
            }
            if (other.HasVersion) {
              Version = other.Version;
            }
            if (other.HasRef) {
              Ref = other.Ref;
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_entryFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _entryFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasKey = input.ReadString(ref result.key_);
                  break;
                }
                case 16: {
                  result.hasVersion = input.ReadInt64(ref result.version_);
                  break;
                }
                case 26: {
                  result.hasRef = input.ReadString(ref result.ref_);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public bool HasKey {
            get { return result.hasKey; }
          }
          public string Key {
            get { return result.Key; }
            set { SetKey(value); }
          }
          public Builder SetKey(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasKey = true;
            result.key_ = value;
            return this;
          }
          public Builder ClearKey() {
            PrepareBuilder();
            result.hasKey = false;
            result.key_ = "";
            return this;
          }
          
          public bool HasVersion {
            get { return result.hasVersion; }
          }
          public long Version {
            get { return result.Version; }
            set { SetVersion(value); }
          }
          public Builder SetVersion(long value) {
            PrepareBuilder();
            result.hasVersion = true;
            result.version_ = value;
            return this;
          }
          public Builder ClearVersion() {
            PrepareBuilder();
            result.hasVersion = false;
            result.version_ = 0L;
            return this;
          }
          
          public bool HasRef {
            get { return result.hasRef; }
          }
          public string Ref {
            get { return result.Ref; }
            set { SetRef(value); }
          }
          public Builder SetRef(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasRef = true;
            result.ref_ = value;
            return this;
          }
          public Builder ClearRef() {
            PrepareBuilder();
            result.hasRef = false;
            result.ref_ = "";
            return this;
          }
        }
        static Entry() {
          object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Bucket : pb::GeneratedMessage<Bucket, Bucket.Builder> {
        private Bucket() { }
        private static readonly Bucket defaultInstance = new Bucket().MakeReadOnly();
        private static readonly string[] _bucketFieldNames = new string[] { "content", "owner", "version" };
        private static readonly uint[] _bucketFieldTags = new uint[] { 26, 10, 16 };
        public static Bucket DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Bucket DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Bucket ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Delta_Bucket__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<Bucket, Bucket.Builder> InternalFieldAccessors {
          get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Delta_Bucket__FieldAccessorTable; }
        }
        
        public const int OwnerFieldNumber = 1;
        private bool hasOwner;
        private global::Akka.Cluster.PubSub.Serializers.Proto.Address owner_;
        public bool HasOwner {
          get { return hasOwner; }
        }
        public global::Akka.Cluster.PubSub.Serializers.Proto.Address Owner {
          get { return owner_ ?? global::Akka.Cluster.PubSub.Serializers.Proto.Address.DefaultInstance; }
        }
        
        public const int VersionFieldNumber = 2;
        private bool hasVersion;
        private long version_;
        public bool HasVersion {
          get { return hasVersion; }
        }
        public long Version {
          get { return version_; }
        }
        
        public const int ContentFieldNumber = 3;
        private pbc::PopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry> content_ = new pbc::PopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry>();
        public scg::IList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry> ContentList {
          get { return content_; }
        }
        public int ContentCount {
          get { return content_.Count; }
        }
        public global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry GetContent(int index) {
          return content_[index];
        }
        
        public override bool IsInitialized {
          get {
            if (!hasOwner) return false;
            if (!hasVersion) return false;
            if (!Owner.IsInitialized) return false;
            foreach (global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry element in ContentList) {
              if (!element.IsInitialized) return false;
            }
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _bucketFieldNames;
          if (hasOwner) {
            output.WriteMessage(1, field_names[1], Owner);
          }
          if (hasVersion) {
            output.WriteInt64(2, field_names[2], Version);
          }
          if (content_.Count > 0) {
            output.WriteMessageArray(3, field_names[0], content_);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasOwner) {
              size += pb::CodedOutputStream.ComputeMessageSize(1, Owner);
            }
            if (hasVersion) {
              size += pb::CodedOutputStream.ComputeInt64Size(2, Version);
            }
            foreach (global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry element in ContentList) {
              size += pb::CodedOutputStream.ComputeMessageSize(3, element);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        public static Bucket ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Bucket ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Bucket ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Bucket ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Bucket ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Bucket ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Bucket ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Bucket ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Bucket ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Bucket ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Bucket MakeReadOnly() {
          content_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Bucket prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<Bucket, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Bucket cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Bucket result;
          
          private Bucket PrepareBuilder() {
            if (resultIsReadOnly) {
              Bucket original = result;
              result = new Bucket();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Bucket MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.Descriptor; }
          }
          
          public override Bucket DefaultInstanceForType {
            get { return global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.DefaultInstance; }
          }
          
          public override Bucket BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is Bucket) {
              return MergeFrom((Bucket) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Bucket other) {
            if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasOwner) {
              MergeOwner(other.Owner);
            }
            if (other.HasVersion) {
              Version = other.Version;
            }
            if (other.content_.Count != 0) {
              result.content_.Add(other.content_);
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_bucketFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _bucketFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  global::Akka.Cluster.PubSub.Serializers.Proto.Address.Builder subBuilder = global::Akka.Cluster.PubSub.Serializers.Proto.Address.CreateBuilder();
                  if (result.hasOwner) {
                    subBuilder.MergeFrom(Owner);
                  }
                  input.ReadMessage(subBuilder, extensionRegistry);
                  Owner = subBuilder.BuildPartial();
                  break;
                }
                case 16: {
                  result.hasVersion = input.ReadInt64(ref result.version_);
                  break;
                }
                case 26: {
                  input.ReadMessageArray(tag, field_name, result.content_, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.DefaultInstance, extensionRegistry);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public bool HasOwner {
           get { return result.hasOwner; }
          }
          public global::Akka.Cluster.PubSub.Serializers.Proto.Address Owner {
            get { return result.Owner; }
            set { SetOwner(value); }
          }
          public Builder SetOwner(global::Akka.Cluster.PubSub.Serializers.Proto.Address value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasOwner = true;
            result.owner_ = value;
            return this;
          }
          public Builder SetOwner(global::Akka.Cluster.PubSub.Serializers.Proto.Address.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.hasOwner = true;
            result.owner_ = builderForValue.Build();
            return this;
          }
          public Builder MergeOwner(global::Akka.Cluster.PubSub.Serializers.Proto.Address value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            if (result.hasOwner &&
                result.owner_ != global::Akka.Cluster.PubSub.Serializers.Proto.Address.DefaultInstance) {
                result.owner_ = global::Akka.Cluster.PubSub.Serializers.Proto.Address.CreateBuilder(result.owner_).MergeFrom(value).BuildPartial();
            } else {
              result.owner_ = value;
            }
            result.hasOwner = true;
            return this;
          }
          public Builder ClearOwner() {
            PrepareBuilder();
            result.hasOwner = false;
            result.owner_ = null;
            return this;
          }
          
          public bool HasVersion {
            get { return result.hasVersion; }
          }
          public long Version {
            get { return result.Version; }
            set { SetVersion(value); }
          }
          public Builder SetVersion(long value) {
            PrepareBuilder();
            result.hasVersion = true;
            result.version_ = value;
            return this;
          }
          public Builder ClearVersion() {
            PrepareBuilder();
            result.hasVersion = false;
            result.version_ = 0L;
            return this;
          }
          
          public pbc::IPopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry> ContentList {
            get { return PrepareBuilder().content_; }
          }
          public int ContentCount {
            get { return result.ContentCount; }
          }
          public global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry GetContent(int index) {
            return result.GetContent(index);
          }
          public Builder SetContent(int index, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.content_[index] = value;
            return this;
          }
          public Builder SetContent(int index, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.content_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddContent(global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.content_.Add(value);
            return this;
          }
          public Builder AddContent(global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.content_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeContent(scg::IEnumerable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Entry> values) {
            PrepareBuilder();
            result.content_.Add(values);
            return this;
          }
          public Builder ClearContent() {
            PrepareBuilder();
            result.content_.Clear();
            return this;
          }
        }
        static Bucket() {
          object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int BucketsFieldNumber = 1;
    private pbc::PopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket> buckets_ = new pbc::PopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket>();
    public scg::IList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket> BucketsList {
      get { return buckets_; }
    }
    public int BucketsCount {
      get { return buckets_.Count; }
    }
    public global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket GetBuckets(int index) {
      return buckets_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket element in BucketsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _deltaFieldNames;
      if (buckets_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], buckets_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket element in BucketsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Delta ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Delta ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Delta ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Delta ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Delta ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Delta ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Delta ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Delta ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Delta ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Delta ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Delta MakeReadOnly() {
      buckets_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Delta prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Delta, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Delta cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Delta result;
      
      private Delta PrepareBuilder() {
        if (resultIsReadOnly) {
          Delta original = result;
          result = new Delta();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Delta MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Descriptor; }
      }
      
      public override Delta DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Delta.DefaultInstance; }
      }
      
      public override Delta BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Delta) {
          return MergeFrom((Delta) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Delta other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Delta.DefaultInstance) return this;
        PrepareBuilder();
        if (other.buckets_.Count != 0) {
          result.buckets_.Add(other.buckets_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_deltaFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _deltaFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.buckets_, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket> BucketsList {
        get { return PrepareBuilder().buckets_; }
      }
      public int BucketsCount {
        get { return result.BucketsCount; }
      }
      public global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket GetBuckets(int index) {
        return result.GetBuckets(index);
      }
      public Builder SetBuckets(int index, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.buckets_[index] = value;
        return this;
      }
      public Builder SetBuckets(int index, global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.buckets_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddBuckets(global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.buckets_.Add(value);
        return this;
      }
      public Builder AddBuckets(global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.buckets_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeBuckets(scg::IEnumerable<global::Akka.Cluster.PubSub.Serializers.Proto.Delta.Types.Bucket> values) {
        PrepareBuilder();
        result.buckets_.Add(values);
        return this;
      }
      public Builder ClearBuckets() {
        PrepareBuilder();
        result.buckets_.Clear();
        return this;
      }
    }
    static Delta() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Address : pb::GeneratedMessage<Address, Address.Builder> {
    private Address() { }
    private static readonly Address defaultInstance = new Address().MakeReadOnly();
    private static readonly string[] _addressFieldNames = new string[] { "hostname", "port", "protocol", "system" };
    private static readonly uint[] _addressFieldTags = new uint[] { 18, 24, 34, 10 };
    public static Address DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Address DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Address ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Address__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Address, Address.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Address__FieldAccessorTable; }
    }
    
    public const int SystemFieldNumber = 1;
    private bool hasSystem;
    private string system_ = "";
    public bool HasSystem {
      get { return hasSystem; }
    }
    public string System {
      get { return system_; }
    }
    
    public const int HostnameFieldNumber = 2;
    private bool hasHostname;
    private string hostname_ = "";
    public bool HasHostname {
      get { return hasHostname; }
    }
    public string Hostname {
      get { return hostname_; }
    }
    
    public const int PortFieldNumber = 3;
    private bool hasPort;
    private uint port_;
    public bool HasPort {
      get { return hasPort; }
    }
    [global::System.CLSCompliant(false)]
    public uint Port {
      get { return port_; }
    }
    
    public const int ProtocolFieldNumber = 4;
    private bool hasProtocol;
    private string protocol_ = "";
    public bool HasProtocol {
      get { return hasProtocol; }
    }
    public string Protocol {
      get { return protocol_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSystem) return false;
        if (!hasHostname) return false;
        if (!hasPort) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _addressFieldNames;
      if (hasSystem) {
        output.WriteString(1, field_names[3], System);
      }
      if (hasHostname) {
        output.WriteString(2, field_names[0], Hostname);
      }
      if (hasPort) {
        output.WriteUInt32(3, field_names[1], Port);
      }
      if (hasProtocol) {
        output.WriteString(4, field_names[2], Protocol);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasSystem) {
          size += pb::CodedOutputStream.ComputeStringSize(1, System);
        }
        if (hasHostname) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Hostname);
        }
        if (hasPort) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, Port);
        }
        if (hasProtocol) {
          size += pb::CodedOutputStream.ComputeStringSize(4, Protocol);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Address ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Address ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Address ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Address ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Address ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Address ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Address ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Address ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Address ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Address ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Address MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Address prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Address, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Address cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Address result;
      
      private Address PrepareBuilder() {
        if (resultIsReadOnly) {
          Address original = result;
          result = new Address();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Address MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Address.Descriptor; }
      }
      
      public override Address DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Address.DefaultInstance; }
      }
      
      public override Address BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Address) {
          return MergeFrom((Address) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Address other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Address.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSystem) {
          System = other.System;
        }
        if (other.HasHostname) {
          Hostname = other.Hostname;
        }
        if (other.HasPort) {
          Port = other.Port;
        }
        if (other.HasProtocol) {
          Protocol = other.Protocol;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_addressFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _addressFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasSystem = input.ReadString(ref result.system_);
              break;
            }
            case 18: {
              result.hasHostname = input.ReadString(ref result.hostname_);
              break;
            }
            case 24: {
              result.hasPort = input.ReadUInt32(ref result.port_);
              break;
            }
            case 34: {
              result.hasProtocol = input.ReadString(ref result.protocol_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSystem {
        get { return result.hasSystem; }
      }
      public string System {
        get { return result.System; }
        set { SetSystem(value); }
      }
      public Builder SetSystem(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSystem = true;
        result.system_ = value;
        return this;
      }
      public Builder ClearSystem() {
        PrepareBuilder();
        result.hasSystem = false;
        result.system_ = "";
        return this;
      }
      
      public bool HasHostname {
        get { return result.hasHostname; }
      }
      public string Hostname {
        get { return result.Hostname; }
        set { SetHostname(value); }
      }
      public Builder SetHostname(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHostname = true;
        result.hostname_ = value;
        return this;
      }
      public Builder ClearHostname() {
        PrepareBuilder();
        result.hasHostname = false;
        result.hostname_ = "";
        return this;
      }
      
      public bool HasPort {
        get { return result.hasPort; }
      }
      [global::System.CLSCompliant(false)]
      public uint Port {
        get { return result.Port; }
        set { SetPort(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetPort(uint value) {
        PrepareBuilder();
        result.hasPort = true;
        result.port_ = value;
        return this;
      }
      public Builder ClearPort() {
        PrepareBuilder();
        result.hasPort = false;
        result.port_ = 0;
        return this;
      }
      
      public bool HasProtocol {
        get { return result.hasProtocol; }
      }
      public string Protocol {
        get { return result.Protocol; }
        set { SetProtocol(value); }
      }
      public Builder SetProtocol(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasProtocol = true;
        result.protocol_ = value;
        return this;
      }
      public Builder ClearProtocol() {
        PrepareBuilder();
        result.hasProtocol = false;
        result.protocol_ = "";
        return this;
      }
    }
    static Address() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Send : pb::GeneratedMessage<Send, Send.Builder> {
    private Send() { }
    private static readonly Send defaultInstance = new Send().MakeReadOnly();
    private static readonly string[] _sendFieldNames = new string[] { "localAffinity", "path", "payload" };
    private static readonly uint[] _sendFieldTags = new uint[] { 16, 10, 26 };
    public static Send DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Send DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Send ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Send__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Send, Send.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Send__FieldAccessorTable; }
    }
    
    public const int PathFieldNumber = 1;
    private bool hasPath;
    private string path_ = "";
    public bool HasPath {
      get { return hasPath; }
    }
    public string Path {
      get { return path_; }
    }
    
    public const int LocalAffinityFieldNumber = 2;
    private bool hasLocalAffinity;
    private bool localAffinity_;
    public bool HasLocalAffinity {
      get { return hasLocalAffinity; }
    }
    public bool LocalAffinity {
      get { return localAffinity_; }
    }
    
    public const int PayloadFieldNumber = 3;
    private bool hasPayload;
    private global::Akka.Cluster.PubSub.Serializers.Proto.Payload payload_;
    public bool HasPayload {
      get { return hasPayload; }
    }
    public global::Akka.Cluster.PubSub.Serializers.Proto.Payload Payload {
      get { return payload_ ?? global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPath) return false;
        if (!hasLocalAffinity) return false;
        if (!hasPayload) return false;
        if (!Payload.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _sendFieldNames;
      if (hasPath) {
        output.WriteString(1, field_names[1], Path);
      }
      if (hasLocalAffinity) {
        output.WriteBool(2, field_names[0], LocalAffinity);
      }
      if (hasPayload) {
        output.WriteMessage(3, field_names[2], Payload);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPath) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Path);
        }
        if (hasLocalAffinity) {
          size += pb::CodedOutputStream.ComputeBoolSize(2, LocalAffinity);
        }
        if (hasPayload) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Payload);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Send ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Send ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Send ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Send ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Send ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Send ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Send ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Send ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Send ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Send ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Send MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Send prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Send, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Send cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Send result;
      
      private Send PrepareBuilder() {
        if (resultIsReadOnly) {
          Send original = result;
          result = new Send();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Send MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Send.Descriptor; }
      }
      
      public override Send DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Send.DefaultInstance; }
      }
      
      public override Send BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Send) {
          return MergeFrom((Send) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Send other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Send.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPath) {
          Path = other.Path;
        }
        if (other.HasLocalAffinity) {
          LocalAffinity = other.LocalAffinity;
        }
        if (other.HasPayload) {
          MergePayload(other.Payload);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_sendFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _sendFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasPath = input.ReadString(ref result.path_);
              break;
            }
            case 16: {
              result.hasLocalAffinity = input.ReadBool(ref result.localAffinity_);
              break;
            }
            case 26: {
              global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder subBuilder = global::Akka.Cluster.PubSub.Serializers.Proto.Payload.CreateBuilder();
              if (result.hasPayload) {
                subBuilder.MergeFrom(Payload);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Payload = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPath {
        get { return result.hasPath; }
      }
      public string Path {
        get { return result.Path; }
        set { SetPath(value); }
      }
      public Builder SetPath(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPath = true;
        result.path_ = value;
        return this;
      }
      public Builder ClearPath() {
        PrepareBuilder();
        result.hasPath = false;
        result.path_ = "";
        return this;
      }
      
      public bool HasLocalAffinity {
        get { return result.hasLocalAffinity; }
      }
      public bool LocalAffinity {
        get { return result.LocalAffinity; }
        set { SetLocalAffinity(value); }
      }
      public Builder SetLocalAffinity(bool value) {
        PrepareBuilder();
        result.hasLocalAffinity = true;
        result.localAffinity_ = value;
        return this;
      }
      public Builder ClearLocalAffinity() {
        PrepareBuilder();
        result.hasLocalAffinity = false;
        result.localAffinity_ = false;
        return this;
      }
      
      public bool HasPayload {
       get { return result.hasPayload; }
      }
      public global::Akka.Cluster.PubSub.Serializers.Proto.Payload Payload {
        get { return result.Payload; }
        set { SetPayload(value); }
      }
      public Builder SetPayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPayload = true;
        result.payload_ = value;
        return this;
      }
      public Builder SetPayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPayload = true;
        result.payload_ = builderForValue.Build();
        return this;
      }
      public Builder MergePayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPayload &&
            result.payload_ != global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance) {
            result.payload_ = global::Akka.Cluster.PubSub.Serializers.Proto.Payload.CreateBuilder(result.payload_).MergeFrom(value).BuildPartial();
        } else {
          result.payload_ = value;
        }
        result.hasPayload = true;
        return this;
      }
      public Builder ClearPayload() {
        PrepareBuilder();
        result.hasPayload = false;
        result.payload_ = null;
        return this;
      }
    }
    static Send() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SendToAll : pb::GeneratedMessage<SendToAll, SendToAll.Builder> {
    private SendToAll() { }
    private static readonly SendToAll defaultInstance = new SendToAll().MakeReadOnly();
    private static readonly string[] _sendToAllFieldNames = new string[] { "allButSelf", "path", "payload" };
    private static readonly uint[] _sendToAllFieldTags = new uint[] { 16, 10, 26 };
    public static SendToAll DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SendToAll DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SendToAll ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_SendToAll__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SendToAll, SendToAll.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_SendToAll__FieldAccessorTable; }
    }
    
    public const int PathFieldNumber = 1;
    private bool hasPath;
    private string path_ = "";
    public bool HasPath {
      get { return hasPath; }
    }
    public string Path {
      get { return path_; }
    }
    
    public const int AllButSelfFieldNumber = 2;
    private bool hasAllButSelf;
    private bool allButSelf_;
    public bool HasAllButSelf {
      get { return hasAllButSelf; }
    }
    public bool AllButSelf {
      get { return allButSelf_; }
    }
    
    public const int PayloadFieldNumber = 3;
    private bool hasPayload;
    private global::Akka.Cluster.PubSub.Serializers.Proto.Payload payload_;
    public bool HasPayload {
      get { return hasPayload; }
    }
    public global::Akka.Cluster.PubSub.Serializers.Proto.Payload Payload {
      get { return payload_ ?? global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPath) return false;
        if (!hasAllButSelf) return false;
        if (!hasPayload) return false;
        if (!Payload.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _sendToAllFieldNames;
      if (hasPath) {
        output.WriteString(1, field_names[1], Path);
      }
      if (hasAllButSelf) {
        output.WriteBool(2, field_names[0], AllButSelf);
      }
      if (hasPayload) {
        output.WriteMessage(3, field_names[2], Payload);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPath) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Path);
        }
        if (hasAllButSelf) {
          size += pb::CodedOutputStream.ComputeBoolSize(2, AllButSelf);
        }
        if (hasPayload) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Payload);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SendToAll ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SendToAll ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SendToAll ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SendToAll ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SendToAll ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SendToAll ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SendToAll ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SendToAll ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SendToAll ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SendToAll ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SendToAll MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SendToAll prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<SendToAll, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SendToAll cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SendToAll result;
      
      private SendToAll PrepareBuilder() {
        if (resultIsReadOnly) {
          SendToAll original = result;
          result = new SendToAll();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SendToAll MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll.Descriptor; }
      }
      
      public override SendToAll DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll.DefaultInstance; }
      }
      
      public override SendToAll BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SendToAll) {
          return MergeFrom((SendToAll) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SendToAll other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.SendToAll.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPath) {
          Path = other.Path;
        }
        if (other.HasAllButSelf) {
          AllButSelf = other.AllButSelf;
        }
        if (other.HasPayload) {
          MergePayload(other.Payload);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_sendToAllFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _sendToAllFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasPath = input.ReadString(ref result.path_);
              break;
            }
            case 16: {
              result.hasAllButSelf = input.ReadBool(ref result.allButSelf_);
              break;
            }
            case 26: {
              global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder subBuilder = global::Akka.Cluster.PubSub.Serializers.Proto.Payload.CreateBuilder();
              if (result.hasPayload) {
                subBuilder.MergeFrom(Payload);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Payload = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPath {
        get { return result.hasPath; }
      }
      public string Path {
        get { return result.Path; }
        set { SetPath(value); }
      }
      public Builder SetPath(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPath = true;
        result.path_ = value;
        return this;
      }
      public Builder ClearPath() {
        PrepareBuilder();
        result.hasPath = false;
        result.path_ = "";
        return this;
      }
      
      public bool HasAllButSelf {
        get { return result.hasAllButSelf; }
      }
      public bool AllButSelf {
        get { return result.AllButSelf; }
        set { SetAllButSelf(value); }
      }
      public Builder SetAllButSelf(bool value) {
        PrepareBuilder();
        result.hasAllButSelf = true;
        result.allButSelf_ = value;
        return this;
      }
      public Builder ClearAllButSelf() {
        PrepareBuilder();
        result.hasAllButSelf = false;
        result.allButSelf_ = false;
        return this;
      }
      
      public bool HasPayload {
       get { return result.hasPayload; }
      }
      public global::Akka.Cluster.PubSub.Serializers.Proto.Payload Payload {
        get { return result.Payload; }
        set { SetPayload(value); }
      }
      public Builder SetPayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPayload = true;
        result.payload_ = value;
        return this;
      }
      public Builder SetPayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPayload = true;
        result.payload_ = builderForValue.Build();
        return this;
      }
      public Builder MergePayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPayload &&
            result.payload_ != global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance) {
            result.payload_ = global::Akka.Cluster.PubSub.Serializers.Proto.Payload.CreateBuilder(result.payload_).MergeFrom(value).BuildPartial();
        } else {
          result.payload_ = value;
        }
        result.hasPayload = true;
        return this;
      }
      public Builder ClearPayload() {
        PrepareBuilder();
        result.hasPayload = false;
        result.payload_ = null;
        return this;
      }
    }
    static SendToAll() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Publish : pb::GeneratedMessage<Publish, Publish.Builder> {
    private Publish() { }
    private static readonly Publish defaultInstance = new Publish().MakeReadOnly();
    private static readonly string[] _publishFieldNames = new string[] { "payload", "topic" };
    private static readonly uint[] _publishFieldTags = new uint[] { 26, 10 };
    public static Publish DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Publish DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Publish ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Publish__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Publish, Publish.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Publish__FieldAccessorTable; }
    }
    
    public const int TopicFieldNumber = 1;
    private bool hasTopic;
    private string topic_ = "";
    public bool HasTopic {
      get { return hasTopic; }
    }
    public string Topic {
      get { return topic_; }
    }
    
    public const int PayloadFieldNumber = 3;
    private bool hasPayload;
    private global::Akka.Cluster.PubSub.Serializers.Proto.Payload payload_;
    public bool HasPayload {
      get { return hasPayload; }
    }
    public global::Akka.Cluster.PubSub.Serializers.Proto.Payload Payload {
      get { return payload_ ?? global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasTopic) return false;
        if (!hasPayload) return false;
        if (!Payload.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _publishFieldNames;
      if (hasTopic) {
        output.WriteString(1, field_names[1], Topic);
      }
      if (hasPayload) {
        output.WriteMessage(3, field_names[0], Payload);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTopic) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Topic);
        }
        if (hasPayload) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Payload);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Publish ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Publish ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Publish ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Publish ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Publish ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Publish ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Publish ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Publish ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Publish ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Publish ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Publish MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Publish prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Publish, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Publish cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Publish result;
      
      private Publish PrepareBuilder() {
        if (resultIsReadOnly) {
          Publish original = result;
          result = new Publish();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Publish MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Publish.Descriptor; }
      }
      
      public override Publish DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Publish.DefaultInstance; }
      }
      
      public override Publish BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Publish) {
          return MergeFrom((Publish) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Publish other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Publish.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTopic) {
          Topic = other.Topic;
        }
        if (other.HasPayload) {
          MergePayload(other.Payload);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_publishFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _publishFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasTopic = input.ReadString(ref result.topic_);
              break;
            }
            case 26: {
              global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder subBuilder = global::Akka.Cluster.PubSub.Serializers.Proto.Payload.CreateBuilder();
              if (result.hasPayload) {
                subBuilder.MergeFrom(Payload);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Payload = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTopic {
        get { return result.hasTopic; }
      }
      public string Topic {
        get { return result.Topic; }
        set { SetTopic(value); }
      }
      public Builder SetTopic(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTopic = true;
        result.topic_ = value;
        return this;
      }
      public Builder ClearTopic() {
        PrepareBuilder();
        result.hasTopic = false;
        result.topic_ = "";
        return this;
      }
      
      public bool HasPayload {
       get { return result.hasPayload; }
      }
      public global::Akka.Cluster.PubSub.Serializers.Proto.Payload Payload {
        get { return result.Payload; }
        set { SetPayload(value); }
      }
      public Builder SetPayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPayload = true;
        result.payload_ = value;
        return this;
      }
      public Builder SetPayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPayload = true;
        result.payload_ = builderForValue.Build();
        return this;
      }
      public Builder MergePayload(global::Akka.Cluster.PubSub.Serializers.Proto.Payload value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPayload &&
            result.payload_ != global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance) {
            result.payload_ = global::Akka.Cluster.PubSub.Serializers.Proto.Payload.CreateBuilder(result.payload_).MergeFrom(value).BuildPartial();
        } else {
          result.payload_ = value;
        }
        result.hasPayload = true;
        return this;
      }
      public Builder ClearPayload() {
        PrepareBuilder();
        result.hasPayload = false;
        result.payload_ = null;
        return this;
      }
    }
    static Publish() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Payload : pb::GeneratedMessage<Payload, Payload.Builder> {
    private Payload() { }
    private static readonly Payload defaultInstance = new Payload().MakeReadOnly();
    private static readonly string[] _payloadFieldNames = new string[] { "enclosedMessage", "messageManifest", "serializerId" };
    private static readonly uint[] _payloadFieldTags = new uint[] { 10, 34, 16 };
    public static Payload DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Payload DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Payload ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Payload__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Payload, Payload.Builder> InternalFieldAccessors {
      get { return global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.internal__static_Payload__FieldAccessorTable; }
    }
    
    public const int EnclosedMessageFieldNumber = 1;
    private bool hasEnclosedMessage;
    private pb::ByteString enclosedMessage_ = pb::ByteString.Empty;
    public bool HasEnclosedMessage {
      get { return hasEnclosedMessage; }
    }
    public pb::ByteString EnclosedMessage {
      get { return enclosedMessage_; }
    }
    
    public const int SerializerIdFieldNumber = 2;
    private bool hasSerializerId;
    private int serializerId_;
    public bool HasSerializerId {
      get { return hasSerializerId; }
    }
    public int SerializerId {
      get { return serializerId_; }
    }
    
    public const int MessageManifestFieldNumber = 4;
    private bool hasMessageManifest;
    private pb::ByteString messageManifest_ = pb::ByteString.Empty;
    public bool HasMessageManifest {
      get { return hasMessageManifest; }
    }
    public pb::ByteString MessageManifest {
      get { return messageManifest_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasEnclosedMessage) return false;
        if (!hasSerializerId) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _payloadFieldNames;
      if (hasEnclosedMessage) {
        output.WriteBytes(1, field_names[0], EnclosedMessage);
      }
      if (hasSerializerId) {
        output.WriteInt32(2, field_names[2], SerializerId);
      }
      if (hasMessageManifest) {
        output.WriteBytes(4, field_names[1], MessageManifest);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasEnclosedMessage) {
          size += pb::CodedOutputStream.ComputeBytesSize(1, EnclosedMessage);
        }
        if (hasSerializerId) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, SerializerId);
        }
        if (hasMessageManifest) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, MessageManifest);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Payload ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Payload ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Payload ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Payload ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Payload ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Payload ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Payload ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Payload ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Payload ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Payload ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Payload MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Payload prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Payload, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Payload cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Payload result;
      
      private Payload PrepareBuilder() {
        if (resultIsReadOnly) {
          Payload original = result;
          result = new Payload();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Payload MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Payload.Descriptor; }
      }
      
      public override Payload DefaultInstanceForType {
        get { return global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance; }
      }
      
      public override Payload BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Payload) {
          return MergeFrom((Payload) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Payload other) {
        if (other == global::Akka.Cluster.PubSub.Serializers.Proto.Payload.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEnclosedMessage) {
          EnclosedMessage = other.EnclosedMessage;
        }
        if (other.HasSerializerId) {
          SerializerId = other.SerializerId;
        }
        if (other.HasMessageManifest) {
          MessageManifest = other.MessageManifest;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_payloadFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _payloadFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasEnclosedMessage = input.ReadBytes(ref result.enclosedMessage_);
              break;
            }
            case 16: {
              result.hasSerializerId = input.ReadInt32(ref result.serializerId_);
              break;
            }
            case 34: {
              result.hasMessageManifest = input.ReadBytes(ref result.messageManifest_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEnclosedMessage {
        get { return result.hasEnclosedMessage; }
      }
      public pb::ByteString EnclosedMessage {
        get { return result.EnclosedMessage; }
        set { SetEnclosedMessage(value); }
      }
      public Builder SetEnclosedMessage(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEnclosedMessage = true;
        result.enclosedMessage_ = value;
        return this;
      }
      public Builder ClearEnclosedMessage() {
        PrepareBuilder();
        result.hasEnclosedMessage = false;
        result.enclosedMessage_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasSerializerId {
        get { return result.hasSerializerId; }
      }
      public int SerializerId {
        get { return result.SerializerId; }
        set { SetSerializerId(value); }
      }
      public Builder SetSerializerId(int value) {
        PrepareBuilder();
        result.hasSerializerId = true;
        result.serializerId_ = value;
        return this;
      }
      public Builder ClearSerializerId() {
        PrepareBuilder();
        result.hasSerializerId = false;
        result.serializerId_ = 0;
        return this;
      }
      
      public bool HasMessageManifest {
        get { return result.hasMessageManifest; }
      }
      public pb::ByteString MessageManifest {
        get { return result.MessageManifest; }
        set { SetMessageManifest(value); }
      }
      public Builder SetMessageManifest(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessageManifest = true;
        result.messageManifest_ = value;
        return this;
      }
      public Builder ClearMessageManifest() {
        PrepareBuilder();
        result.hasMessageManifest = false;
        result.messageManifest_ = pb::ByteString.Empty;
        return this;
      }
    }
    static Payload() {
      object.ReferenceEquals(global::Akka.Cluster.PubSub.Serializers.Proto.DistributedPubSubMessages.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
