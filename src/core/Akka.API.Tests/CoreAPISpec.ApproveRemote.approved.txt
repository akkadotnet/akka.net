[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Metrics")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Sharding")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tests.MultiNode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Cluster.Tools")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.TestKit")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.TestKit.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests.MultiNode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Akka.Remote.Tests.Performance")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.InteropServices.GuidAttribute("78986bdb-73f7-4532-8e03-1c9ccbe8148e")]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName="")]
namespace Akka.Remote
{
    public class AddressUid : Akka.Actor.IExtension
    {
        public readonly int Uid;
        public AddressUid() { }
    }
    public class AddressUidExtension : Akka.Actor.ExtensionIdProvider<Akka.Remote.AddressUid>
    {
        public AddressUidExtension() { }
        public override Akka.Remote.AddressUid CreateExtension(Akka.Actor.ExtendedActorSystem system) { }
        public static int Uid(Akka.Actor.ActorSystem system) { }
    }
    public class AkkaProtocolSettings
    {
        public AkkaProtocolSettings(Akka.Configuration.Config config) { }
        public System.TimeSpan HandshakeTimeout { get; }
        public Akka.Configuration.Config TransportFailureDetectorConfig { get; }
        public string TransportFailureDetectorImplementationClass { get; }
        public System.TimeSpan TransportHeartBeatInterval { get; }
    }
    public sealed class AssociatedEvent : Akka.Remote.AssociationEvent
    {
        public AssociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }
        public override bool IsInbound { get; set; }
        public override Akka.Actor.Address LocalAddress { get; set; }
        public override Akka.Actor.Address RemoteAddress { get; set; }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public sealed class AssociationErrorEvent : Akka.Remote.AssociationEvent
    {
        public AssociationErrorEvent(System.Exception cause, Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound, Akka.Event.LogLevel level) { }
        public System.Exception Cause { get; }
        public override bool IsInbound { get; set; }
        public override Akka.Actor.Address LocalAddress { get; set; }
        public override Akka.Actor.Address RemoteAddress { get; set; }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
    public abstract class AssociationEvent : Akka.Remote.RemotingLifecycleEvent
    {
        protected string EventName;
        protected AssociationEvent() { }
        public abstract bool IsInbound { get; set; }
        public abstract Akka.Actor.Address LocalAddress { get; set; }
        public abstract Akka.Actor.Address RemoteAddress { get; set; }
        public override string ToString() { }
    }
    public delegate long Clock();
    public class Deadline
    {
        public Deadline(System.DateTime when) { }
        public bool HasTimeLeft { get; }
        public bool IsOverdue { get; }
        public static Akka.Remote.Deadline Now { get; }
        public System.TimeSpan TimeLeft { get; }
        public System.DateTime When { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public static Akka.Remote.Deadline +(Akka.Remote.Deadline deadline, System.TimeSpan duration) { }
        public static Akka.Remote.Deadline +(Akka.Remote.Deadline deadline, System.Nullable<System.TimeSpan> duration) { }
    }
    public class DeadlineFailureDetector : Akka.Remote.FailureDetector
    {
        [System.ObsoleteAttribute("Use DeadlineFailureDetector(acceptableHeartbeatPause, heartbeatInterval, clock) i" +
            "nstead. [1.1.2]")]
        public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, Akka.Remote.Clock clock = null) { }
        public DeadlineFailureDetector(System.TimeSpan acceptableHeartbeatPause, System.TimeSpan heartbeatInterval, Akka.Remote.Clock clock = null) { }
        public DeadlineFailureDetector(Akka.Configuration.Config config, Akka.Event.EventStream eventStream) { }
        public override bool IsAvailable { get; }
        public override bool IsMonitoring { get; }
        public override void HeartBeat() { }
    }
    public class DefaultFailureDetectorRegistry<T> : Akka.Remote.IFailureDetectorRegistry<T>
    {
        public DefaultFailureDetectorRegistry(System.Func<Akka.Remote.FailureDetector> factory) { }
        public void Heartbeat(T resource) { }
        public bool IsAvailable(T resource) { }
        public bool IsMonitoring(T resource) { }
        public void Remove(T resource) { }
        public void Reset() { }
    }
    public sealed class DisassociatedEvent : Akka.Remote.AssociationEvent
    {
        public DisassociatedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, bool inbound) { }
        public override bool IsInbound { get; set; }
        public override Akka.Actor.Address LocalAddress { get; set; }
        public override Akka.Actor.Address RemoteAddress { get; set; }
        public override Akka.Event.LogLevel LogLevel() { }
    }
    public abstract class FailureDetector
    {
        public static readonly Akka.Remote.Clock DefaultClock;
        protected FailureDetector() { }
        public abstract bool IsAvailable { get; }
        public abstract bool IsMonitoring { get; }
        public abstract void HeartBeat();
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class static FailureDetectorLoader
    {
        public static Akka.Remote.FailureDetector Load(string fqcn, Akka.Configuration.Config config, Akka.Actor.ActorSystem system) { }
        public static Akka.Remote.FailureDetector LoadFailureDetector(this Akka.Actor.IActorContext context, string fqcn, Akka.Configuration.Config config) { }
    }
    public interface IFailureDetectorRegistry<in T>
    {
        void Heartbeat(T resource);
        bool IsAvailable(T resource);
        bool IsMonitoring(T resource);
        void Remove(T resource);
        void Reset();
    }
    [Akka.Annotations.InternalApiAttribute()]
    public interface IRemoteActorRefProvider : Akka.Actor.IActorRefProvider
    {
        Akka.Actor.IInternalActorRef RemoteDaemon { get; }
        Akka.Remote.RemoteSettings RemoteSettings { get; }
        Akka.Actor.IActorRef RemoteWatcher { get; }
        Akka.Remote.RemoteTransport Transport { get; }
        bool HasAddress(Akka.Actor.Address address);
        Akka.Actor.IActorRef InternalResolveActorRef(string path);
        Akka.Actor.Deploy LookUpRemotes(System.Collections.Generic.IEnumerable<string> p);
        void Quarantine(Akka.Actor.Address address, System.Nullable<int> uid);
        Akka.Actor.IInternalActorRef ResolveActorRefWithLocalAddress(string path, Akka.Actor.Address localAddress);
        void UseActorOnNode(Akka.Remote.RemoteActorRef actor, Akka.Actor.Props props, Akka.Actor.Deploy deploy, Akka.Actor.IInternalActorRef supervisor);
    }
    [Akka.Annotations.InternalApiAttribute()]
    public interface IRemoteRef : Akka.Actor.IActorRefScope { }
    public class PhiAccrualFailureDetector : Akka.Remote.FailureDetector
    {
        public PhiAccrualFailureDetector(double threshold, int maxSampleSize, System.TimeSpan minStdDeviation, System.TimeSpan acceptableHeartbeatPause, System.TimeSpan firstHeartbeatEstimate, Akka.Remote.Clock clock = null) { }
        public PhiAccrualFailureDetector(Akka.Configuration.Config config, Akka.Event.EventStream ev) { }
        protected PhiAccrualFailureDetector(Akka.Remote.Clock clock) { }
        public override bool IsAvailable { get; }
        public override bool IsMonitoring { get; }
        public override void HeartBeat() { }
    }
    public sealed class QuarantinedEvent : Akka.Remote.RemotingLifecycleEvent
    {
        public QuarantinedEvent(Akka.Actor.Address address, int uid) { }
        public Akka.Actor.Address Address { get; }
        public int Uid { get; }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
    public class RemoteActorRef : Akka.Actor.InternalActorRefBase, Akka.Actor.IActorRefScope, Akka.Remote.IRemoteRef
    {
        public RemoteActorRef(Akka.Remote.RemoteTransport remote, Akka.Actor.Address localAddressToUse, Akka.Actor.ActorPath path, Akka.Actor.IInternalActorRef parent, Akka.Actor.Props props, Akka.Actor.Deploy deploy) { }
        public override bool IsLocal { get; }
        [System.ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
        public override bool IsTerminated { get; }
        public Akka.Actor.Address LocalAddressToUse { get; }
        public override Akka.Actor.IInternalActorRef Parent { get; }
        public override Akka.Actor.ActorPath Path { get; }
        public override Akka.Actor.IActorRefProvider Provider { get; }
        public override Akka.Actor.IActorRef GetChild(System.Collections.Generic.IEnumerable<string> name) { }
        public bool IsWatchIntercepted(Akka.Actor.IActorRef watchee, Akka.Actor.IActorRef watcher) { }
        public override void Restart(System.Exception cause) { }
        public override void Resume(System.Exception causedByFailure = null) { }
        public override void SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage message) { }
        public override void Start() { }
        public override void Stop() { }
        public override void Suspend() { }
        protected override void TellInternal(object message, Akka.Actor.IActorRef sender) { }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public class RemoteActorRefProvider : Akka.Actor.IActorRefProvider, Akka.Remote.IRemoteActorRefProvider
    {
        public RemoteActorRefProvider(string systemName, Akka.Actor.Settings settings, Akka.Event.EventStream eventStream) { }
        public Akka.Actor.IActorRef DeadLetters { get; }
        public Akka.Actor.Address DefaultAddress { get; }
        public Akka.Actor.Deployer Deployer { get; set; }
        public Akka.Actor.LocalActorRef Guardian { get; }
        public Akka.Actor.IInternalActorRef RemoteDaemon { get; }
        public Akka.Remote.RemoteSettings RemoteSettings { get; }
        public Akka.Actor.IActorRef RemoteWatcher { get; }
        public Akka.Actor.IInternalActorRef RootGuardian { get; }
        public Akka.Actor.ActorPath RootPath { get; }
        public Akka.Serialization.Information SerializationInformation { get; }
        public Akka.Actor.Settings Settings { get; }
        public Akka.Actor.LocalActorRef SystemGuardian { get; }
        public Akka.Actor.IInternalActorRef TempContainer { get; }
        public System.Threading.Tasks.Task TerminationTask { get; }
        public Akka.Remote.RemoteTransport Transport { get; }
        public Akka.Actor.IInternalActorRef ActorOf(Akka.Actor.Internal.ActorSystemImpl system, Akka.Actor.Props props, Akka.Actor.IInternalActorRef supervisor, Akka.Actor.ActorPath path, bool systemService, Akka.Actor.Deploy deploy, bool lookupDeploy, bool async) { }
        protected virtual Akka.Actor.IActorRef CreateRemoteDeploymentWatcher(Akka.Actor.Internal.ActorSystemImpl system) { }
        protected virtual Akka.Actor.IInternalActorRef CreateRemoteRef(Akka.Actor.ActorPath actorPath, Akka.Actor.Address localAddress) { }
        protected virtual Akka.Actor.IActorRef CreateRemoteWatcher(Akka.Actor.Internal.ActorSystemImpl system) { }
        protected Akka.Remote.DefaultFailureDetectorRegistry<Akka.Actor.Address> CreateRemoteWatcherFailureDetector(Akka.Actor.ActorSystem system) { }
        public Akka.Actor.Address GetExternalAddressFor(Akka.Actor.Address address) { }
        public bool HasAddress(Akka.Actor.Address address) { }
        public virtual void Init(Akka.Actor.Internal.ActorSystemImpl system) { }
        public Akka.Actor.IActorRef InternalResolveActorRef(string path) { }
        public Akka.Actor.Deploy LookUpRemotes(System.Collections.Generic.IEnumerable<string> p) { }
        public void Quarantine(Akka.Actor.Address address, System.Nullable<int> uid) { }
        public void RegisterTempActor(Akka.Actor.IInternalActorRef actorRef, Akka.Actor.ActorPath path) { }
        public Akka.Actor.IActorRef ResolveActorRef(string path) { }
        public Akka.Actor.IActorRef ResolveActorRef(Akka.Actor.ActorPath actorPath) { }
        public Akka.Actor.IInternalActorRef ResolveActorRefWithLocalAddress(string path, Akka.Actor.Address localAddress) { }
        public Akka.Actor.IActorRef RootGuardianAt(Akka.Actor.Address address) { }
        public Akka.Actor.ActorPath TempPath() { }
        public void UnregisterTempActor(Akka.Actor.ActorPath path) { }
        public void UseActorOnNode(Akka.Remote.RemoteActorRef actor, Akka.Actor.Props props, Akka.Actor.Deploy deploy, Akka.Actor.IInternalActorRef supervisor) { }
    }
    public class RemoteSettings
    {
        public static readonly string AkkaScheme;
        public RemoteSettings(Akka.Configuration.Config config) { }
        public System.Collections.Generic.IDictionary<string, string> Adapters { get; set; }
        public System.TimeSpan BackoffPeriod { get; set; }
        public System.TimeSpan CommandAckTimeout { get; set; }
        public Akka.Configuration.Config Config { get; }
        public string Dispatcher { get; set; }
        public System.TimeSpan FlushWait { get; set; }
        public System.TimeSpan InitialSysMsgDeliveryTimeout { get; set; }
        public int LogBufferSizeExceeding { get; set; }
        public bool LogReceive { get; set; }
        public bool LogSend { get; set; }
        public System.Nullable<System.TimeSpan> QuarantineDuration { get; set; }
        public System.TimeSpan QuarantineSilentSystemTimeout { get; set; }
        public string RemoteLifecycleEventsLogLevel { get; set; }
        public System.TimeSpan RetryGateClosedFor { get; set; }
        public System.TimeSpan ShutdownTimeout { get; set; }
        public System.TimeSpan StartupTimeout { get; set; }
        public System.TimeSpan SysMsgAckTimeout { get; set; }
        public int SysMsgBufferSize { get; set; }
        public int SysResendLimit { get; set; }
        public System.TimeSpan SysResendTimeout { get; set; }
        public System.Collections.Generic.IList<string> TransportNames { get; set; }
        public TransportSettings[] Transports { get; set; }
        public System.Collections.Generic.HashSet<string> TrustedSelectionPaths { get; set; }
        public bool UntrustedMode { get; set; }
        public bool UsePassiveConnections { get; set; }
        public Akka.Configuration.Config WatchFailureDetectorConfig { get; set; }
        public string WatchFailureDetectorImplementationClass { get; set; }
        public System.TimeSpan WatchHeartBeatInterval { get; set; }
        public System.TimeSpan WatchHeartbeatExpectedResponseAfter { get; set; }
        public System.TimeSpan WatchUnreachableReaperInterval { get; set; }
        public Akka.Actor.Props ConfigureDispatcher(Akka.Actor.Props props) { }
        public class TransportSettings
        {
            public TransportSettings(Akka.Configuration.Config config) { }
            public System.Collections.Generic.IList<string> Adapters { get; set; }
            public Akka.Configuration.Config Config { get; set; }
            public string TransportClass { get; set; }
        }
    }
    [Akka.Annotations.InternalApiAttribute()]
    public abstract class RemoteTransport
    {
        protected RemoteTransport(Akka.Actor.ExtendedActorSystem system, Akka.Remote.RemoteActorRefProvider provider) { }
        public abstract System.Collections.Generic.ISet<Akka.Actor.Address> Addresses { get; }
        public abstract Akka.Actor.Address DefaultAddress { get; }
        public Akka.Event.ILoggingAdapter Log { get; set; }
        public Akka.Remote.RemoteActorRefProvider Provider { get; }
        public Akka.Actor.ExtendedActorSystem System { get; }
        protected bool UseUntrustedMode { get; set; }
        public bool logRemoteLifeCycleEvents { get; set; }
        public abstract Akka.Actor.Address LocalAddressForRemote(Akka.Actor.Address remote);
        public abstract System.Threading.Tasks.Task<bool> ManagementCommand(object cmd);
        public abstract void Quarantine(Akka.Actor.Address address, System.Nullable<int> uid);
        public abstract void Send(object message, Akka.Actor.IActorRef sender, Akka.Remote.RemoteActorRef recipient);
        public abstract System.Threading.Tasks.Task Shutdown();
        public abstract void Start();
    }
    public class RemoteTransportException : Akka.Actor.AkkaException
    {
        public RemoteTransportException(string message, System.Exception cause = null) { }
    }
    public class RemoteWatcher : Akka.Actor.UntypedActor, Akka.Dispatch.IRequiresMessageQueue<Akka.Dispatch.IUnboundedMessageQueueSemantics>
    {
        protected readonly Akka.Event.ILoggingAdapter Log;
        protected readonly System.Collections.Generic.Dictionary<Akka.Actor.Address, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> WatcheeByNodes;
        protected readonly System.Collections.Generic.Dictionary<Akka.Actor.IInternalActorRef, System.Collections.Generic.HashSet<Akka.Actor.IInternalActorRef>> Watching;
        public RemoteWatcher(Akka.Remote.IFailureDetectorRegistry<Akka.Actor.Address> failureDetector, System.TimeSpan heartbeatInterval, System.TimeSpan unreachableReaperInterval, System.TimeSpan heartbeatExpectedResponseAfter) { }
        protected System.Collections.Generic.HashSet<Akka.Actor.Address> Unreachable { get; }
        protected System.Collections.Generic.ICollection<Akka.Actor.Address> WatchingNodes { get; }
        protected void AddWatching(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        protected override void OnReceive(object message) { }
        protected override void PostStop() { }
        public static Akka.Actor.Props Props(Akka.Remote.IFailureDetectorRegistry<Akka.Actor.Address> failureDetector, System.TimeSpan heartbeatInterval, System.TimeSpan unreachableReaperInterval, System.TimeSpan heartbeatExpectedResponseAfter) { }
        protected virtual void PublishAddressTerminated(Akka.Actor.Address address) { }
        protected virtual void Quarantine(Akka.Actor.Address address, System.Nullable<int> addressUid) { }
        protected void RemoveWatch(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        protected void RemoveWatchee(Akka.Actor.IInternalActorRef watchee) { }
        protected void UnwatchNode(Akka.Actor.Address watcheeAddress) { }
        protected virtual void WatchNode(Akka.Actor.IInternalActorRef watchee) { }
        public sealed class ExpectedFirstHeartbeat
        {
            public ExpectedFirstHeartbeat(Akka.Actor.Address from) { }
            public Akka.Actor.Address From { get; }
        }
        public sealed class Heartbeat
        {
            public static Akka.Remote.RemoteWatcher.Heartbeat Instance { get; }
        }
        public class HeartbeatRsp
        {
            public HeartbeatRsp(int addressUid) { }
            public int AddressUid { get; }
        }
        public class HeartbeatTick
        {
            public static Akka.Remote.RemoteWatcher.HeartbeatTick Instance { get; }
        }
        public class ReapUnreachableTick
        {
            public static Akka.Remote.RemoteWatcher.ReapUnreachableTick Instance { get; }
        }
        public sealed class Stats
        {
            public static Akka.Remote.RemoteWatcher.Stats Empty;
            public Stats(int watching, int watchingNodes) { }
            public Stats(int watching, int watchingNodes, System.Collections.Immutable.ImmutableHashSet<System.ValueTuple<Akka.Actor.IActorRef, Akka.Actor.IActorRef>> watchingRefs, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.Address> watchingAddresses) { }
            public int Watching { get; }
            public System.Collections.Immutable.ImmutableHashSet<Akka.Actor.Address> WatchingAddresses { get; }
            public int WatchingNodes { get; }
            public System.Collections.Immutable.ImmutableHashSet<System.ValueTuple<Akka.Actor.IActorRef, Akka.Actor.IActorRef>> WatchingRefs { get; }
            public Akka.Remote.RemoteWatcher.Stats Copy(int watching, int watchingNodes, System.Collections.Immutable.ImmutableHashSet<System.ValueTuple<Akka.Actor.IActorRef, Akka.Actor.IActorRef>> watchingRefs = null, System.Collections.Immutable.ImmutableHashSet<Akka.Actor.Address> watchingAddresses = null) { }
            public static Akka.Remote.RemoteWatcher.Stats Counts(int watching, int watchingNodes) { }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
            public override string ToString() { }
        }
        public sealed class UnwatchRemote : Akka.Remote.RemoteWatcher.WatchCommand
        {
            public UnwatchRemote(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        }
        public abstract class WatchCommand
        {
            protected WatchCommand(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
            public Akka.Actor.IInternalActorRef Watchee { get; }
            public Akka.Actor.IInternalActorRef Watcher { get; }
        }
        public sealed class WatchRemote : Akka.Remote.RemoteWatcher.WatchCommand
        {
            public WatchRemote(Akka.Actor.IInternalActorRef watchee, Akka.Actor.IInternalActorRef watcher) { }
        }
    }
    public sealed class RemotingErrorEvent : Akka.Remote.RemotingLifecycleEvent
    {
        public RemotingErrorEvent(System.Exception cause) { }
        public System.Exception Cause { get; }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
    public abstract class RemotingLifecycleEvent
    {
        protected RemotingLifecycleEvent() { }
        public abstract Akka.Event.LogLevel LogLevel();
    }
    public sealed class RemotingListenEvent : Akka.Remote.RemotingLifecycleEvent
    {
        public RemotingListenEvent(System.Collections.Generic.IList<Akka.Actor.Address> listenAddresses) { }
        public System.Collections.Generic.IList<Akka.Actor.Address> ListenAddresses { get; }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
    public sealed class RemotingShutdownEvent : Akka.Remote.RemotingLifecycleEvent
    {
        public RemotingShutdownEvent() { }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
    public sealed class ThisActorSystemQuarantinedEvent : Akka.Remote.RemotingLifecycleEvent
    {
        public ThisActorSystemQuarantinedEvent(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress) { }
        public Akka.Actor.Address LocalAddress { get; }
        public Akka.Actor.Address RemoteAddress { get; }
        public override Akka.Event.LogLevel LogLevel() { }
        public override string ToString() { }
    }
}
namespace Akka.Remote.Routing
{
    public sealed class RemoteRouterConfig : Akka.Routing.Pool, System.IEquatable<Akka.Routing.RouterConfig>
    {
        public RemoteRouterConfig(Akka.Routing.Pool local, System.Collections.Generic.IEnumerable<Akka.Actor.Address> nodes) { }
        public override Akka.Routing.Resizer Resizer { get; }
        public override string RouterDispatcher { get; }
        public override Akka.Actor.SupervisorStrategy SupervisorStrategy { get; }
        public override Akka.Routing.Router CreateRouter(Akka.Actor.ActorSystem system) { }
        public bool Equals(Akka.Routing.RouterConfig other) { }
        public override int GetNrOfInstances(Akka.Actor.ActorSystem system) { }
        public override Akka.Util.ISurrogate ToSurrogate(Akka.Actor.ActorSystem system) { }
        public override Akka.Routing.RouterConfig WithFallback(Akka.Routing.RouterConfig routerConfig) { }
        public class RemoteRouterConfigSurrogate : Akka.Util.ISurrogate
        {
            public RemoteRouterConfigSurrogate() { }
            public Akka.Routing.Pool Local { get; set; }
            public Akka.Actor.Address[] Nodes { get; set; }
            public Akka.Util.ISurrogated FromSurrogate(Akka.Actor.ActorSystem system) { }
        }
    }
}
namespace Akka.Remote.Serialization
{
    public class DaemonMsgCreateSerializer : Akka.Serialization.Serializer
    {
        public DaemonMsgCreateSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public class MessageContainerSerializer : Akka.Serialization.Serializer
    {
        public MessageContainerSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public sealed class MiscMessageSerializer : Akka.Serialization.SerializerWithStringManifest
    {
        public MiscMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override object FromBinary(byte[] bytes, string manifest) { }
        public override string Manifest(object obj) { }
        public override byte[] ToBinary(object obj) { }
    }
    public sealed class PrimitiveSerializers : Akka.Serialization.Serializer
    {
        public PrimitiveSerializers(Akka.Actor.ExtendedActorSystem system) { }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public class ProtobufSerializer : Akka.Serialization.Serializer
    {
        public ProtobufSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
    public sealed class SystemMessageSerializer : Akka.Serialization.Serializer
    {
        public SystemMessageSerializer(Akka.Actor.ExtendedActorSystem system) { }
        public override bool IncludeManifest { get; }
        public override object FromBinary(byte[] bytes, System.Type type) { }
        public override byte[] ToBinary(object obj) { }
    }
}
namespace Akka.Remote.Transport
{
    public abstract class AbstractTransportAdapter : Akka.Remote.Transport.Transport
    {
        protected Akka.Remote.Transport.Transport WrappedTransport;
        protected AbstractTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport) { }
        public override long MaximumPayloadBytes { get; }
        protected abstract Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }
        public override string SchemeIdentifier { get; }
        public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }
        protected abstract void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise);
        protected abstract System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask);
        public override bool IsResponsibleFor(Akka.Actor.Address remote) { }
        public override System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen() { }
        public override System.Threading.Tasks.Task<bool> Shutdown() { }
    }
    public abstract class Activity
    {
        protected Activity() { }
    }
    public sealed class ActorAssociationEventListener : Akka.Remote.Transport.IAssociationEventListener
    {
        public ActorAssociationEventListener(Akka.Actor.IActorRef actor) { }
        public Akka.Actor.IActorRef Actor { get; }
        public void Notify(Akka.Remote.Transport.IAssociationEvent ev) { }
    }
    public sealed class ActorHandleEventListener : Akka.Remote.Transport.IHandleEventListener
    {
        public readonly Akka.Actor.IActorRef Actor;
        public ActorHandleEventListener(Akka.Actor.IActorRef actor) { }
        public void Notify(Akka.Remote.Transport.IHandleEvent ev) { }
    }
    public abstract class ActorTransportAdapter : Akka.Remote.Transport.AbstractTransportAdapter
    {
        public static readonly System.TimeSpan AskTimeout;
        protected Akka.Actor.IActorRef modreq(System.Runtime.CompilerServices.IsVolatile) manager;
        protected ActorTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }
        protected abstract string ManagerName { get; }
        protected abstract Akka.Actor.Props ManagerProps { get; }
        protected override void InterceptAssociate(Akka.Actor.Address remoteAddress, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.AssociationHandle> statusPromise) { }
        protected override System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> InterceptListen(Akka.Actor.Address listenAddress, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> listenerTask) { }
        public override System.Threading.Tasks.Task<bool> Shutdown() { }
    }
    public class AkkaProtocolException : Akka.Actor.AkkaException
    {
        public AkkaProtocolException(string message, System.Exception cause = null) { }
    }
    public sealed class AssociateAttempt : Akka.Remote.Transport.Activity
    {
        public AssociateAttempt(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress) { }
        public Akka.Actor.Address LocalAddress { get; }
        public Akka.Actor.Address RemoteAddress { get; }
    }
    public abstract class AssociationHandle
    {
        protected AssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress) { }
        public Akka.Actor.Address LocalAddress { get; set; }
        public System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IHandleEventListener> ReadHandlerSource { get; set; }
        public Akka.Actor.Address RemoteAddress { get; set; }
        [System.ObsoleteAttribute("Use the method that states reasons to make sure disassociation reasons are logged" +
            ".")]
        public abstract void Disassociate();
        public void Disassociate(string reason, Akka.Event.ILoggingAdapter log) { }
        public override bool Equals(object obj) { }
        protected bool Equals(Akka.Remote.Transport.AssociationHandle other) { }
        public override int GetHashCode() { }
        public abstract bool Write(Google.Protobuf.ByteString payload);
    }
    public class AssociationRegistry
    {
        public AssociationRegistry() { }
        public static void Clear() { }
        public void ClearLog() { }
        public Akka.Util.Option<System.ValueTuple<Akka.Remote.Transport.IHandleEventListener, Akka.Remote.Transport.IHandleEventListener>> DeregisterAssociation(System.ValueTuple<Akka.Actor.Address, Akka.Actor.Address> key) { }
        public bool ExistsAssociation(Akka.Actor.Address initiatorAddress, Akka.Actor.Address remoteAddress) { }
        public static Akka.Remote.Transport.AssociationRegistry Get(string key) { }
        public Akka.Remote.Transport.IHandleEventListener GetRemoteReadHandlerFor(Akka.Remote.Transport.TestAssociationHandle localHandle) { }
        public void LogActivity(Akka.Remote.Transport.Activity activity) { }
        public System.Collections.Generic.IList<Akka.Remote.Transport.Activity> LogSnapshot() { }
        public void RegisterListenerPair(System.ValueTuple<Akka.Actor.Address, Akka.Actor.Address> key, System.ValueTuple<Akka.Remote.Transport.IHandleEventListener, Akka.Remote.Transport.IHandleEventListener> listeners) { }
        public void RegisterTransport(Akka.Remote.Transport.TestTransport transport, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener> associationEventListenerTask) { }
        public Akka.Remote.Transport.IHandleEventListener RemoteListenerRelativeTo(Akka.Remote.Transport.TestAssociationHandle handle, System.ValueTuple<Akka.Remote.Transport.IHandleEventListener, Akka.Remote.Transport.IHandleEventListener> listenerPair) { }
        public void Reset() { }
        public Akka.Util.Option<System.ValueTuple<Akka.Remote.Transport.TestTransport, System.Threading.Tasks.Task<Akka.Remote.Transport.IAssociationEventListener>>> TransportFor(Akka.Actor.Address address) { }
        public bool TransportsReady(params Akka.Actor.Address[] addresses) { }
    }
    public class Blackhole : Akka.Remote.Transport.ThrottleMode
    {
        public static Akka.Remote.Transport.Blackhole Instance { get; }
        public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }
        public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }
    }
    public sealed class DisassociateAttempt : Akka.Remote.Transport.Activity
    {
        public DisassociateAttempt(Akka.Actor.Address requestor, Akka.Actor.Address remote) { }
        public Akka.Actor.Address Remote { get; }
        public Akka.Actor.Address Requestor { get; }
    }
    public enum DisassociateInfo
    {
        Unknown = 0,
        Shutdown = 1,
        Quarantined = 2,
    }
    public sealed class Disassociated : Akka.Actor.INoSerializationVerificationNeeded, Akka.Event.IDeadLetterSuppression, Akka.Remote.Transport.IHandleEvent
    {
        public Disassociated(Akka.Remote.Transport.DisassociateInfo info) { }
    }
    public sealed class FailureInjectorException : Akka.Actor.AkkaException
    {
        public FailureInjectorException(string msg) { }
        public string Msg { get; }
    }
    public class FailureInjectorProvider : Akka.Remote.Transport.ITransportAdapterProvider
    {
        public FailureInjectorProvider() { }
        public Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system) { }
    }
    public interface IAssociationEvent : Akka.Actor.INoSerializationVerificationNeeded { }
    public interface IAssociationEventListener
    {
        void Notify(Akka.Remote.Transport.IAssociationEvent ev);
    }
    public interface IHandleEvent : Akka.Actor.INoSerializationVerificationNeeded { }
    public interface IHandleEventListener
    {
        void Notify(Akka.Remote.Transport.IHandleEvent ev);
    }
    public interface ITransportAdapterProvider
    {
        Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system);
    }
    public sealed class InboundAssociation : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IAssociationEvent
    {
        public InboundAssociation(Akka.Remote.Transport.AssociationHandle association) { }
        public Akka.Remote.Transport.AssociationHandle Association { get; }
    }
    public sealed class InboundPayload : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent
    {
        public InboundPayload(Google.Protobuf.ByteString payload) { }
        public Google.Protobuf.ByteString Payload { get; }
        public override string ToString() { }
    }
    public class InvalidAssociationException : Akka.Actor.AkkaException
    {
        public InvalidAssociationException(string message, System.Exception cause = null) { }
    }
    public sealed class ListenAttempt : Akka.Remote.Transport.Activity
    {
        public ListenAttempt(Akka.Actor.Address boundAddress) { }
        public Akka.Actor.Address BoundAddress { get; }
    }
    public class SchemeAugmenter
    {
        public readonly string AddedSchemeIdentifier;
        public SchemeAugmenter(string addedSchemeIdentifier) { }
        public string AugmentScheme(string originalScheme) { }
        public Akka.Actor.Address AugmentScheme(Akka.Actor.Address address) { }
        public string RemoveScheme(string scheme) { }
        public Akka.Actor.Address RemoveScheme(Akka.Actor.Address address) { }
    }
    public sealed class SetThrottle
    {
        public SetThrottle(Akka.Actor.Address address, Akka.Remote.Transport.ThrottleTransportAdapter.Direction direction, Akka.Remote.Transport.ThrottleMode mode) { }
        public Akka.Actor.Address Address { get; }
        public Akka.Remote.Transport.ThrottleTransportAdapter.Direction Direction { get; }
        public Akka.Remote.Transport.ThrottleMode Mode { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public static bool ==(Akka.Remote.Transport.SetThrottle left, Akka.Remote.Transport.SetThrottle right) { }
        public static bool !=(Akka.Remote.Transport.SetThrottle left, Akka.Remote.Transport.SetThrottle right) { }
    }
    public sealed class SetThrottleAck
    {
        public static Akka.Remote.Transport.SetThrottleAck Instance { get; }
    }
    public sealed class ShutdownAttempt : Akka.Remote.Transport.Activity
    {
        public ShutdownAttempt(Akka.Actor.Address boundAddress) { }
        public Akka.Actor.Address BoundAddress { get; }
    }
    public class SwitchableLoggedBehavior<TIn, TOut>
    {
        public SwitchableLoggedBehavior(System.Func<TIn, System.Threading.Tasks.Task<TOut>> defaultBehavior, System.Action<TIn> logCallback) { }
        public System.Func<TIn, System.Threading.Tasks.Task<TOut>> CurrentBehavior { get; }
        public System.Func<TIn, System.Threading.Tasks.Task<TOut>> DefaultBehavior { get; }
        public System.Action<TIn> LogCallback { get; }
        public System.Threading.Tasks.Task<TOut> Apply(TIn param) { }
        public void Pop() { }
        public void Push(System.Func<TIn, System.Threading.Tasks.Task<TOut>> behavior) { }
        public void PushConstant(TOut result) { }
        public System.Threading.Tasks.TaskCompletionSource<bool> PushDelayed() { }
        public void PushError(System.Exception e) { }
    }
    public sealed class TestAssociationHandle : Akka.Remote.Transport.AssociationHandle
    {
        public readonly bool Inbound;
        public TestAssociationHandle(Akka.Actor.Address localAddress, Akka.Actor.Address remoteAddress, Akka.Remote.Transport.TestTransport transport, bool inbound) { }
        public System.ValueTuple<Akka.Actor.Address, Akka.Actor.Address> Key { get; }
        public override void Disassociate() { }
        public override bool Write(Google.Protobuf.ByteString payload) { }
    }
    public class TestTransport : Akka.Remote.Transport.Transport
    {
        public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Actor.Address, Akka.Remote.Transport.AssociationHandle> AssociateBehavior;
        public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<Akka.Remote.Transport.TestAssociationHandle, bool> DisassociateBehavior;
        public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> ListenBehavior;
        public readonly Akka.Actor.Address LocalAddress;
        public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<bool, bool> ShutdownBehavior;
        public readonly Akka.Remote.Transport.SwitchableLoggedBehavior<System.ValueTuple<Akka.Remote.Transport.TestAssociationHandle, Google.Protobuf.ByteString>, bool> WriteBehavior;
        public TestTransport(Akka.Actor.ActorSystem system, Akka.Configuration.Config conf) { }
        public TestTransport(Akka.Actor.Address localAddress, Akka.Remote.Transport.AssociationRegistry registry, long maximumPayloadBytes = 32000, string schemeIdentifier = "test") { }
        public override System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress) { }
        public System.Threading.Tasks.Task<bool> DefaultDisassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }
        public System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> DefaultListen() { }
        public System.Threading.Tasks.Task Disassociate(Akka.Remote.Transport.TestAssociationHandle handle) { }
        public override bool IsResponsibleFor(Akka.Actor.Address remote) { }
        public override System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen() { }
        public override System.Threading.Tasks.Task<bool> Shutdown() { }
        public System.Threading.Tasks.Task<bool> Write(Akka.Remote.Transport.TestAssociationHandle handle, Google.Protobuf.ByteString payload) { }
    }
    public abstract class ThrottleMode : Akka.Actor.INoSerializationVerificationNeeded
    {
        protected ThrottleMode() { }
        public abstract System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens);
        public abstract System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens);
    }
    public class ThrottleTransportAdapter : Akka.Remote.Transport.ActorTransportAdapter
    {
        public const string Scheme = "trttl";
        public static readonly Akka.Util.Internal.AtomicCounter UniqueId;
        public ThrottleTransportAdapter(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ActorSystem system) { }
        protected override string ManagerName { get; }
        protected override Akka.Actor.Props ManagerProps { get; }
        protected override Akka.Remote.Transport.SchemeAugmenter SchemeAugmenter { get; }
        public override System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }
        public enum Direction
        {
            Send = 0,
            Receive = 1,
            Both = 2,
        }
    }
    public class ThrottlerProvider : Akka.Remote.Transport.ITransportAdapterProvider
    {
        public ThrottlerProvider() { }
        public Akka.Remote.Transport.Transport Create(Akka.Remote.Transport.Transport wrappedTransport, Akka.Actor.ExtendedActorSystem system) { }
    }
    public abstract class Transport
    {
        protected Transport() { }
        public Akka.Configuration.Config Config { get; set; }
        public virtual long MaximumPayloadBytes { get; set; }
        public virtual string SchemeIdentifier { get; set; }
        public Akka.Actor.ActorSystem System { get; set; }
        public abstract System.Threading.Tasks.Task<Akka.Remote.Transport.AssociationHandle> Associate(Akka.Actor.Address remoteAddress);
        public abstract bool IsResponsibleFor(Akka.Actor.Address remote);
        public abstract System.Threading.Tasks.Task<System.ValueTuple<Akka.Actor.Address, System.Threading.Tasks.TaskCompletionSource<Akka.Remote.Transport.IAssociationEventListener>>> Listen();
        public virtual System.Threading.Tasks.Task<bool> ManagementCommand(object message) { }
        public abstract System.Threading.Tasks.Task<bool> Shutdown();
    }
    public sealed class UnderlyingTransportError : Akka.Actor.INoSerializationVerificationNeeded, Akka.Remote.Transport.IHandleEvent
    {
        public UnderlyingTransportError(System.Exception cause, string message) { }
    }
    public class Unthrottled : Akka.Remote.Transport.ThrottleMode
    {
        public static Akka.Remote.Transport.Unthrottled Instance { get; }
        public override System.TimeSpan TimeToAvailable(long currentNanoTime, int tokens) { }
        public override System.ValueTuple<Akka.Remote.Transport.ThrottleMode, bool> TryConsumeTokens(long nanoTimeOfSend, int tokens) { }
    }
    public sealed class WriteAttempt : Akka.Remote.Transport.Activity
    {
        public WriteAttempt(Akka.Actor.Address sender, Akka.Actor.Address recipient, Google.Protobuf.ByteString payload) { }
        public Google.Protobuf.ByteString Payload { get; }
        public Akka.Actor.Address Recipient { get; }
        public Akka.Actor.Address Sender { get; }
    }
}